[{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\scripts\\fix-data.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/scripts\\fix-data.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DataSource } from 'typeorm';\r\nimport { Asset } from '../src/database/entities/asset.entity';\r\nimport { AssetPrice } from '../src/database/entities/asset-price.entity';\r\nimport { FundamentalData } from '../src/database/entities/fundamental-data.entity';\r\nimport { config } from 'dotenv';\r\n\r\nconfig();\r\n\r\nconst AppDataSource = new DataSource({\r\n    type: 'postgres',\r\n    host: process.env.DB_HOST || 'localhost',\r\n    port: parseInt(process.env.DB_PORT || '5432'),\r\n    username: process.env.DB_USER || 'invest_user',\r\n    password: process.env.DB_PASSWORD || 'invest_password',\r\n    database: process.env.DB_NAME || 'invest_db',\r\n    entities: [Asset, AssetPrice, FundamentalData],\r\n    synchronize: false,\r\n});\r\n\r\nasync function fixData() {\r\n    try {\r\n        await AppDataSource.initialize();\r\n        console.log('Database connected');\r\n\r\n        const assetRepository = AppDataSource.getRepository(Asset);\r\n        const priceRepository = AppDataSource.getRepository(AssetPrice);\r\n\r\n        const assets = await assetRepository.find();\r\n        console.log(`Found ${assets.length} assets`);\r\n\r\n        for (const asset of assets) {\r\n            console.log(`Processing ${asset.ticker}...`);\r\n\r\n            const prices = await priceRepository.find({\r\n                where: { assetId: asset.id },\r\n                order: { date: 'ASC' },\r\n            });\r\n\r\n            if (prices.length < 2) {\r\n                console.log(`Not enough prices for ${asset.ticker}`);\r\n                continue;\r\n            }\r\n\r\n            let updatedCount = 0;\r\n\r\n            for (let i = 1; i < prices.length; i++) {\r\n                const current = prices[i];\r\n                const previous = prices[i - 1];\r\n\r\n                // Calculate change if missing\r\n                if (current.change === null || current.changePercent === null) {\r\n                    const close = Number(current.close);\r\n                    const prevClose = Number(previous.close);\r\n\r\n                    const change = close - prevClose;\r\n                    const changePercent = (change / prevClose) * 100;\r\n\r\n                    current.change = change;\r\n                    current.changePercent = changePercent;\r\n\r\n                    await priceRepository.save(current);\r\n                    updatedCount++;\r\n                }\r\n            }\r\n\r\n            // Also update the first record to have 0 change if null\r\n            if (prices[0].change === null) {\r\n                prices[0].change = 0;\r\n                prices[0].changePercent = 0;\r\n                await priceRepository.save(prices[0]);\r\n                updatedCount++;\r\n            }\r\n\r\n            console.log(`Updated ${updatedCount} records for ${asset.ticker}`);\r\n        }\r\n\r\n        console.log('Data fix completed');\r\n    } catch (error) {\r\n        console.error('Error fixing data:', error);\r\n    } finally {\r\n        await AppDataSource.destroy();\r\n    }\r\n}\r\n\r\nfixData();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\scripts\\measure-sync.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/scripts\\measure-sync.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NestFactory } from '@nestjs/core';\r\nimport { AppModule } from '../src/app.module';\r\nimport { AssetsService } from '../src/api/assets/assets.service';\r\nimport { Logger } from '@nestjs/common';\r\n\r\nasync function bootstrap() {\r\n    const app = await NestFactory.createApplicationContext(AppModule);\r\n    const assetsService = app.get(AssetsService);\r\n    const logger = new Logger('MeasureSync');\r\n\r\n    logger.log('Starting syncAllAssets measurement...');\r\n    const start = Date.now();\r\n\r\n    try {\r\n        // Run sync for a subset or all to estimate\r\n        // We'll run for all since that's the real case\r\n        const result = await assetsService.syncAllAssets('1d'); // Use 1d to be faster but still test connection\r\n\r\n        const end = Date.now();\r\n        const duration = (end - start) / 1000;\r\n\r\n        logger.log(`Sync completed in ${duration.toFixed(2)} seconds`);\r\n        logger.log(`Success: ${result.success}, Failed: ${result.failed}`);\r\n    } catch (error) {\r\n        logger.error(`Sync failed: ${error.message}`);\r\n    } finally {\r\n        await app.close();\r\n    }\r\n}\r\n\r\nbootstrap();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\scripts\\populate-top20-data.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/scripts\\populate-top20-data.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import 'reflect-metadata';\r\nimport { NestFactory } from '@nestjs/core';\r\nimport { AppModule } from '../src/app.module';\r\nimport { ScrapersService } from '../src/scrapers/scrapers.service';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { Repository, DataSource } from 'typeorm';\r\nimport { Asset } from '../src/database/entities/asset.entity';\r\nimport { FundamentalData } from '../src/database/entities/fundamental-data.entity';\r\nimport { AssetPrice } from '../src/database/entities/asset-price.entity';\r\n\r\n/**\r\n * Script para popular dados fundamentais e pre├ºos das Top 20 a├º├Áes B3\r\n *\r\n * Execu├º├úo: npm run populate:top20\r\n *\r\n * O que faz:\r\n * 1. Busca as 20 a├º├Áes do banco\r\n * 2. Para cada a├º├úo, executa scrapers (Fundamentus, BRAPI, StatusInvest, Investidor10)\r\n * 3. Salva dados fundamentais\r\n * 4. Salva pre├ºos hist├│ricos (se dispon├¡vel)\r\n */\r\n\r\nconst TOP_20_TICKERS = [\r\n  'PETR4', 'VALE3', 'ITUB4', 'BBDC4', 'ABEV3',\r\n  'MGLU3', 'B3SA3', 'RENT3', 'WEGE3', 'SUZB3',\r\n  'RAIL3', 'GGBR4', 'RADL3', 'JBSS3', 'EMBR3',\r\n  'LREN3', 'SANB11', 'VIVT3', 'EGIE3', 'EQTL3',\r\n];\r\n\r\nclass PopulateDataScript {\r\n  private scrapersService: ScrapersService;\r\n  private assetRepository: Repository<Asset>;\r\n  private fundamentalRepository: Repository<FundamentalData>;\r\n  private priceRepository: Repository<AssetPrice>;\r\n  private dataSource: DataSource;\r\n\r\n  async initialize() {\r\n    console.log('­ƒÜÇ Initializing NestJS application...\\n');\r\n\r\n    const app = await NestFactory.createApplicationContext(AppModule, {\r\n      logger: ['error', 'warn', 'log'],\r\n    });\r\n\r\n    this.scrapersService = app.get(ScrapersService);\r\n    this.dataSource = app.get(DataSource);\r\n    this.assetRepository = this.dataSource.getRepository(Asset);\r\n    this.fundamentalRepository = this.dataSource.getRepository(FundamentalData);\r\n    this.priceRepository = this.dataSource.getRepository(AssetPrice);\r\n\r\n    console.log('Ô£à Application initialized\\n');\r\n\r\n    return app;\r\n  }\r\n\r\n  async populateAssetData(ticker: string): Promise<boolean> {\r\n    try {\r\n      console.log(`\\n­ƒôè Processing ${ticker}...`);\r\n\r\n      // 1. Find asset in database\r\n      const asset = await this.assetRepository.findOne({ where: { ticker } });\r\n\r\n      if (!asset) {\r\n        console.log(`   ÔÜá´©Å  Asset ${ticker} not found in database, skipping`);\r\n        return false;\r\n      }\r\n\r\n      // 2. Scrape fundamental data from multiple sources\r\n      console.log(`   ­ƒöì Scraping fundamental data from 4 sources...`);\r\n      const fundamentalResult = await this.scrapersService.scrapeFundamentalData(ticker);\r\n\r\n      if (!fundamentalResult.isValid || !fundamentalResult.data) {\r\n        console.log(`   ÔØî Failed to scrape valid data for ${ticker}`);\r\n        console.log(`      Sources: ${fundamentalResult.sourcesCount}/${4}`);\r\n        console.log(`      Confidence: ${(fundamentalResult.confidence * 100).toFixed(1)}%`);\r\n        return false;\r\n      }\r\n\r\n      console.log(`   Ô£à Scraped data from ${fundamentalResult.sourcesCount} sources`);\r\n      console.log(`      Confidence: ${(fundamentalResult.confidence * 100).toFixed(1)}%`);\r\n      console.log(`      Sources: ${fundamentalResult.sources.join(', ')}`);\r\n\r\n      // 3. Save fundamental data\r\n      const fundamentalData = this.fundamentalRepository.create({\r\n        assetId: asset.id,\r\n        referenceDate: new Date(),\r\n\r\n        // Valuation indicators\r\n        pl: fundamentalResult.data.pl || fundamentalResult.data.pe || null,\r\n        pvp: fundamentalResult.data.pvp || fundamentalResult.data.pb || null,\r\n        psr: fundamentalResult.data.psr || null,\r\n        dividendYield: fundamentalResult.data.dividendYield || fundamentalResult.data.dy || null,\r\n        evEbitda: fundamentalResult.data.evEbitda || null,\r\n        evEbit: fundamentalResult.data.evEbit || null,\r\n\r\n        // Profitability indicators\r\n        roe: fundamentalResult.data.roe || null,\r\n        roa: fundamentalResult.data.roa || null,\r\n        roic: fundamentalResult.data.roic || null,\r\n        margemLiquida: fundamentalResult.data.margemLiquida || fundamentalResult.data.netMargin || null,\r\n        margemBruta: fundamentalResult.data.margemBruta || fundamentalResult.data.grossMargin || null,\r\n        margemEbit: fundamentalResult.data.margemEbit || fundamentalResult.data.ebitMargin || null,\r\n\r\n        // Liquidity\r\n        liquidezCorrente: fundamentalResult.data.liquidezCorrente || fundamentalResult.data.currentRatio || null,\r\n\r\n        // Absolute values (in millions)\r\n        valorMercado: fundamentalResult.data.valorMercado || fundamentalResult.data.marketCap || null,\r\n        receitaLiquida: fundamentalResult.data.receitaLiquida || fundamentalResult.data.revenue || null,\r\n        lucroLiquido: fundamentalResult.data.lucroLiquido || fundamentalResult.data.netIncome || null,\r\n        ebitda: fundamentalResult.data.ebitda || null,\r\n        ebit: fundamentalResult.data.ebit || null,\r\n        ativoTotal: fundamentalResult.data.ativoTotal || fundamentalResult.data.totalAssets || null,\r\n        patrimonioLiquido: fundamentalResult.data.patrimonioLiquido || fundamentalResult.data.shareholderEquity || null,\r\n        disponibilidades: fundamentalResult.data.disponibilidades || fundamentalResult.data.cash || null,\r\n        dividaBruta: fundamentalResult.data.dividaBruta || fundamentalResult.data.debt || null,\r\n      });\r\n\r\n      await this.fundamentalRepository.save(fundamentalData);\r\n      console.log(`   ­ƒÆ¥ Saved fundamental data to database`);\r\n\r\n      // 4. Save current price if available\r\n      const currentPrice = fundamentalResult.data.cotacao || fundamentalResult.data.price || fundamentalResult.data.regularMarketPrice;\r\n\r\n      if (currentPrice && currentPrice > 0) {\r\n        const priceData = this.priceRepository.create({\r\n          assetId: asset.id,\r\n          date: new Date(),\r\n          open: currentPrice,\r\n          high: currentPrice,\r\n          low: currentPrice,\r\n          close: currentPrice,\r\n          volume: fundamentalResult.data.volume || 0,\r\n          adjustedClose: currentPrice,\r\n        });\r\n\r\n        await this.priceRepository.save(priceData);\r\n        console.log(`   ­ƒÆ░ Saved current price: R$ ${currentPrice.toFixed(2)}`);\r\n      }\r\n\r\n      console.log(`   Ô£à ${ticker} completed successfully!`);\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error(`   ÔØî Error processing ${ticker}:`, error.message);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async run() {\r\n    console.log('ÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉ');\r\n    console.log('  POPULATE TOP 20 B3 ASSETS - FUNDAMENTAL DATA & PRICES');\r\n    console.log('ÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉ\\n');\r\n    console.log(`­ƒôï Assets to process: ${TOP_20_TICKERS.length}`);\r\n    console.log(`­ƒöì Scrapers: Fundamentus, BRAPI, StatusInvest, Investidor10\\n`);\r\n\r\n    let successCount = 0;\r\n    let failCount = 0;\r\n\r\n    const startTime = Date.now();\r\n\r\n    for (const ticker of TOP_20_TICKERS) {\r\n      const success = await this.populateAssetData(ticker);\r\n\r\n      if (success) {\r\n        successCount++;\r\n      } else {\r\n        failCount++;\r\n      }\r\n\r\n      // Small delay between requests to avoid rate limiting\r\n      await new Promise(resolve => setTimeout(resolve, 2000));\r\n    }\r\n\r\n    const endTime = Date.now();\r\n    const duration = ((endTime - startTime) / 1000).toFixed(1);\r\n\r\n    console.log('\\nÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉ');\r\n    console.log('  SUMMARY');\r\n    console.log('ÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉ');\r\n    console.log(`Ô£à Success: ${successCount}/${TOP_20_TICKERS.length}`);\r\n    console.log(`ÔØî Failed:  ${failCount}/${TOP_20_TICKERS.length}`);\r\n    console.log(`ÔÅ▒´©Å  Duration: ${duration}s`);\r\n    console.log(`­ƒôè Average: ${(parseFloat(duration) / TOP_20_TICKERS.length).toFixed(1)}s per asset`);\r\n    console.log('ÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉ\\n');\r\n\r\n    // Show database stats\r\n    const fundamentalCount = await this.fundamentalRepository.count();\r\n    const priceCount = await this.priceRepository.count();\r\n\r\n    console.log('­ƒôê Database Stats:');\r\n    console.log(`   Fundamental Data Records: ${fundamentalCount}`);\r\n    console.log(`   Price Records: ${priceCount}`);\r\n    console.log('');\r\n  }\r\n}\r\n\r\nasync function main() {\r\n  const script = new PopulateDataScript();\r\n\r\n  try {\r\n    const app = await script.initialize();\r\n    await script.run();\r\n    await app.close();\r\n    process.exit(0);\r\n  } catch (error) {\r\n    console.error('­ƒÆÑ Fatal error:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nmain();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\scripts\\populate-top20-simple.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/scripts\\populate-top20-simple.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import 'reflect-metadata';\r\nimport { NestFactory } from '@nestjs/core';\r\nimport { AppModule } from '../src/app.module';\r\nimport { DataSource } from 'typeorm';\r\nimport { Asset } from '../src/database/entities/asset.entity';\r\n\r\n/**\r\n * Script SIMPLIFICADO para testar scrapers e popular dados\r\n * Vers├úo 1: Apenas testa se os scrapers funcionam e mostra os dados\r\n */\r\n\r\nconst TOP_20_TICKERS = [\r\n  'PETR4', 'VALE3', 'ITUB4', 'BBDC4', 'ABEV3',\r\n  'MGLU3', 'B3SA3', 'RENT3', 'WEGE3', 'SUZB3',\r\n  'RAIL3', 'GGBR4', 'RADL3', 'JBSS3', 'EMBR3',\r\n  'LREN3', 'SANB11', 'VIVT3', 'EGIE3', 'EQTL3',\r\n];\r\n\r\nasync function main() {\r\n  console.log('­ƒÜÇ Initializing application...\\n');\r\n\r\n  const app = await NestFactory.createApplicationContext(AppModule, {\r\n    logger: ['error', 'warn'],\r\n  });\r\n\r\n  const dataSource = app.get(DataSource);\r\n  const scrapersService = app.get('ScrapersService');\r\n\r\n  console.log('ÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉ');\r\n  console.log('  TEST SCRAPERS - TOP 20 B3 ASSETS');\r\n  console.log('ÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉ\\n');\r\n\r\n  let successCount = 0;\r\n  let failCount = 0;\r\n\r\n  // Test only first 3 assets to start\r\n  const testTickers = TOP_20_TICKERS.slice(0, 3);\r\n\r\n  for (const ticker of testTickers) {\r\n    try {\r\n      console.log(`\\n­ƒôè Testing ${ticker}...`);\r\n\r\n      const result = await scrapersService.scrapeFundamentalData(ticker);\r\n\r\n      if (result.isValid && result.data) {\r\n        console.log(`   Ô£à SUCCESS`);\r\n        console.log(`      Sources: ${result.sourcesCount} (${result.sources.join(', ')})`);\r\n        console.log(`      Confidence: ${(result.confidence * 100).toFixed(1)}%`);\r\n        console.log(`      Sample data:`);\r\n        console.log(`        - P/L: ${result.data.pl || result.data.pe || 'N/A'}`);\r\n        console.log(`        - P/VP: ${result.data.pvp || result.data.pb || 'N/A'}`);\r\n        console.log(`        - ROE: ${result.data.roe || 'N/A'}%`);\r\n        console.log(`        - Div Yield: ${result.data.dividendYield || result.data.dy || 'N/A'}%`);\r\n        console.log(`        - Cota├º├úo: R$ ${result.data.cotacao || result.data.price || 'N/A'}`);\r\n        successCount++;\r\n      } else {\r\n        console.log(`   ÔØî FAILED`);\r\n        console.log(`      Sources: ${result.sourcesCount}`);\r\n        console.log(`      Confidence: ${(result.confidence * 100).toFixed(1)}%`);\r\n        failCount++;\r\n      }\r\n\r\n      // Delay to avoid rate limiting\r\n      await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n    } catch (error) {\r\n      console.log(`   ÔØî ERROR: ${error.message}`);\r\n      failCount++;\r\n    }\r\n  }\r\n\r\n  console.log('\\nÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉ');\r\n  console.log(`Ô£à Success: ${successCount}/${testTickers.length}`);\r\n  console.log(`ÔØî Failed:  ${failCount}/${testTickers.length}`);\r\n  console.log('ÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉÔòÉ\\n');\r\n\r\n  await app.close();\r\n  process.exit(0);\r\n}\r\n\r\nmain().catch(error => {\r\n  console.error('­ƒÆÑ Fatal error:', error);\r\n  process.exit(1);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\scripts\\run-ibov-seed.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/scripts\\run-ibov-seed.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NestFactory } from '@nestjs/core';\r\nimport { AppModule } from '../src/app.module';\r\nimport { DataSource } from 'typeorm';\r\nimport { seedIbovNewAssets } from '../src/database/seeds/ibov-new-assets.seed';\r\n\r\n/**\r\n * Script to run IBOV new assets seed\r\n *\r\n * Usage: ts-node -r tsconfig-paths/register scripts/run-ibov-seed.ts\r\n */\r\n\r\nasync function runSeed() {\r\n  console.log('­ƒî▒ Iniciando seed de novos ativos do IBOV...\\n');\r\n\r\n  const app = await NestFactory.createApplicationContext(AppModule);\r\n  const dataSource = app.get(DataSource);\r\n\r\n  try {\r\n    await seedIbovNewAssets(dataSource);\r\n    console.log('\\nÔ£à Seed executado com sucesso!');\r\n  } catch (error) {\r\n    console.error('\\nÔØî Erro ao executar seed:', error);\r\n    process.exit(1);\r\n  } finally {\r\n    await app.close();\r\n  }\r\n}\r\n\r\nrunSeed()\r\n  .then(() => process.exit(0))\r\n  .catch((error) => {\r\n    console.error('Erro fatal:', error);\r\n    process.exit(1);\r\n  });\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\scripts\\seed-test-prices.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/scripts\\seed-test-prices.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DataSource } from 'typeorm';\r\nimport { Asset, AssetPrice } from '../src/database/entities';\r\n\r\n// Sample test price data with different variations to test sorting\r\nconst TEST_PRICES = [\r\n  // High performers\r\n  { ticker: 'MGLU3', close: 12.50, previousClose: 10.00, volume: 15000000 },\r\n  { ticker: 'RENT3', close: 45.80, previousClose: 42.00, volume: 8000000 },\r\n  { ticker: 'WEGE3', close: 38.90, previousClose: 36.50, volume: 12000000 },\r\n  { ticker: 'VALE3', close: 65.20, previousClose: 62.00, volume: 25000000 },\r\n\r\n  // Medium performers\r\n  { ticker: 'ITUB4', close: 28.30, previousClose: 27.50, volume: 20000000 },\r\n  { ticker: 'BBDC4', close: 15.75, previousClose: 15.50, volume: 18000000 },\r\n  { ticker: 'PETR4', close: 38.45, previousClose: 38.00, volume: 30000000 },\r\n  { ticker: 'B3SA3', close: 11.80, previousClose: 11.70, volume: 10000000 },\r\n\r\n  // Low performers or stable\r\n  { ticker: 'ABEV3', close: 13.20, previousClose: 13.25, volume: 22000000 },\r\n  { ticker: 'BBAS3', close: 26.50, previousClose: 27.00, volume: 15000000 },\r\n  { ticker: 'JBSS3', close: 19.80, previousClose: 20.50, volume: 9000000 },\r\n  { ticker: 'LREN3', close: 16.40, previousClose: 17.00, volume: 7000000 },\r\n];\r\n\r\nasync function seedTestPrices() {\r\n  // Create TypeORM connection\r\n  const dataSource = new DataSource({\r\n    type: 'postgres',\r\n    host: process.env.DB_HOST || 'localhost',\r\n    port: parseInt(process.env.DB_PORT || '5532'),\r\n    username: process.env.DB_USER || 'invest_user',\r\n    password: process.env.DB_PASSWORD || 'invest_pass_2024',\r\n    database: process.env.DB_NAME || 'invest_platform_db',\r\n    entities: [Asset, AssetPrice],\r\n    synchronize: false,\r\n  });\r\n\r\n  try {\r\n    await dataSource.initialize();\r\n    console.log('Ô£ô Database connection established');\r\n\r\n    const assetRepository = dataSource.getRepository(Asset);\r\n    const priceRepository = dataSource.getRepository(AssetPrice);\r\n\r\n    const today = new Date();\r\n    const yesterday = new Date(today);\r\n    yesterday.setDate(yesterday.getDate() - 1);\r\n\r\n    let inserted = 0;\r\n    let failed = 0;\r\n\r\n    for (const priceData of TEST_PRICES) {\r\n      try {\r\n        // Find asset\r\n        const asset = await assetRepository.findOne({\r\n          where: { ticker: priceData.ticker }\r\n        });\r\n\r\n        if (!asset) {\r\n          console.log(`ÔÜá Asset ${priceData.ticker} not found, skipping...`);\r\n          failed++;\r\n          continue;\r\n        }\r\n\r\n        // Insert today's price\r\n        const todayPrice = priceRepository.create({\r\n          asset,\r\n          assetId: asset.id,\r\n          date: today,\r\n          open: priceData.previousClose * 1.001,\r\n          high: priceData.close * 1.005,\r\n          low: priceData.previousClose * 0.998,\r\n          close: priceData.close,\r\n          volume: priceData.volume,\r\n          adjustedClose: priceData.close,\r\n        });\r\n\r\n        await priceRepository.save(todayPrice);\r\n\r\n        // Insert yesterday's price for comparison\r\n        const yesterdayPrice = priceRepository.create({\r\n          asset,\r\n          assetId: asset.id,\r\n          date: yesterday,\r\n          open: priceData.previousClose * 0.995,\r\n          high: priceData.previousClose * 1.002,\r\n          low: priceData.previousClose * 0.992,\r\n          close: priceData.previousClose,\r\n          volume: priceData.volume * 0.9,\r\n          adjustedClose: priceData.previousClose,\r\n        });\r\n\r\n        await priceRepository.save(yesterdayPrice);\r\n\r\n        const change = priceData.close - priceData.previousClose;\r\n        const changePercent = ((change / priceData.previousClose) * 100).toFixed(2);\r\n        console.log(`Ô£ô ${priceData.ticker}: R$ ${priceData.close.toFixed(2)} (${changePercent}%)`);\r\n        inserted++;\r\n      } catch (error) {\r\n        console.error(`Ô£ù Error inserting ${priceData.ticker}:`, error.message);\r\n        failed++;\r\n      }\r\n    }\r\n\r\n    console.log(`\\n­ƒôè Seed completed:`);\r\n    console.log(`   - Inserted: ${inserted} assets`);\r\n    console.log(`   - Failed: ${failed} assets`);\r\n    console.log(`   - Total prices created: ${inserted * 2} (today + yesterday)`);\r\n\r\n    await dataSource.destroy();\r\n  } catch (error) {\r\n    console.error('ÔØî Error:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nseedTestPrices();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\scripts\\sync-historical-data.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/scripts\\sync-historical-data.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NestFactory } from '@nestjs/core';\r\nimport { AppModule } from '../src/app.module';\r\nimport { AssetsService } from '../src/api/assets/assets.service';\r\n\r\n/**\r\n * Script para popular dados hist├│ricos completos de ativos\r\n * Usa BRAPI com range='3mo' (m├íximo permitido no plano gratuito)\r\n *\r\n * Uso:\r\n * - Sync espec├¡fico: ts-node scripts/sync-historical-data.ts ABEV3\r\n * - Sync m├║ltiplos: ts-node scripts/sync-historical-data.ts ABEV3 CMIG4 CYRE3\r\n * - Sync TODOS: ts-node scripts/sync-historical-data.ts --all\r\n */\r\nasync function main() {\r\n  console.log('­ƒÜÇ Starting historical data sync script...\\n');\r\n\r\n  const app = await NestFactory.createApplicationContext(AppModule, {\r\n    logger: ['log', 'error', 'warn'],\r\n  });\r\n\r\n  const assetsService = app.get(AssetsService);\r\n\r\n  const args = process.argv.slice(2);\r\n\r\n  try {\r\n    if (args.length === 0) {\r\n      console.error('ÔØî Error: No tickers provided');\r\n      console.log('\\nUsage:');\r\n      console.log('  ts-node scripts/sync-historical-data.ts ABEV3 CMIG4 CYRE3');\r\n      console.log('  ts-node scripts/sync-historical-data.ts --all');\r\n      process.exit(1);\r\n    }\r\n\r\n    let tickers: string[] = [];\r\n\r\n    if (args[0] === '--all') {\r\n      console.log('­ƒôè Syncing ALL assets with range=3mo...\\n');\r\n      const result = await assetsService.syncAllAssets('3mo');\r\n      console.log('\\nÔ£à Sync completed:');\r\n      console.log(`   Total: ${result.total}`);\r\n      console.log(`   Success: ${result.success}`);\r\n      console.log(`   Failed: ${result.failed}`);\r\n      console.log(`   Duration: ${(new Date(result.completedAt).getTime() - new Date(result.startedAt).getTime()) / 1000}s`);\r\n\r\n      if (result.failed > 0) {\r\n        console.log('\\nÔØî Failed assets:');\r\n        result.assets.filter(a => a.status === 'failed').forEach(a => {\r\n          console.log(`   - ${a.ticker}: ${a.error}`);\r\n        });\r\n      }\r\n    } else {\r\n      tickers = args;\r\n      console.log(`­ƒôè Syncing ${tickers.length} assets with range=3mo...`);\r\n      console.log(`   Tickers: ${tickers.join(', ')}\\n`);\r\n\r\n      const results = [];\r\n\r\n      for (const ticker of tickers) {\r\n        console.log(`ÔÅ│ Syncing ${ticker}...`);\r\n        const startTime = Date.now();\r\n\r\n        try {\r\n          const result = await assetsService.syncAsset(ticker, '3mo');\r\n          const duration = ((Date.now() - startTime) / 1000).toFixed(2);\r\n\r\n          console.log(`   Ô£à Success (${duration}s)`);\r\n          console.log(`      Price: R$ ${result.currentPrice}`);\r\n          console.log(`      Change: ${result.change >= 0 ? '+' : ''}${result.change} (${result.changePercent >= 0 ? '+' : ''}${result.changePercent}%)`);\r\n\r\n          results.push({ ticker, status: 'success', duration });\r\n        } catch (error) {\r\n          const duration = ((Date.now() - startTime) / 1000).toFixed(2);\r\n          console.log(`   ÔØî Failed (${duration}s): ${error.message}`);\r\n          results.push({ ticker, status: 'failed', error: error.message, duration });\r\n        }\r\n\r\n        console.log('');\r\n      }\r\n\r\n      // Summary\r\n      const successCount = results.filter(r => r.status === 'success').length;\r\n      const failedCount = results.filter(r => r.status === 'failed').length;\r\n\r\n      console.log('­ƒôï Summary:');\r\n      console.log(`   Total: ${results.length}`);\r\n      console.log(`   Success: ${successCount}`);\r\n      console.log(`   Failed: ${failedCount}`);\r\n\r\n      if (failedCount > 0) {\r\n        console.log('\\nÔØî Failed tickers:');\r\n        results.filter(r => r.status === 'failed').forEach(r => {\r\n          console.log(`   - ${r.ticker}: ${r.error}`);\r\n        });\r\n      }\r\n    }\r\n\r\n    console.log('\\nÔ£¿ Script completed!');\r\n  } catch (error) {\r\n    console.error('\\nÔØî Fatal error:', error);\r\n    process.exit(1);\r\n  } finally {\r\n    await app.close();\r\n  }\r\n}\r\n\r\nmain();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\scripts\\sync-ibov-new-assets.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/scripts\\sync-ibov-new-assets.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NestFactory } from '@nestjs/core';\r\nimport { AppModule } from '../src/app.module';\r\nimport { AssetsService } from '../src/api/assets/assets.service';\r\n\r\n/**\r\n * Script para sincronizar dados dos novos ativos do IBOV\r\n *\r\n * Usage: ts-node -r tsconfig-paths/register scripts/sync-ibov-new-assets.ts\r\n */\r\n\r\nconst NEW_IBOV_TICKERS = [\r\n  'ALOS3',  'ASAI3',  'AURE3',  'AXIA3',\r\n  'AXIA6',  'AZZA3',  'BBSE3',  'BBDC3',\r\n  'BRKM5',  'BRAV3',  'BPAC11', 'CXSE3',\r\n  'CEAB3',  'COGN3',\r\n];\r\n\r\nasync function syncNewAssets() {\r\n  console.log('­ƒöä Iniciando sincroniza├º├úo dos novos ativos do IBOV...\\n');\r\n  console.log(`­ƒôè Total de ativos a sincronizar: ${NEW_IBOV_TICKERS.length}\\n`);\r\n  console.log('ÔöÇ'.repeat(80));\r\n\r\n  const app = await NestFactory.createApplicationContext(AppModule);\r\n  const assetsService = app.get(AssetsService);\r\n\r\n  let synced = 0;\r\n  let failed = 0;\r\n\r\n  for (const ticker of NEW_IBOV_TICKERS) {\r\n    try {\r\n      process.stdout.write(`Syncing ${ticker.padEnd(10)}... `);\r\n\r\n      const result = await assetsService.syncAsset(ticker);\r\n\r\n      if (result.status === 'success') {\r\n        synced++;\r\n        const price = result.currentPrice ? `R$ ${result.currentPrice.toFixed(2)}` : 'N/A';\r\n        console.log(`Ô£à OK - ${price}`);\r\n      } else {\r\n        failed++;\r\n        console.log(`ÔØî ERRO - ${result.error || 'Unknown error'}`);\r\n      }\r\n    } catch (error: any) {\r\n      failed++;\r\n      console.log(`ÔØî ERRO - ${error.message}`);\r\n    }\r\n\r\n    // Small delay to avoid rate limiting\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n  }\r\n\r\n  console.log('ÔöÇ'.repeat(80));\r\n  console.log('\\n­ƒôê RESUMO DA SINCRONIZA├ç├âO:\\n');\r\n  console.log(`Ô£à Sincronizados com sucesso: ${synced}`);\r\n  console.log(`ÔØî Falhas: ${failed}`);\r\n  console.log('\\nÔ£à Sincroniza├º├úo conclu├¡da!\\n');\r\n\r\n  await app.close();\r\n}\r\n\r\nsyncNewAssets()\r\n  .then(() => process.exit(0))\r\n  .catch((error) => {\r\n    console.error('Erro fatal:', error);\r\n    process.exit(1);\r\n  });\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\scripts\\test-brapi-availability.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/scripts\\test-brapi-availability.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NestFactory } from '@nestjs/core';\r\nimport { AppModule } from '../src/app.module';\r\nimport { BrapiScraper } from '../src/scrapers/fundamental/brapi.scraper';\r\n\r\n/**\r\n * Script para testar disponibilidade de ativos no BRAPI\r\n *\r\n * Uso: ts-node -r tsconfig-paths/register scripts/test-brapi-availability.ts\r\n */\r\n\r\nconst NEW_IBOV_TICKERS = [\r\n  // Novos ativos encontrados na p├ígina 1 do IBOV\r\n  'ALOS3',  // ALLOS\r\n  'ASAI3',  // ASSAI\r\n  'AURE3',  // AUREN\r\n  'AXIA3',  // AXIA ENERGIA ON\r\n  'AXIA6',  // AXIA ENERGIA PNB\r\n  'AZZA3',  // AZZAS 2154\r\n  'BBSE3',  // BBSEGURIDADE\r\n  'BBDC3',  // BRADESCO ON (temos BBDC4 PN)\r\n  'BRKM5',  // BRASKEM\r\n  'BRAV3',  // BRAVA\r\n  'BPAC11', // BTGP BANCO\r\n  'CXSE3',  // CAIXA SEGURI\r\n  'CEAB3',  // CEA MODAS\r\n  'COGN3',  // COGNA ON\r\n];\r\n\r\ninterface TestResult {\r\n  ticker: string;\r\n  available: boolean;\r\n  statusCode?: number;\r\n  error?: string;\r\n  price?: number;\r\n  name?: string;\r\n}\r\n\r\nasync function testBrapiAvailability() {\r\n  console.log('­ƒöì Iniciando teste de disponibilidade no BRAPI...\\n');\r\n  console.log(`­ƒôè Total de ativos a testar: ${NEW_IBOV_TICKERS.length}\\n`);\r\n  console.log('ÔöÇ'.repeat(80));\r\n\r\n  const app = await NestFactory.createApplicationContext(AppModule);\r\n  const brapiScraper = app.get(BrapiScraper);\r\n\r\n  const results: TestResult[] = [];\r\n  let availableCount = 0;\r\n  let unavailableCount = 0;\r\n\r\n  for (const ticker of NEW_IBOV_TICKERS) {\r\n    try {\r\n      process.stdout.write(`Testing ${ticker.padEnd(10)}... `);\r\n\r\n      const result = await brapiScraper.scrape(ticker, '1d');\r\n\r\n      if (result.success && result.data) {\r\n        availableCount++;\r\n        console.log(`Ô£à OK - R$ ${result.data.price?.toFixed(2) || 'N/A'} - ${result.data.name || ticker}`);\r\n\r\n        results.push({\r\n          ticker,\r\n          available: true,\r\n          price: result.data.price,\r\n          name: result.data.name,\r\n        });\r\n      } else {\r\n        unavailableCount++;\r\n        console.log(`ÔØî ERRO - ${result.error || 'Sem dados'}`);\r\n\r\n        results.push({\r\n          ticker,\r\n          available: false,\r\n          error: result.error,\r\n        });\r\n      }\r\n    } catch (error: any) {\r\n      unavailableCount++;\r\n      const statusCode = error.response?.status;\r\n      console.log(`ÔØî ERRO ${statusCode || ''} - ${error.message}`);\r\n\r\n      results.push({\r\n        ticker,\r\n        available: false,\r\n        statusCode,\r\n        error: error.message,\r\n      });\r\n    }\r\n\r\n    // Pequeno delay para n├úo sobrecarregar a API\r\n    await new Promise(resolve => setTimeout(resolve, 200));\r\n  }\r\n\r\n  console.log('ÔöÇ'.repeat(80));\r\n  console.log('\\n­ƒôê RESUMO DOS TESTES:\\n');\r\n  console.log(`Ô£à Dispon├¡veis: ${availableCount} (${((availableCount/NEW_IBOV_TICKERS.length)*100).toFixed(1)}%)`);\r\n  console.log(`ÔØî Indispon├¡veis: ${unavailableCount} (${((unavailableCount/NEW_IBOV_TICKERS.length)*100).toFixed(1)}%)`);\r\n\r\n  console.log('\\n­ƒôï ATIVOS DISPON├ìVEIS PARA ADICIONAR:\\n');\r\n  const available = results.filter(r => r.available);\r\n  if (available.length > 0) {\r\n    available.forEach(r => {\r\n      console.log(`  ${r.ticker.padEnd(10)} - ${r.name || 'N/A'} - R$ ${r.price?.toFixed(2) || 'N/A'}`);\r\n    });\r\n  } else {\r\n    console.log('  Nenhum ativo dispon├¡vel');\r\n  }\r\n\r\n  console.log('\\nÔØî ATIVOS INDISPON├ìVEIS:\\n');\r\n  const unavailable = results.filter(r => !r.available);\r\n  if (unavailable.length > 0) {\r\n    unavailable.forEach(r => {\r\n      console.log(`  ${r.ticker.padEnd(10)} - ${r.error || 'Erro desconhecido'}`);\r\n    });\r\n  } else {\r\n    console.log('  Todos dispon├¡veis!');\r\n  }\r\n\r\n  console.log('\\nÔöÇ'.repeat(80));\r\n  console.log('Ô£à Teste conclu├¡do!\\n');\r\n\r\n  await app.close();\r\n\r\n  return results;\r\n}\r\n\r\ntestBrapiAvailability()\r\n  .then(() => process.exit(0))\r\n  .catch((error) => {\r\n    console.error('Erro ao executar teste:', error);\r\n    process.exit(1);\r\n  });\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\scripts\\validate-api-precision.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/scripts\\validate-api-precision.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport axios from 'axios';\r\n\r\nasync function validateApiPrecision() {\r\n    const ticker = 'PETR4';\r\n    const url = `http://localhost:3101/api/v1/assets/${ticker}/price-history?range=1mo`;\r\n\r\n    try {\r\n        console.log(`Fetching ${url}...`);\r\n        const response = await axios.get(url);\r\n        const data = response.data;\r\n\r\n        if (!Array.isArray(data)) {\r\n            console.error('Error: Response is not an array.', data);\r\n            return;\r\n        }\r\n\r\n        if (data.length === 0) {\r\n            console.warn('Warning: No price history data found for PETR4.');\r\n            return;\r\n        }\r\n\r\n        console.log(`Received ${data.length} records.`);\r\n\r\n        // Check for decimals in the first few records\r\n        const hasDecimals = data.some(record => {\r\n            const closeStr = record.close.toString();\r\n            const adjStr = record.adjustedClose?.toString() || '';\r\n\r\n            // Check if string representation has > 2 decimals\r\n            const closeDecimals = closeStr.split('.')[1]?.length || 0;\r\n            const adjDecimals = adjStr.split('.')[1]?.length || 0;\r\n\r\n            if (closeDecimals > 2 || adjDecimals > 2) {\r\n                console.log(`Found precise record: Date=${record.date}, Close=${record.close} (${closeDecimals} decimals), Adj=${record.adjustedClose} (${adjDecimals} decimals)`);\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n\r\n        if (hasDecimals) {\r\n            console.log('SUCCESS: API returns values with > 2 decimals.');\r\n        } else {\r\n            console.log('WARNING: All API values have <= 2 decimals. Check serialization or data source.');\r\n            // Print a sample to be sure\r\n            console.log('Sample record:', data[0]);\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error('Error fetching API:', error.message);\r\n        if (error.response) {\r\n            console.error('Status:', error.response.status);\r\n            console.error('Data:', error.response.data);\r\n        }\r\n    }\r\n}\r\n\r\nvalidateApiPrecision();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\scripts\\validate-precision.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/scripts\\validate-precision.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { DataSource } from 'typeorm';\r\nimport { AssetPrice } from '../src/database/entities/asset-price.entity';\r\nimport { Asset } from '../src/database/entities/asset.entity';\r\nimport { FundamentalData } from '../src/database/entities/fundamental-data.entity';\r\nimport * as dotenv from 'dotenv';\r\n\r\ndotenv.config();\r\n\r\nasync function validatePrecision() {\r\n    const dataSource = new DataSource({\r\n        type: 'postgres',\r\n        host: process.env.DB_HOST || 'localhost',\r\n        port: parseInt(process.env.DB_PORT || '5532'),\r\n        username: process.env.DB_USER || 'invest_user',\r\n        password: process.env.DB_PASSWORD || 'invest_password',\r\n        database: process.env.DB_NAME || 'invest_db',\r\n        entities: [AssetPrice, Asset, FundamentalData],\r\n        synchronize: false,\r\n    });\r\n\r\n    try {\r\n        await dataSource.initialize();\r\n        console.log('Database connected.');\r\n\r\n        const repo = dataSource.getRepository(AssetPrice);\r\n        const assetRepo = dataSource.getRepository(Asset);\r\n\r\n        const petr4 = await assetRepo.findOne({ where: { ticker: 'PETR4' } });\r\n\r\n        if (!petr4) {\r\n            console.error('PETR4 not found in Asset table.');\r\n            return;\r\n        }\r\n\r\n        console.log(`Found PETR4: ${petr4.id}`);\r\n\r\n        // Insert test data with 4 decimals\r\n        const testDate = '2099-01-01';\r\n        const testPrice = 35.1234;\r\n\r\n        const newPrice = new AssetPrice();\r\n        newPrice.asset = petr4;\r\n        newPrice.date = new Date(testDate);\r\n        newPrice.open = testPrice;\r\n        newPrice.high = testPrice;\r\n        newPrice.low = testPrice;\r\n        newPrice.close = testPrice;\r\n        newPrice.volume = 1000;\r\n        newPrice.source = 'cotahist' as any;\r\n\r\n        await repo.save(newPrice);\r\n        console.log('Inserted test price: 35.1234');\r\n\r\n        // Read back\r\n        const readPrice = await repo.findOne({\r\n            where: { assetId: petr4.id, date: new Date(testDate) }\r\n        });\r\n\r\n        if (!readPrice) {\r\n            console.error('Failed to read back test price.');\r\n        } else {\r\n            console.log(`Read back close: ${readPrice.close}`);\r\n            // Check if precision is preserved\r\n            if (Number(readPrice.close) === 35.1234) {\r\n                console.log('SUCCESS: Precision preserved (35.1234).');\r\n            } else {\r\n                console.log(`FAILURE: Precision lost. Got ${readPrice.close}`);\r\n            }\r\n        }\r\n\r\n        // Cleanup\r\n        await repo.delete({ assetId: petr4.id, date: new Date(testDate) });\r\n        console.log('Cleanup done.');\r\n\r\n    } catch (error) {\r\n        console.error('Error:', error);\r\n    } finally {\r\n        await dataSource.destroy();\r\n    }\r\n}\r\n\r\nvalidatePrecision();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\agents\\base-financial-agent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\agents\\fundamental-analyst.agent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ticker' is assigned a value but never used.","line":31,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":31,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { BaseFinancialAgent } from './base-financial-agent';\nimport { AgentResponse, AnalysisContext, Signal } from '../interfaces/analysis.types';\n\n/**\n * Agente Analista Fundamentalista\n * Especializado em: Valuation, indicadores financeiros, balan├ºos, P/L, ROE, etc.\n */\n@Injectable()\nexport class FundamentalAnalystAgent extends BaseFinancialAgent {\n  readonly name = 'Analista Fundamentalista';\n  readonly specialty = 'Valuation, balan├ºos patrimoniais, indicadores financeiros';\n  readonly version = '1.0.0';\n\n  constructor(configService: ConfigService) {\n    super(configService);\n  }\n\n  canAnalyze(context: AnalysisContext): boolean {\n    const { stockData } = context;\n\n    // Precisa de pelo menos alguns indicadores fundamentalistas\n    return !!(\n      stockData &&\n      (stockData.pe || stockData.roe || stockData.dividendYield || stockData.debtToEquity)\n    );\n  }\n\n  async analyze(context: AnalysisContext): Promise<AgentResponse> {\n    const { ticker, stockData } = context;\n\n    const systemPrompt = `Voc├¬ ├® um analista fundamentalista experiente, especializado em an├ílise de a├º├Áes brasileiras da B3.\nSeu foco ├® avaliar empresas atrav├®s de:\n- M├║ltiplos de valuation (P/L, P/VP, EV/EBITDA)\n- Indicadores de rentabilidade (ROE, ROA, Margem L├¡quida)\n- Indicadores de endividamento (D├¡vida/Patrim├┤nio, D├¡vida/EBITDA)\n- Dividend Yield e pol├¡tica de dividendos\n- Qualidade dos balan├ºos patrimoniais\n\nVoc├¬ deve ser:\n- Objetivo e baseado em n├║meros\n- Comparar com m├®dias do setor\n- Identificar pontos fortes e fracos\n- Avaliar se a empresa est├í cara ou barata\n- Fornecer recomenda├º├úo clara: COMPRA, MANTER ou VENDA\n\nSeja direto e use linguagem t├®cnica mas acess├¡vel.`;\n\n    const userPrompt = this.buildFundamentalPrompt(stockData);\n\n    const analysis = await this.callGPT4(systemPrompt, userPrompt);\n\n    // Extrair sinais da an├ílise\n    const signals = this.extractFundamentalSignals(stockData);\n\n    return {\n      analysis,\n      confidence: this.calculateFundamentalConfidence(stockData),\n      recommendation: this.extractRecommendation(analysis),\n      signals,\n      metadata: {\n        agent: this.name,\n        specialty: this.specialty,\n        version: this.version,\n        indicators: this.getAvailableIndicators(stockData),\n      },\n      timestamp: new Date(),\n    };\n  }\n\n  private buildFundamentalPrompt(stockData: any): string {\n    const parts: string[] = [];\n\n    parts.push('Analise fundamentalistamente a seguinte a├º├úo:');\n    parts.push('');\n    parts.push(this.formatStockData(stockData));\n    parts.push('');\n    parts.push('Indicadores Fundamentalistas:');\n\n    if (stockData.pe !== undefined) {\n      parts.push(`- P/L (Price/Earnings): ${stockData.pe.toFixed(2)}`);\n    }\n\n    if (stockData.priceToBook !== undefined) {\n      parts.push(`- P/VP (Price/Book Value): ${stockData.priceToBook.toFixed(2)}`);\n    }\n\n    if (stockData.roe !== undefined) {\n      parts.push(`- ROE (Return on Equity): ${stockData.roe.toFixed(2)}%`);\n    }\n\n    if (stockData.dividendYield !== undefined) {\n      parts.push(`- Dividend Yield: ${stockData.dividendYield.toFixed(2)}%`);\n    }\n\n    if (stockData.debtToEquity !== undefined) {\n      parts.push(`- D├¡vida/Patrim├┤nio: ${stockData.debtToEquity.toFixed(2)}`);\n    }\n\n    if (stockData.eps !== undefined) {\n      parts.push(`- LPA (Lucro por A├º├úo): R$ ${stockData.eps.toFixed(2)}`);\n    }\n\n    parts.push('');\n    parts.push('Forne├ºa uma an├ílise fundamentalista completa:');\n    parts.push('1. Avalia├º├úo de valuation (cara, justa ou barata?)');\n    parts.push('2. Qualidade dos indicadores de rentabilidade');\n    parts.push('3. N├¡vel de endividamento');\n    parts.push('4. Pol├¡tica de dividendos');\n    parts.push('5. Recomenda├º├úo final: COMPRA, MANTER ou VENDA');\n    parts.push('6. Pre├ºo-alvo estimado');\n\n    return parts.join('\\n');\n  }\n\n  private extractFundamentalSignals(stockData: any): Signal[] {\n    const signals: Signal[] = [];\n\n    // Sinal baseado em P/L\n    if (stockData.pe !== undefined) {\n      if (stockData.pe < 10) {\n        signals.push({\n          type: 'BUY',\n          strength: 0.7,\n          reason: `P/L baixo (${stockData.pe.toFixed(2)}) - Potencial subavalia├º├úo`,\n          priority: 'HIGH',\n        });\n      } else if (stockData.pe > 30) {\n        signals.push({\n          type: 'SELL',\n          strength: 0.6,\n          reason: `P/L alto (${stockData.pe.toFixed(2)}) - Poss├¡vel sobreavalia├º├úo`,\n          priority: 'MEDIUM',\n        });\n      }\n    }\n\n    // Sinal baseado em ROE\n    if (stockData.roe !== undefined) {\n      if (stockData.roe > 15) {\n        signals.push({\n          type: 'BUY',\n          strength: 0.8,\n          reason: `ROE excelente (${stockData.roe.toFixed(2)}%) - Alta rentabilidade`,\n          priority: 'HIGH',\n        });\n      } else if (stockData.roe < 5) {\n        signals.push({\n          type: 'WARNING',\n          strength: 0.7,\n          reason: `ROE baixo (${stockData.roe.toFixed(2)}%) - Rentabilidade fraca`,\n          priority: 'HIGH',\n        });\n      }\n    }\n\n    // Sinal baseado em Dividend Yield\n    if (stockData.dividendYield !== undefined && stockData.dividendYield > 6) {\n      signals.push({\n        type: 'BUY',\n        strength: 0.6,\n        reason: `Dividend Yield atrativo (${stockData.dividendYield.toFixed(2)}%)`,\n        priority: 'MEDIUM',\n      });\n    }\n\n    // Sinal baseado em endividamento\n    if (stockData.debtToEquity !== undefined) {\n      if (stockData.debtToEquity > 2) {\n        signals.push({\n          type: 'WARNING',\n          strength: 0.8,\n          reason: `Endividamento alto (${stockData.debtToEquity.toFixed(2)}) - Risco financeiro`,\n          priority: 'HIGH',\n        });\n      } else if (stockData.debtToEquity < 0.5) {\n        signals.push({\n          type: 'BUY',\n          strength: 0.5,\n          reason: `Endividamento baixo (${stockData.debtToEquity.toFixed(2)}) - Balan├ºo saud├ível`,\n          priority: 'MEDIUM',\n        });\n      }\n    }\n\n    return signals;\n  }\n\n  private calculateFundamentalConfidence(stockData: any): number {\n    let confidence = this.getBaseConfidence();\n    let indicatorCount = 0;\n\n    // Quanto mais indicadores dispon├¡veis, maior a confian├ºa\n    const indicators = ['pe', 'roe', 'dividendYield', 'debtToEquity', 'priceToBook', 'eps'];\n\n    for (const indicator of indicators) {\n      if (stockData[indicator] !== undefined) {\n        indicatorCount++;\n      }\n    }\n\n    // Ajusta confian├ºa baseado na quantidade de dados\n    if (indicatorCount >= 5) {\n      confidence = Math.min(0.95, confidence + 0.15);\n    } else if (indicatorCount >= 3) {\n      confidence = Math.min(0.85, confidence + 0.05);\n    } else if (indicatorCount < 2) {\n      confidence = Math.max(0.5, confidence - 0.15);\n    }\n\n    return confidence;\n  }\n\n  private getAvailableIndicators(stockData: any): string[] {\n    const indicators: string[] = [];\n\n    if (stockData.pe !== undefined) indicators.push('P/L');\n    if (stockData.priceToBook !== undefined) indicators.push('P/VP');\n    if (stockData.roe !== undefined) indicators.push('ROE');\n    if (stockData.dividendYield !== undefined) indicators.push('Dividend Yield');\n    if (stockData.debtToEquity !== undefined) indicators.push('D├¡vida/Patrim├┤nio');\n    if (stockData.eps !== undefined) indicators.push('LPA');\n\n    return indicators;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\agents\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\agents\\macro-analyst.agent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ticker' is assigned a value but never used.","line":25,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { BaseFinancialAgent } from './base-financial-agent';\nimport { AgentResponse, AnalysisContext, Signal } from '../interfaces/analysis.types';\n\n/**\n * Agente Analista Macroecon├┤mico\n * Especializado em: Selic, infla├º├úo, c├ómbio, PIB, cen├írio pol├¡tico\n */\n@Injectable()\nexport class MacroAnalystAgent extends BaseFinancialAgent {\n  readonly name = 'Analista Macroecon├┤mico';\n  readonly specialty = 'Cen├írio macro, Selic, infla├º├úo, c├ómbio, pol├¡tica';\n  readonly version = '1.0.0';\n\n  constructor(configService: ConfigService) {\n    super(configService);\n  }\n\n  canAnalyze(context: AnalysisContext): boolean {\n    return !!context.macroData;\n  }\n\n  async analyze(context: AnalysisContext): Promise<AgentResponse> {\n    const { ticker, stockData, macroData } = context;\n\n    const systemPrompt = `Voc├¬ ├® um analista macroecon├┤mico especializado no mercado brasileiro.\nAvalie: impacto de Selic, infla├º├úo, c├ómbio, PIB no setor/empresa.\nConsidere: ciclo econ├┤mico, pol├¡ticas monet├íria/fiscal, cen├írio pol├¡tico.`;\n\n    const userPrompt = this.buildMacroPrompt(stockData, macroData);\n    const analysis = await this.callGPT4(systemPrompt, userPrompt);\n\n    return {\n      analysis,\n      confidence: 0.75,\n      signals: this.extractMacroSignals(macroData, stockData),\n      metadata: {\n        agent: this.name,\n        macroScenario: this.assessMacroScenario(macroData),\n      },\n      timestamp: new Date(),\n    };\n  }\n\n  private buildMacroPrompt(stockData: any, macroData: any): string {\n    const parts = [\n      `Analise o impacto macroecon├┤mico em ${stockData.ticker} (${stockData.sector || 'setor'}):`,\n    ];\n\n    if (macroData.selic) parts.push(`Selic: ${macroData.selic.toFixed(2)}%`);\n    if (macroData.ipca) parts.push(`IPCA: ${macroData.ipca.toFixed(2)}%`);\n    if (macroData.usdBrl) parts.push(`USD/BRL: R$ ${macroData.usdBrl.toFixed(2)}`);\n    if (macroData.gdpGrowth)\n      parts.push(`PIB: ${macroData.gdpGrowth > 0 ? '+' : ''}${macroData.gdpGrowth.toFixed(2)}%`);\n\n    parts.push('\\nAvalie: impacto no setor, perspectivas, riscos macroecon├┤micos.');\n    return parts.join('\\n');\n  }\n\n  private extractMacroSignals(macroData: any, stockData: any): Signal[] {\n    const signals: Signal[] = [];\n\n    // Selic alta = negativo para a├º├Áes, positivo para bancos\n    if (macroData.selic && macroData.selic > 12) {\n      if (stockData.sector === 'Financeiro') {\n        signals.push({\n          type: 'BUY',\n          strength: 0.6,\n          reason: `Selic alta (${macroData.selic.toFixed(2)}%) favorece setor financeiro`,\n          priority: 'MEDIUM',\n        });\n      } else {\n        signals.push({\n          type: 'WARNING',\n          strength: 0.5,\n          reason: `Selic alta (${macroData.selic.toFixed(2)}%) pode pressionar valuation`,\n          priority: 'MEDIUM',\n        });\n      }\n    }\n\n    // C├ómbio alto = bom para exportadores\n    if (macroData.usdBrl && macroData.usdBrl > 5.5) {\n      const exportSectors = ['Commodities', 'Minera├º├úo', 'Siderurgia'];\n      if (exportSectors.includes(stockData.sector)) {\n        signals.push({\n          type: 'BUY',\n          strength: 0.6,\n          reason: `C├ómbio favor├ível (R$ ${macroData.usdBrl.toFixed(2)}) para exportadores`,\n          priority: 'MEDIUM',\n        });\n      }\n    }\n\n    return signals;\n  }\n\n  private assessMacroScenario(macroData: any): string {\n    if (macroData.selic > 12 && macroData.ipca > 6) return 'CONTRACIONISTA';\n    if (macroData.selic < 8 && macroData.gdpGrowth > 2) return 'EXPANSIONISTA';\n    return 'NEUTRO';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\agents\\risk-analyst.agent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ticker' is assigned a value but never used.","line":25,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { BaseFinancialAgent } from './base-financial-agent';\nimport { AgentResponse, AnalysisContext, Signal } from '../interfaces/analysis.types';\n\n/**\n * Agente Analista de Risco\n * Especializado em: Volatilidade, beta, correla├º├Áes, risco de portf├│lio\n */\n@Injectable()\nexport class RiskAnalystAgent extends BaseFinancialAgent {\n  readonly name = 'Analista de Risco';\n  readonly specialty = 'Gest├úo de risco, volatilidade, correla├º├Áes';\n  readonly version = '1.0.0';\n\n  constructor(configService: ConfigService) {\n    super(configService);\n  }\n\n  canAnalyze(context: AnalysisContext): boolean {\n    return !!(context.stockData && (context.stockData.beta || context.portfolio));\n  }\n\n  async analyze(context: AnalysisContext): Promise<AgentResponse> {\n    const { ticker, stockData, portfolio } = context;\n\n    const systemPrompt = `Voc├¬ ├® um analista de risco especializado em gest├úo de portf├│lios.\nAvalie: volatilidade, beta, correla├º├Áes, concentra├º├úo, risco sist├¬mico.\nSugira: diversifica├º├úo, hedge, dimensionamento de posi├º├úo.`;\n\n    const userPrompt = this.buildRiskPrompt(stockData, portfolio);\n    const analysis = await this.callGPT4(systemPrompt, userPrompt);\n\n    return {\n      analysis,\n      confidence: 0.8,\n      signals: this.extractRiskSignals(stockData, portfolio),\n      metadata: {\n        agent: this.name,\n        riskLevel: this.assessRiskLevel(stockData),\n      },\n      timestamp: new Date(),\n    };\n  }\n\n  private buildRiskPrompt(stockData: any, portfolio: any): string {\n    const parts = [`Avalie o risco de ${stockData.ticker}:`];\n\n    if (stockData.beta) parts.push(`Beta: ${stockData.beta.toFixed(2)}`);\n    if (portfolio) {\n      parts.push(`\\nPortf├│lio: ${portfolio.positions.length} posi├º├Áes`);\n      parts.push(`Volatilidade: ${portfolio.volatility}%`);\n      if (portfolio.concentration) {\n        parts.push(`\\nConcentra├º├úo por setor:`);\n        Object.entries(portfolio.concentration).forEach(([sector, pct]: any) => {\n          parts.push(`- ${sector}: ${(pct * 100).toFixed(1)}%`);\n        });\n      }\n    }\n\n    return parts.join('\\n');\n  }\n\n  private extractRiskSignals(stockData: any, portfolio: any): Signal[] {\n    const signals: Signal[] = [];\n\n    if (stockData.beta && stockData.beta > 1.5) {\n      signals.push({\n        type: 'WARNING',\n        strength: 0.7,\n        reason: `Beta alto (${stockData.beta.toFixed(2)}) - Alta volatilidade`,\n        priority: 'HIGH',\n      });\n    }\n\n    if (portfolio?.concentration) {\n      const maxConcentration = Math.max(...(Object.values(portfolio.concentration) as number[]));\n      if (maxConcentration > 0.4) {\n        signals.push({\n          type: 'WARNING',\n          strength: 0.8,\n          reason: `Concentra├º├úo excessiva em um setor (${(maxConcentration * 100).toFixed(0)}%)`,\n          priority: 'CRITICAL',\n        });\n      }\n    }\n\n    return signals;\n  }\n\n  private assessRiskLevel(stockData: any): string {\n    if (!stockData.beta) return 'UNKNOWN';\n    if (stockData.beta > 1.5) return 'HIGH';\n    if (stockData.beta > 1.0) return 'MODERATE';\n    return 'LOW';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\agents\\sentiment-analyst.agent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ticker' is assigned a value but never used.","line":25,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { BaseFinancialAgent } from './base-financial-agent';\nimport { AgentResponse, AnalysisContext, Signal } from '../interfaces/analysis.types';\n\n/**\n * Agente Analista de Sentimento\n * Especializado em: Not├¡cias, redes sociais, sentiment analysis, eventos corporativos\n */\n@Injectable()\nexport class SentimentAnalystAgent extends BaseFinancialAgent {\n  readonly name = 'Analista de Sentimento';\n  readonly specialty = 'An├ílise de not├¡cias, sentimento de mercado, eventos';\n  readonly version = '1.0.0';\n\n  constructor(configService: ConfigService) {\n    super(configService);\n  }\n\n  canAnalyze(context: AnalysisContext): boolean {\n    return !!(context.news && context.news.length > 0);\n  }\n\n  async analyze(context: AnalysisContext): Promise<AgentResponse> {\n    const { ticker, stockData, news } = context;\n\n    const systemPrompt = `Voc├¬ ├® um analista de sentimento de mercado especializado em not├¡cias financeiras.\nAnalise o sentimento (positivo, neutro, negativo) de not├¡cias e eventos relacionados ├á empresa.\nIdentifique: temas recorrentes, eventos relevantes, percep├º├úo do mercado.\nForne├ºa recomenda├º├úo baseada no sentimento geral.`;\n\n    const userPrompt = this.buildSentimentPrompt(stockData, news);\n    const analysis = await this.callGPT4(systemPrompt, userPrompt);\n\n    return {\n      analysis,\n      confidence: news.length >= 5 ? 0.8 : 0.6,\n      recommendation: this.extractRecommendation(analysis),\n      signals: this.extractSentimentSignals(news),\n      metadata: {\n        agent: this.name,\n        newsCount: news.length,\n        sentiment: this.aggregateSentiment(news),\n      },\n      timestamp: new Date(),\n    };\n  }\n\n  private buildSentimentPrompt(stockData: any, news: any[]): string {\n    const parts = [`Analise o sentimento das not├¡cias sobre ${stockData.ticker}:`];\n\n    news.slice(0, 10).forEach((item, i) => {\n      parts.push(`\\n${i + 1}. ${item.headline}`);\n      if (item.summary) parts.push(`   ${item.summary}`);\n    });\n\n    parts.push('\\nAvalie: sentimento geral, temas principais, impacto no pre├ºo.');\n    return parts.join('\\n');\n  }\n\n  private extractSentimentSignals(news: any[]): Signal[] {\n    const sentiment = this.aggregateSentiment(news);\n    const signals: Signal[] = [];\n\n    if (sentiment.positive > 0.6) {\n      signals.push({\n        type: 'BUY',\n        strength: 0.6,\n        reason: `Sentimento predominantemente positivo (${(sentiment.positive * 100).toFixed(0)}%)`,\n        priority: 'MEDIUM',\n      });\n    } else if (sentiment.negative > 0.6) {\n      signals.push({\n        type: 'SELL',\n        strength: 0.6,\n        reason: `Sentimento predominantemente negativo (${(sentiment.negative * 100).toFixed(0)}%)`,\n        priority: 'MEDIUM',\n      });\n    }\n\n    return signals;\n  }\n\n  private aggregateSentiment(news: any[]): { positive: number; neutral: number; negative: number } {\n    const counts = { positive: 0, neutral: 0, negative: 0 };\n\n    news.forEach((item) => {\n      if (item.sentiment) {\n        counts[item.sentiment.toLowerCase()]++;\n      } else {\n        counts.neutral++;\n      }\n    });\n\n    const total = news.length;\n    return {\n      positive: counts.positive / total,\n      neutral: counts.neutral / total,\n      negative: counts.negative / total,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\agents\\technical-analyst.agent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ticker' is assigned a value but never used.","line":28,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { BaseFinancialAgent } from './base-financial-agent';\nimport { AgentResponse, AnalysisContext, Signal } from '../interfaces/analysis.types';\n\n/**\n * Agente Analista T├®cnico\n * Especializado em: Gr├íficos, indicadores t├®cnicos, tend├¬ncias, suporte/resist├¬ncia\n */\n@Injectable()\nexport class TechnicalAnalystAgent extends BaseFinancialAgent {\n  readonly name = 'Analista T├®cnico';\n  readonly specialty = 'An├ílise t├®cnica, gr├íficos, tend├¬ncias, padr├Áes';\n  readonly version = '1.0.0';\n\n  constructor(configService: ConfigService) {\n    super(configService);\n  }\n\n  canAnalyze(context: AnalysisContext): boolean {\n    const { stockData } = context;\n\n    // Precisa de pelo menos alguns indicadores t├®cnicos\n    return !!(stockData && (stockData.rsi || stockData.macd || stockData.sma20 || stockData.sma50));\n  }\n\n  async analyze(context: AnalysisContext): Promise<AgentResponse> {\n    const { ticker, stockData } = context;\n\n    const systemPrompt = `Voc├¬ ├® um analista t├®cnico profissional, especializado em an├ílise gr├ífica e indicadores t├®cnicos.\nSeu foco ├® identificar:\n- Tend├¬ncias (alta, baixa, lateral)\n- N├¡veis de suporte e resist├¬ncia\n- Padr├Áes gr├íficos (tri├óngulos, candles, etc)\n- Indicadores t├®cnicos (RSI, MACD, M├®dias M├│veis, Bollinger Bands)\n- Sinais de compra e venda\n- Volume e momentum\n\nVoc├¬ deve ser:\n- Objetivo e baseado em dados t├®cnicos\n- Identificar pontos de entrada e sa├¡da\n- Avaliar for├ºa da tend├¬ncia\n- Considerar m├║ltiplos timeframes\n- Fornecer recomenda├º├úo clara: COMPRA, MANTER ou VENDA\n\nUse terminologia t├®cnica mas explique os conceitos.`;\n\n    const userPrompt = this.buildTechnicalPrompt(stockData);\n\n    const analysis = await this.callGPT4(systemPrompt, userPrompt);\n\n    // Extrair sinais da an├ílise\n    const signals = this.extractTechnicalSignals(stockData);\n\n    return {\n      analysis,\n      confidence: this.calculateTechnicalConfidence(stockData),\n      recommendation: this.extractRecommendation(analysis),\n      signals,\n      metadata: {\n        agent: this.name,\n        specialty: this.specialty,\n        version: this.version,\n        indicators: this.getAvailableIndicators(stockData),\n        trend: this.identifyTrend(stockData),\n      },\n      timestamp: new Date(),\n    };\n  }\n\n  private buildTechnicalPrompt(stockData: any): string {\n    const parts: string[] = [];\n\n    parts.push('Analise tecnicamente a seguinte a├º├úo:');\n    parts.push('');\n    parts.push(this.formatStockData(stockData));\n    parts.push('');\n    parts.push('Indicadores T├®cnicos:');\n\n    if (stockData.rsi !== undefined) {\n      parts.push(`- RSI (14): ${stockData.rsi.toFixed(2)}`);\n      if (stockData.rsi > 70) parts.push('  ÔåÆ Zona de sobrecompra');\n      else if (stockData.rsi < 30) parts.push('  ÔåÆ Zona de sobrevenda');\n    }\n\n    if (stockData.macd) {\n      parts.push(`- MACD: ${stockData.macd.value.toFixed(4)}`);\n      parts.push(`- MACD Signal: ${stockData.macd.signal.toFixed(4)}`);\n      parts.push(`- MACD Histogram: ${stockData.macd.histogram.toFixed(4)}`);\n\n      if (stockData.macd.histogram > 0) {\n        parts.push('  ÔåÆ MACD positivo (tend├¬ncia de alta)');\n      } else {\n        parts.push('  ÔåÆ MACD negativo (tend├¬ncia de baixa)');\n      }\n    }\n\n    if (stockData.sma20) {\n      parts.push(`- SMA 20: R$ ${stockData.sma20.toFixed(2)}`);\n      if (stockData.price > stockData.sma20) {\n        parts.push('  ÔåÆ Pre├ºo acima da m├®dia de 20 dias');\n      } else {\n        parts.push('  ÔåÆ Pre├ºo abaixo da m├®dia de 20 dias');\n      }\n    }\n\n    if (stockData.sma50) {\n      parts.push(`- SMA 50: R$ ${stockData.sma50.toFixed(2)}`);\n    }\n\n    if (stockData.sma200) {\n      parts.push(`- SMA 200: R$ ${stockData.sma200.toFixed(2)}`);\n    }\n\n    if (stockData.bollingerBands) {\n      parts.push('\\nBollinger Bands:');\n      parts.push(`- Banda Superior: R$ ${stockData.bollingerBands.upper.toFixed(2)}`);\n      parts.push(`- Banda M├®dia: R$ ${stockData.bollingerBands.middle.toFixed(2)}`);\n      parts.push(`- Banda Inferior: R$ ${stockData.bollingerBands.lower.toFixed(2)}`);\n    }\n\n    parts.push('');\n    parts.push('Forne├ºa uma an├ílise t├®cnica completa:');\n    parts.push('1. Tend├¬ncia atual (alta, baixa ou lateral)');\n    parts.push('2. For├ºa da tend├¬ncia');\n    parts.push('3. N├¡veis de suporte e resist├¬ncia');\n    parts.push('4. Sinais de compra ou venda');\n    parts.push('5. Pontos de entrada e sa├¡da sugeridos');\n    parts.push('6. Recomenda├º├úo final: COMPRA, MANTER ou VENDA');\n\n    return parts.join('\\n');\n  }\n\n  private extractTechnicalSignals(stockData: any): Signal[] {\n    const signals: Signal[] = [];\n\n    // Sinal baseado em RSI\n    if (stockData.rsi !== undefined) {\n      if (stockData.rsi < 30) {\n        signals.push({\n          type: 'BUY',\n          strength: 0.8,\n          reason: `RSI em sobrevenda (${stockData.rsi.toFixed(2)}) - Poss├¡vel revers├úo de alta`,\n          priority: 'HIGH',\n        });\n      } else if (stockData.rsi > 70) {\n        signals.push({\n          type: 'SELL',\n          strength: 0.7,\n          reason: `RSI em sobrecompra (${stockData.rsi.toFixed(2)}) - Poss├¡vel corre├º├úo`,\n          priority: 'MEDIUM',\n        });\n      } else if (stockData.rsi > 50 && stockData.rsi < 60) {\n        signals.push({\n          type: 'BUY',\n          strength: 0.5,\n          reason: 'RSI em zona neutra positiva - Momentum favor├ível',\n          priority: 'LOW',\n        });\n      }\n    }\n\n    // Sinal baseado em MACD\n    if (stockData.macd) {\n      if (stockData.macd.histogram > 0 && stockData.macd.value > stockData.macd.signal) {\n        signals.push({\n          type: 'BUY',\n          strength: 0.7,\n          reason: 'MACD cruzou acima da linha de sinal - Sinal de compra',\n          priority: 'HIGH',\n        });\n      } else if (stockData.macd.histogram < 0 && stockData.macd.value < stockData.macd.signal) {\n        signals.push({\n          type: 'SELL',\n          strength: 0.7,\n          reason: 'MACD cruzou abaixo da linha de sinal - Sinal de venda',\n          priority: 'HIGH',\n        });\n      }\n    }\n\n    // Sinal baseado em M├®dias M├│veis\n    if (stockData.sma20 && stockData.sma50) {\n      // Golden Cross (SMA20 > SMA50)\n      if (stockData.sma20 > stockData.sma50 * 1.02) {\n        signals.push({\n          type: 'BUY',\n          strength: 0.75,\n          reason: 'Golden Cross - M├®dia de 20 dias acima da de 50 dias',\n          priority: 'HIGH',\n        });\n      }\n      // Death Cross (SMA20 < SMA50)\n      else if (stockData.sma20 < stockData.sma50 * 0.98) {\n        signals.push({\n          type: 'SELL',\n          strength: 0.75,\n          reason: 'Death Cross - M├®dia de 20 dias abaixo da de 50 dias',\n          priority: 'HIGH',\n        });\n      }\n    }\n\n    // Sinal baseado em posi├º├úo do pre├ºo vs m├®dias\n    if (stockData.sma20 && stockData.price) {\n      if (stockData.price > stockData.sma20 * 1.05) {\n        signals.push({\n          type: 'WARNING',\n          strength: 0.6,\n          reason: 'Pre├ºo 5%+ acima da SMA20 - Poss├¡vel sobreextens├úo',\n          priority: 'MEDIUM',\n        });\n      } else if (stockData.price < stockData.sma20 * 0.95) {\n        signals.push({\n          type: 'BUY',\n          strength: 0.6,\n          reason: 'Pre├ºo 5%+ abaixo da SMA20 - Poss├¡vel oportunidade de compra',\n          priority: 'MEDIUM',\n        });\n      }\n    }\n\n    // Sinal baseado em Bollinger Bands\n    if (stockData.bollingerBands && stockData.price) {\n      if (stockData.price <= stockData.bollingerBands.lower) {\n        signals.push({\n          type: 'BUY',\n          strength: 0.7,\n          reason: 'Pre├ºo tocou banda inferior de Bollinger - Poss├¡vel revers├úo',\n          priority: 'HIGH',\n        });\n      } else if (stockData.price >= stockData.bollingerBands.upper) {\n        signals.push({\n          type: 'SELL',\n          strength: 0.6,\n          reason: 'Pre├ºo tocou banda superior de Bollinger - Poss├¡vel corre├º├úo',\n          priority: 'MEDIUM',\n        });\n      }\n    }\n\n    return signals;\n  }\n\n  private calculateTechnicalConfidence(stockData: any): number {\n    let confidence = this.getBaseConfidence();\n    let indicatorCount = 0;\n\n    // Quanto mais indicadores dispon├¡veis, maior a confian├ºa\n    const indicators = ['rsi', 'macd', 'sma20', 'sma50', 'sma200', 'bollingerBands'];\n\n    for (const indicator of indicators) {\n      if (stockData[indicator] !== undefined) {\n        indicatorCount++;\n      }\n    }\n\n    // Ajusta confian├ºa baseado na quantidade de dados\n    if (indicatorCount >= 5) {\n      confidence = Math.min(0.95, confidence + 0.15);\n    } else if (indicatorCount >= 3) {\n      confidence = Math.min(0.85, confidence + 0.05);\n    } else if (indicatorCount < 2) {\n      confidence = Math.max(0.5, confidence - 0.15);\n    }\n\n    return confidence;\n  }\n\n  private identifyTrend(stockData: any): string {\n    // Identificar tend├¬ncia baseado em m├®dias m├│veis\n    if (stockData.sma20 && stockData.sma50 && stockData.sma200) {\n      if (stockData.sma20 > stockData.sma50 && stockData.sma50 > stockData.sma200) {\n        return 'UPTREND_STRONG'; // Tend├¬ncia de alta forte\n      } else if (stockData.sma20 < stockData.sma50 && stockData.sma50 < stockData.sma200) {\n        return 'DOWNTREND_STRONG'; // Tend├¬ncia de baixa forte\n      }\n    }\n\n    if (stockData.sma20 && stockData.sma50) {\n      if (stockData.sma20 > stockData.sma50) {\n        return 'UPTREND'; // Tend├¬ncia de alta\n      } else if (stockData.sma20 < stockData.sma50) {\n        return 'DOWNTREND'; // Tend├¬ncia de baixa\n      }\n    }\n\n    return 'SIDEWAYS'; // Lateral\n  }\n\n  private getAvailableIndicators(stockData: any): string[] {\n    const indicators: string[] = [];\n\n    if (stockData.rsi !== undefined) indicators.push('RSI');\n    if (stockData.macd !== undefined) indicators.push('MACD');\n    if (stockData.sma20 !== undefined) indicators.push('SMA20');\n    if (stockData.sma50 !== undefined) indicators.push('SMA50');\n    if (stockData.sma200 !== undefined) indicators.push('SMA200');\n    if (stockData.bollingerBands !== undefined) indicators.push('Bollinger Bands');\n\n    return indicators;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\ai.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\ai.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":7,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'prompt' is defined but never used.","line":7,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'analysisData' is defined but never used.","line":13,"column":48,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":65}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\n\n@Injectable()\nexport class AiService {\n  private readonly logger = new Logger(AiService.name);\n\n  async analyzeWithAI(data: any, prompt: string) {\n    this.logger.log('Analyzing data with AI');\n    // TODO: Implement AI analysis using web scraping or API\n    return { message: 'AI analysis not implemented yet' };\n  }\n\n  async generateRecommendation(ticker: string, analysisData: any) {\n    this.logger.log(`Generating recommendation for ${ticker}`);\n    // TODO: Implement AI recommendation\n    return { recommendation: 'hold', confidence: 0.5 };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\interfaces\\analysis.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\interfaces\\financial-agent.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\services\\document-sharding.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'chunks' is assigned a value but never used.","line":41,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":41,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'i' is defined but never used.","line":79,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":79,"endColumn":33}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport OpenAI from 'openai';\n\nexport interface DocumentChunk {\n  id: string;\n  content: string;\n  tokens: number;\n  relevance?: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface ShardingOptions {\n  maxTokensPerChunk?: number;\n  overlapTokens?: number;\n  preserveParagraphs?: boolean;\n}\n\n/**\n * Document Sharding Service\n * Divide documentos grandes em chunks para economizar tokens GPT-4\n * Usa embeddings para selecionar apenas partes relevantes\n */\n@Injectable()\nexport class DocumentShardingService {\n  private readonly logger = new Logger(DocumentShardingService.name);\n  private openai: OpenAI;\n\n  constructor(private configService: ConfigService) {\n    this.openai = new OpenAI({\n      apiKey: configService.get('OPENAI_API_KEY'),\n    });\n  }\n\n  /**\n   * Divide documento em chunks menores\n   */\n  shardDocument(document: string, options: ShardingOptions = {}): DocumentChunk[] {\n    const { maxTokensPerChunk = 2000, overlapTokens = 200, preserveParagraphs = true } = options;\n\n    const chunks: DocumentChunk[] = [];\n\n    if (preserveParagraphs) {\n      return this.shardByParagraphs(document, maxTokensPerChunk);\n    } else {\n      return this.shardByTokens(document, maxTokensPerChunk, overlapTokens);\n    }\n  }\n\n  /**\n   * Divide por par├ígrafos (melhor para manter contexto)\n   */\n  private shardByParagraphs(document: string, maxTokens: number): DocumentChunk[] {\n    const chunks: DocumentChunk[] = [];\n    const paragraphs = document.split(/\\n\\n+/);\n\n    let currentChunk = '';\n    let currentTokens = 0;\n    let chunkId = 0;\n\n    for (const paragraph of paragraphs) {\n      const paragraphTokens = this.estimateTokens(paragraph);\n\n      // Se o par├ígrafo sozinho excede o limite, divide ele\n      if (paragraphTokens > maxTokens) {\n        if (currentChunk) {\n          chunks.push({\n            id: `chunk_${chunkId++}`,\n            content: currentChunk.trim(),\n            tokens: currentTokens,\n          });\n          currentChunk = '';\n          currentTokens = 0;\n        }\n\n        // Divide o par├ígrafo grande\n        const subChunks = this.shardByTokens(paragraph, maxTokens, 0);\n        chunks.push(\n          ...subChunks.map((c, i) => ({\n            ...c,\n            id: `chunk_${chunkId++}`,\n          })),\n        );\n\n        continue;\n      }\n\n      // Se adicionar este par├ígrafo exceder o limite, salva chunk atual\n      if (currentTokens + paragraphTokens > maxTokens) {\n        chunks.push({\n          id: `chunk_${chunkId++}`,\n          content: currentChunk.trim(),\n          tokens: currentTokens,\n        });\n\n        currentChunk = paragraph;\n        currentTokens = paragraphTokens;\n      } else {\n        currentChunk += (currentChunk ? '\\n\\n' : '') + paragraph;\n        currentTokens += paragraphTokens;\n      }\n    }\n\n    // Adiciona ├║ltimo chunk\n    if (currentChunk) {\n      chunks.push({\n        id: `chunk_${chunkId}`,\n        content: currentChunk.trim(),\n        tokens: currentTokens,\n      });\n    }\n\n    this.logger.log(\n      `Document sharded into ${chunks.length} chunks (avg ${Math.round(chunks.reduce((sum, c) => sum + c.tokens, 0) / chunks.length)} tokens/chunk)`,\n    );\n\n    return chunks;\n  }\n\n  /**\n   * Divide por tokens com overlap (para contexto cont├¡nuo)\n   */\n  private shardByTokens(text: string, maxTokens: number, overlapTokens: number): DocumentChunk[] {\n    const chunks: DocumentChunk[] = [];\n    const words = text.split(/\\s+/);\n    const tokensPerWord = 1.3; // Estimativa: ~1.3 tokens por palavra\n\n    const wordsPerChunk = Math.floor(maxTokens / tokensPerWord);\n    const overlapWords = Math.floor(overlapTokens / tokensPerWord);\n\n    let chunkId = 0;\n    let start = 0;\n\n    while (start < words.length) {\n      const end = Math.min(start + wordsPerChunk, words.length);\n      const chunkWords = words.slice(start, end);\n      const content = chunkWords.join(' ');\n\n      chunks.push({\n        id: `chunk_${chunkId++}`,\n        content,\n        tokens: this.estimateTokens(content),\n      });\n\n      // Pr├│ximo chunk come├ºa com overlap\n      start = end - overlapWords;\n\n      // Evita loop infinito\n      if (start >= words.length - overlapWords) break;\n    }\n\n    return chunks;\n  }\n\n  /**\n   * Seleciona chunks mais relevantes usando embeddings\n   * ECONOMIA: Em vez de enviar 10 chunks (20k tokens), enviar apenas 3 (6k tokens) = 70% economia!\n   */\n  async selectRelevantChunks(\n    chunks: DocumentChunk[],\n    query: string,\n    maxChunks: number = 3,\n  ): Promise<DocumentChunk[]> {\n    try {\n      // Se j├í tem poucos chunks, retorna todos\n      if (chunks.length <= maxChunks) {\n        return chunks;\n      }\n\n      this.logger.log(`Selecting ${maxChunks} most relevant chunks from ${chunks.length} total`);\n\n      // Gerar embedding da query\n      const queryEmbedding = await this.getEmbedding(query);\n\n      // Calcular relev├óncia de cada chunk\n      const chunksWithRelevance = await Promise.all(\n        chunks.map(async (chunk) => {\n          const chunkEmbedding = await this.getEmbedding(chunk.content);\n          const relevance = this.cosineSimilarity(queryEmbedding, chunkEmbedding);\n\n          return {\n            ...chunk,\n            relevance,\n          };\n        }),\n      );\n\n      // Ordenar por relev├óncia e pegar top N\n      const selected = chunksWithRelevance\n        .sort((a, b) => (b.relevance || 0) - (a.relevance || 0))\n        .slice(0, maxChunks);\n\n      const totalTokensSaved =\n        chunks.reduce((sum, c) => sum + c.tokens, 0) -\n        selected.reduce((sum, c) => sum + c.tokens, 0);\n\n      this.logger.log(\n        `Selected ${selected.length} chunks, saved ~${totalTokensSaved} tokens (${((totalTokensSaved / chunks.reduce((sum, c) => sum + c.tokens, 0)) * 100).toFixed(0)}% reduction)`,\n      );\n\n      return selected;\n    } catch (error) {\n      this.logger.error('Error selecting relevant chunks:', error);\n      // Fallback: retorna primeiros N chunks\n      return chunks.slice(0, maxChunks);\n    }\n  }\n\n  /**\n   * Analisa documento com sharding (economia de tokens!)\n   */\n  async analyzeWithSharding(\n    document: string,\n    question: string,\n    options: {\n      maxChunks?: number;\n      maxTokensPerChunk?: number;\n      model?: string;\n    } = {},\n  ): Promise<string> {\n    const { maxChunks = 3, maxTokensPerChunk = 2000, model = 'gpt-4-turbo-preview' } = options;\n\n    try {\n      // 1. Dividir documento\n      const chunks = this.shardDocument(document, { maxTokensPerChunk });\n\n      this.logger.log(`Document sharded into ${chunks.length} chunks`);\n\n      // 2. Selecionar chunks relevantes (ECONOMIA AQUI!)\n      const relevantChunks = await this.selectRelevantChunks(chunks, question, maxChunks);\n\n      // 3. Combinar chunks relevantes\n      const context = relevantChunks\n        .map((c, i) => `[Parte ${i + 1}]\\n${c.content}`)\n        .join('\\n\\n---\\n\\n');\n\n      // 4. An├ílise com contexto reduzido\n      const response = await this.openai.chat.completions.create({\n        model,\n        temperature: 0.3,\n        messages: [\n          {\n            role: 'system',\n            content:\n              'Voc├¬ ├® um analista financeiro. Responda baseado apenas no contexto fornecido.',\n          },\n          {\n            role: 'user',\n            content: `Contexto:\\n${context}\\n\\nPergunta: ${question}`,\n          },\n        ],\n      });\n\n      const totalTokens = response.usage?.total_tokens || 0;\n      this.logger.log(`Analysis completed using ${totalTokens} tokens`);\n\n      return response.choices[0].message.content || '';\n    } catch (error) {\n      this.logger.error('Error analyzing with sharding:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Estima tokens de um texto (aproxima├º├úo)\n   * Regra: ~4 caracteres = 1 token para portugu├¬s\n   */\n  estimateTokens(text: string): number {\n    return Math.ceil(text.length / 4);\n  }\n\n  /**\n   * Gera embedding usando OpenAI\n   */\n  private async getEmbedding(text: string): Promise<number[]> {\n    try {\n      const response = await this.openai.embeddings.create({\n        model: 'text-embedding-ada-002',\n        input: text.slice(0, 8000), // Limita tamanho para API\n      });\n\n      return response.data[0].embedding;\n    } catch (error) {\n      this.logger.error('Error generating embedding:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Calcula similaridade de cosseno entre dois vetores\n   */\n  private cosineSimilarity(a: number[], b: number[]): number {\n    if (a.length !== b.length) {\n      throw new Error('Vectors must have same length');\n    }\n\n    let dotProduct = 0;\n    let magnitudeA = 0;\n    let magnitudeB = 0;\n\n    for (let i = 0; i < a.length; i++) {\n      dotProduct += a[i] * b[i];\n      magnitudeA += a[i] * a[i];\n      magnitudeB += b[i] * b[i];\n    }\n\n    magnitudeA = Math.sqrt(magnitudeA);\n    magnitudeB = Math.sqrt(magnitudeB);\n\n    if (magnitudeA === 0 || magnitudeB === 0) {\n      return 0;\n    }\n\n    return dotProduct / (magnitudeA * magnitudeB);\n  }\n\n  /**\n   * Calcula economia potencial em tokens\n   */\n  calculateTokenSavings(\n    originalDocument: string,\n    selectedChunks: DocumentChunk[],\n  ): {\n    originalTokens: number;\n    reducedTokens: number;\n    savedTokens: number;\n    savingsPercent: number;\n  } {\n    const originalTokens = this.estimateTokens(originalDocument);\n    const reducedTokens = selectedChunks.reduce((sum, c) => sum + c.tokens, 0);\n    const savedTokens = originalTokens - reducedTokens;\n    const savingsPercent = (savedTokens / originalTokens) * 100;\n\n    return {\n      originalTokens,\n      reducedTokens,\n      savedTokens,\n      savingsPercent,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\ai\\services\\multi-agent-analysis.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'secondScore' is assigned a value but never used.","line":183,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":183,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport {\n  FundamentalAnalystAgent,\n  TechnicalAnalystAgent,\n  SentimentAnalystAgent,\n  RiskAnalystAgent,\n  MacroAnalystAgent,\n} from '../agents';\nimport { AnalysisContext, AgentResponse } from '../interfaces/analysis.types';\nimport { MultiAgentAnalysis } from '../interfaces/financial-agent.interface';\n\n/**\n * Servi├ºo que orquestra m├║ltiplos agentes especializados\n * Executa an├ílises em paralelo e consolida resultados\n */\n@Injectable()\nexport class MultiAgentAnalysisService {\n  private readonly logger = new Logger(MultiAgentAnalysisService.name);\n\n  private agents: {\n    fundamental: FundamentalAnalystAgent;\n    technical: TechnicalAnalystAgent;\n    sentiment: SentimentAnalystAgent;\n    risk: RiskAnalystAgent;\n    macro: MacroAnalystAgent;\n  };\n\n  constructor(private configService: ConfigService) {\n    // Inicializar todos os agentes\n    this.agents = {\n      fundamental: new FundamentalAnalystAgent(configService),\n      technical: new TechnicalAnalystAgent(configService),\n      sentiment: new SentimentAnalystAgent(configService),\n      risk: new RiskAnalystAgent(configService),\n      macro: new MacroAnalystAgent(configService),\n    };\n  }\n\n  /**\n   * Executa an├ílise completa com todos os agentes aplic├íveis\n   */\n  async analyzeComplete(context: AnalysisContext): Promise<MultiAgentAnalysis> {\n    const ticker = context.ticker;\n    this.logger.log(`Starting multi-agent analysis for ${ticker}`);\n\n    const startTime = Date.now();\n\n    // Executar agentes em paralelo (apenas os que podem analisar)\n    const agentPromises: Promise<{ name: string; result: AgentResponse | null }>[] = [];\n\n    // An├ílise Fundamentalista\n    if (this.agents.fundamental.canAnalyze(context)) {\n      agentPromises.push(\n        this.agents.fundamental\n          .analyze(context)\n          .then((result) => ({ name: 'fundamental', result }))\n          .catch((err) => {\n            this.logger.error('Fundamental analysis error:', err);\n            return { name: 'fundamental', result: null };\n          }),\n      );\n    }\n\n    // An├ílise T├®cnica\n    if (this.agents.technical.canAnalyze(context)) {\n      agentPromises.push(\n        this.agents.technical\n          .analyze(context)\n          .then((result) => ({ name: 'technical', result }))\n          .catch((err) => {\n            this.logger.error('Technical analysis error:', err);\n            return { name: 'technical', result: null };\n          }),\n      );\n    }\n\n    // An├ílise de Sentimento\n    if (this.agents.sentiment.canAnalyze(context)) {\n      agentPromises.push(\n        this.agents.sentiment\n          .analyze(context)\n          .then((result) => ({ name: 'sentiment', result }))\n          .catch((err) => {\n            this.logger.error('Sentiment analysis error:', err);\n            return { name: 'sentiment', result: null };\n          }),\n      );\n    }\n\n    // An├ílise de Risco\n    if (this.agents.risk.canAnalyze(context)) {\n      agentPromises.push(\n        this.agents.risk\n          .analyze(context)\n          .then((result) => ({ name: 'risk', result }))\n          .catch((err) => {\n            this.logger.error('Risk analysis error:', err);\n            return { name: 'risk', result: null };\n          }),\n      );\n    }\n\n    // An├ílise Macro\n    if (this.agents.macro.canAnalyze(context)) {\n      agentPromises.push(\n        this.agents.macro\n          .analyze(context)\n          .then((result) => ({ name: 'macro', result }))\n          .catch((err) => {\n            this.logger.error('Macro analysis error:', err);\n            return { name: 'macro', result: null };\n          }),\n      );\n    }\n\n    // Executar todos em paralelo\n    const results = await Promise.all(agentPromises);\n\n    // Organizar resultados\n    const agentResults: { [key: string]: AgentResponse } = {};\n    results.forEach(({ name, result }) => {\n      if (result) {\n        agentResults[name] = result;\n      }\n    });\n\n    // Calcular consenso\n    const consensus = this.calculateConsensus(agentResults);\n\n    // Gerar summary consolidado\n    const summary = await this.generateConsolidatedSummary(ticker, agentResults, consensus);\n\n    const duration = Date.now() - startTime;\n    this.logger.log(`Multi-agent analysis completed in ${duration}ms`);\n\n    return {\n      ticker,\n      timestamp: new Date(),\n      agents: agentResults,\n      consensus,\n      summary,\n    };\n  }\n\n  /**\n   * Calcula consenso entre os agentes\n   */\n  private calculateConsensus(agents: { [key: string]: AgentResponse }):\n    | {\n        recommendation: 'BUY' | 'HOLD' | 'SELL';\n        confidence: number;\n        agreement: number;\n      }\n    | undefined {\n    const recommendations: { [key: string]: number } = {\n      BUY: 0,\n      HOLD: 0,\n      SELL: 0,\n    };\n\n    let totalConfidence = 0;\n    let count = 0;\n\n    // Votos ponderados por confian├ºa\n    Object.values(agents).forEach((result) => {\n      if (result.recommendation) {\n        recommendations[result.recommendation] += result.confidence;\n        totalConfidence += result.confidence;\n        count++;\n      }\n    });\n\n    if (count === 0) {\n      return undefined;\n    }\n\n    // Recomenda├º├úo com maior score\n    const sortedRecs = Object.entries(recommendations).sort(([, a], [, b]) => b - a);\n\n    const topRecommendation = sortedRecs[0][0] as 'BUY' | 'HOLD' | 'SELL';\n    const topScore = sortedRecs[0][1];\n    const secondScore = sortedRecs[1]?.[1] || 0;\n\n    // N├¡vel de acordo: qu├úo un├ónimes s├úo os agentes\n    const agreement = topScore / totalConfidence;\n\n    // Confian├ºa final considerando o acordo\n    const confidenceMultiplier = agreement > 0.7 ? 1.0 : agreement > 0.5 ? 0.8 : 0.6;\n    const finalConfidence = (topScore / count) * confidenceMultiplier;\n\n    return {\n      recommendation: topRecommendation,\n      confidence: Math.min(finalConfidence, 1.0),\n      agreement,\n    };\n  }\n\n  /**\n   * Gera resumo consolidado das an├ílises\n   */\n  private async generateConsolidatedSummary(\n    ticker: string,\n    agents: { [key: string]: AgentResponse },\n    consensus: any,\n  ): Promise<string> {\n    const parts: string[] = [];\n\n    parts.push(`=== AN├üLISE MULTI-AGENTE: ${ticker} ===\\n`);\n\n    // Consenso\n    if (consensus) {\n      parts.push(`­ƒÄ» RECOMENDA├ç├âO CONSOLIDADA: ${consensus.recommendation}`);\n      parts.push(`   Confian├ºa: ${(consensus.confidence * 100).toFixed(0)}%`);\n      parts.push(`   Acordo entre agentes: ${(consensus.agreement * 100).toFixed(0)}%\\n`);\n    }\n\n    // Resumo de cada agente\n    Object.entries(agents).forEach(([name, result]) => {\n      const emoji =\n        {\n          fundamental: '­ƒôè',\n          technical: '­ƒôê',\n          sentiment: '­ƒÆ¡',\n          risk: 'ÔÜá´©Å',\n          macro: '­ƒîì',\n        }[name] || '­ƒñû';\n\n      parts.push(\n        `${emoji} ${name.toUpperCase()}: ${result.recommendation || 'N/A'} (${(result.confidence * 100).toFixed(0)}%)`,\n      );\n\n      // Principais sinais\n      if (result.signals && result.signals.length > 0) {\n        const topSignals = result.signals.slice(0, 2);\n        topSignals.forEach((signal) => {\n          parts.push(`   ÔÇó ${signal.reason}`);\n        });\n      }\n\n      parts.push('');\n    });\n\n    // Alertas importantes\n    const criticalSignals = Object.values(agents)\n      .flatMap((a) => a.signals || [])\n      .filter((s) => s.priority === 'CRITICAL');\n\n    if (criticalSignals.length > 0) {\n      parts.push('­ƒÜ¿ ALERTAS CR├ìTICOS:');\n      criticalSignals.forEach((signal) => {\n        parts.push(`   ÔÇó ${signal.reason}`);\n      });\n    }\n\n    return parts.join('\\n');\n  }\n\n  /**\n   * An├ílise r├ípida (apenas agentes essenciais)\n   */\n  async analyzeQuick(context: AnalysisContext): Promise<MultiAgentAnalysis> {\n    const ticker = context.ticker;\n\n    // Apenas fundamental e t├®cnico\n    const results = await Promise.all([\n      this.agents.fundamental.canAnalyze(context) ? this.agents.fundamental.analyze(context) : null,\n      this.agents.technical.canAnalyze(context) ? this.agents.technical.analyze(context) : null,\n    ]);\n\n    const agentResults: { [key: string]: AgentResponse } = {};\n    if (results[0]) agentResults['fundamental'] = results[0];\n    if (results[1]) agentResults['technical'] = results[1];\n\n    const consensus = this.calculateConsensus(agentResults);\n    const summary = await this.generateConsolidatedSummary(ticker, agentResults, consensus);\n\n    return {\n      ticker,\n      timestamp: new Date(),\n      agents: agentResults,\n      consensus,\n      summary,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\analysis\\sentiment\\sentiment-analysis.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'axios' is defined but never used.","line":3,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":13}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport axios from 'axios';\n\nexport interface SentimentResult {\n  score: number; // -1 (muito negativo) a +1 (muito positivo)\n  label: 'very_negative' | 'negative' | 'neutral' | 'positive' | 'very_positive';\n  confidence: number; // 0 a 1\n  keywords: string[];\n}\n\nexport interface NewsSentiment {\n  ticker: string;\n  overallSentiment: SentimentResult;\n  articlesAnalyzed: number;\n  positiveCount: number;\n  negativeCount: number;\n  neutralCount: number;\n  sentimentTrend: 'improving' | 'declining' | 'stable';\n  topPositiveKeywords: string[];\n  topNegativeKeywords: string[];\n}\n\n@Injectable()\nexport class SentimentAnalysisService {\n  private readonly logger = new Logger(SentimentAnalysisService.name);\n  private readonly openaiApiKey: string;\n\n  constructor(private readonly configService: ConfigService) {\n    this.openaiApiKey = this.configService.get<string>('OPENAI_API_KEY');\n  }\n\n  async analyzeText(text: string): Promise<SentimentResult> {\n    try {\n      // An├ílise b├ísica usando palavras-chave (fallback)\n      const positiveWords = [\n        'lucro',\n        'crescimento',\n        'alta',\n        'ganho',\n        'positivo',\n        'otimista',\n        'valoriza├º├úo',\n        'recupera├º├úo',\n        'expans├úo',\n        'aumento',\n        'melhora',\n        'recorde',\n        'forte',\n        'bom',\n        'excelente',\n        'superou',\n        'expectativas',\n      ];\n\n      const negativeWords = [\n        'preju├¡zo',\n        'queda',\n        'perda',\n        'negativo',\n        'pessimista',\n        'desvaloriza├º├úo',\n        'crise',\n        'redu├º├úo',\n        'diminui├º├úo',\n        'fraco',\n        'ruim',\n        'frustrou',\n        'decep├º├úo',\n        'baixa',\n        'risco',\n        'problema',\n        'dificuldade',\n      ];\n\n      const textLower = text.toLowerCase();\n\n      let positiveCount = 0;\n      let negativeCount = 0;\n      const foundKeywords: string[] = [];\n\n      positiveWords.forEach((word) => {\n        const regex = new RegExp(`\\\\b${word}\\\\b`, 'gi');\n        const matches = textLower.match(regex);\n        if (matches) {\n          positiveCount += matches.length;\n          if (!foundKeywords.includes(word)) foundKeywords.push(word);\n        }\n      });\n\n      negativeWords.forEach((word) => {\n        const regex = new RegExp(`\\\\b${word}\\\\b`, 'gi');\n        const matches = textLower.match(regex);\n        if (matches) {\n          negativeCount += matches.length;\n          if (!foundKeywords.includes(word)) foundKeywords.push(word);\n        }\n      });\n\n      const total = positiveCount + negativeCount;\n      let score = 0;\n      let label: SentimentResult['label'] = 'neutral';\n\n      if (total > 0) {\n        score = (positiveCount - negativeCount) / total;\n\n        if (score >= 0.5) label = 'very_positive';\n        else if (score >= 0.2) label = 'positive';\n        else if (score <= -0.5) label = 'very_negative';\n        else if (score <= -0.2) label = 'negative';\n        else label = 'neutral';\n      }\n\n      const confidence = total > 0 ? Math.min(total / 10, 1) : 0.3;\n\n      return {\n        score,\n        label,\n        confidence,\n        keywords: foundKeywords,\n      };\n    } catch (error) {\n      this.logger.error(`Erro na an├ílise de sentimento: ${error.message}`);\n      return {\n        score: 0,\n        label: 'neutral',\n        confidence: 0,\n        keywords: [],\n      };\n    }\n  }\n\n  async analyzeNews(\n    ticker: string,\n    articles: Array<{ title: string; snippet?: string; summary?: string }>,\n  ): Promise<NewsSentiment> {\n    this.logger.log(`Analisando sentimento de ${articles.length} not├¡cias para ${ticker}`);\n\n    const sentiments: SentimentResult[] = [];\n\n    for (const article of articles) {\n      const text = `${article.title} ${article.snippet || article.summary || ''}`;\n      const sentiment = await this.analyzeText(text);\n      sentiments.push(sentiment);\n    }\n\n    // Calcular m├®tricas gerais\n    const positiveCount = sentiments.filter(\n      (s) => s.label === 'positive' || s.label === 'very_positive',\n    ).length;\n    const negativeCount = sentiments.filter(\n      (s) => s.label === 'negative' || s.label === 'very_negative',\n    ).length;\n    const neutralCount = sentiments.filter((s) => s.label === 'neutral').length;\n\n    const avgScore = sentiments.reduce((sum, s) => sum + s.score, 0) / sentiments.length;\n    const avgConfidence = sentiments.reduce((sum, s) => sum + s.confidence, 0) / sentiments.length;\n\n    // Determinar tend├¬ncia (├║ltimas 5 vs primeiras 5)\n    let sentimentTrend: NewsSentiment['sentimentTrend'] = 'stable';\n    if (sentiments.length >= 10) {\n      const recentAvg = sentiments.slice(0, 5).reduce((sum, s) => sum + s.score, 0) / 5;\n      const olderAvg = sentiments.slice(5, 10).reduce((sum, s) => sum + s.score, 0) / 5;\n\n      if (recentAvg > olderAvg + 0.2) sentimentTrend = 'improving';\n      else if (recentAvg < olderAvg - 0.2) sentimentTrend = 'declining';\n    }\n\n    // Agregar keywords\n    const allKeywords = sentiments.flatMap((s) => s.keywords);\n    const keywordCounts = allKeywords.reduce(\n      (acc, keyword) => {\n        acc[keyword] = (acc[keyword] || 0) + 1;\n        return acc;\n      },\n      {} as Record<string, number>,\n    );\n\n    const sortedKeywords = Object.entries(keywordCounts)\n      .sort(([, a], [, b]) => b - a)\n      .map(([keyword]) => keyword);\n\n    // Separar keywords positivas e negativas\n    const positiveKeywords = ['lucro', 'crescimento', 'alta', 'ganho', 'positivo', 'valoriza├º├úo'];\n    const negativeKeywords = ['preju├¡zo', 'queda', 'perda', 'negativo', 'desvaloriza├º├úo', 'crise'];\n\n    const topPositiveKeywords = sortedKeywords\n      .filter((k) => positiveKeywords.includes(k))\n      .slice(0, 5);\n    const topNegativeKeywords = sortedKeywords\n      .filter((k) => negativeKeywords.includes(k))\n      .slice(0, 5);\n\n    // Determinar label geral\n    let overallLabel: SentimentResult['label'] = 'neutral';\n    if (avgScore >= 0.5) overallLabel = 'very_positive';\n    else if (avgScore >= 0.2) overallLabel = 'positive';\n    else if (avgScore <= -0.5) overallLabel = 'very_negative';\n    else if (avgScore <= -0.2) overallLabel = 'negative';\n\n    return {\n      ticker,\n      overallSentiment: {\n        score: avgScore,\n        label: overallLabel,\n        confidence: avgConfidence,\n        keywords: sortedKeywords.slice(0, 10),\n      },\n      articlesAnalyzed: articles.length,\n      positiveCount,\n      negativeCount,\n      neutralCount,\n      sentimentTrend,\n      topPositiveKeywords,\n      topNegativeKeywords,\n    };\n  }\n\n  getSentimentDescription(sentiment: SentimentResult['label']): string {\n    const descriptions = {\n      very_positive: 'Muito Positivo - Not├¡cias amplamente favor├íveis',\n      positive: 'Positivo - Maioria das not├¡cias favor├íveis',\n      neutral: 'Neutro - Not├¡cias equilibradas ou neutras',\n      negative: 'Negativo - Maioria das not├¡cias desfavor├íveis',\n      very_negative: 'Muito Negativo - Not├¡cias amplamente desfavor├íveis',\n    };\n\n    return descriptions[sentiment];\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\analysis\\technical\\python-client.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\analysis\\technical\\technical-analysis.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\analysis\\technical\\technical-analysis.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'patterns' is defined but never used.","line":337,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":337,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { TechnicalIndicatorsService, PriceData } from './technical-indicators.service';\nimport { TechnicalIndicators } from '../../api/market-data/interfaces';\n\nexport interface TechnicalAnalysisResult {\n  ticker: string;\n  analysisDate: Date;\n  currentPrice: number;\n  indicators: TechnicalIndicators;\n  signals: {\n    overall: 'BUY' | 'SELL' | 'NEUTRAL';\n    strength: number; // 0-100\n    trendSignal: 'BUY' | 'SELL' | 'NEUTRAL';\n    momentumSignal: 'BUY' | 'SELL' | 'NEUTRAL';\n    volatilitySignal: 'LOW' | 'MEDIUM' | 'HIGH';\n  };\n  patterns: string[];\n  supportLevels: number[];\n  resistanceLevels: number[];\n  recommendations: string[];\n}\n\n@Injectable()\nexport class TechnicalAnalysisService {\n  private readonly logger = new Logger(TechnicalAnalysisService.name);\n\n  constructor(private technicalIndicators: TechnicalIndicatorsService) {}\n\n  /**\n   * Perform complete technical analysis\n   */\n  async analyze(ticker: string, priceHistory: PriceData[]): Promise<TechnicalAnalysisResult> {\n    this.logger.log(`Performing technical analysis for ${ticker}`);\n\n    const indicators = await this.technicalIndicators.calculateIndicators(ticker, priceHistory);\n    const currentPrice = priceHistory[priceHistory.length - 1].close;\n\n    // Analyze signals\n    const trendSignal = this.analyzeTrendSignal(indicators, currentPrice);\n    const momentumSignal = this.analyzeMomentumSignal(indicators);\n    const volatilitySignal = this.analyzeVolatility(indicators);\n\n    // Calculate overall signal\n    const signals = {\n      overall: this.calculateOverallSignal(trendSignal, momentumSignal),\n      strength: this.calculateSignalStrength(indicators, trendSignal, momentumSignal),\n      trendSignal,\n      momentumSignal,\n      volatilitySignal,\n    };\n\n    // Detect patterns\n    const patterns = this.detectPatterns(priceHistory, indicators);\n\n    // Calculate support and resistance\n    const { supportLevels, resistanceLevels } = this.calculateSupportResistance(priceHistory);\n\n    // Generate recommendations\n    const recommendations = this.generateRecommendations(indicators, signals, patterns);\n\n    return {\n      ticker,\n      analysisDate: new Date(),\n      currentPrice,\n      indicators,\n      signals,\n      patterns,\n      supportLevels,\n      resistanceLevels,\n      recommendations,\n    };\n  }\n\n  /**\n   * Analyze trend signal\n   */\n  private analyzeTrendSignal(\n    indicators: TechnicalIndicators,\n    currentPrice: number,\n  ): 'BUY' | 'SELL' | 'NEUTRAL' {\n    let buySignals = 0;\n    let sellSignals = 0;\n\n    // Helper to get last value\n    const getLast = (val: number | number[] | undefined): number => {\n      if (Array.isArray(val)) return val[val.length - 1] || 0;\n      return val || 0;\n    };\n\n    const sma20 = getLast(indicators.sma_20);\n    const sma50 = getLast(indicators.sma_50);\n    const sma200 = getLast(indicators.sma_200);\n    const ema9 = getLast(indicators.ema_9);\n    const ema21 = getLast(indicators.ema_21);\n\n    // Check moving averages\n    if (currentPrice > sma20 && currentPrice > sma50 && currentPrice > sma200) {\n      buySignals += 2;\n    } else if (currentPrice < sma20 && currentPrice < sma50 && currentPrice < sma200) {\n      sellSignals += 2;\n    }\n\n    // Check EMA\n    if (currentPrice > ema9 && currentPrice > ema21) {\n      buySignals++;\n    } else if (currentPrice < ema9 && currentPrice < ema21) {\n      sellSignals++;\n    }\n\n    // Check trend\n    if (indicators.trend === 'UPTREND') {\n      buySignals++;\n    } else if (indicators.trend === 'DOWNTREND') {\n      sellSignals++;\n    }\n\n    if (buySignals > sellSignals + 1) return 'BUY';\n    if (sellSignals > buySignals + 1) return 'SELL';\n    return 'NEUTRAL';\n  }\n\n  /**\n   * Analyze momentum signal\n   */\n  private analyzeMomentumSignal(indicators: TechnicalIndicators): 'BUY' | 'SELL' | 'NEUTRAL' {\n    let buySignals = 0;\n    let sellSignals = 0;\n\n    // Helper to get last value\n    const getLast = (val: number | number[] | undefined): number => {\n      if (Array.isArray(val)) return val[val.length - 1] || 0;\n      return val || 0;\n    };\n\n    const rsi = getLast(indicators.rsi);\n\n    // MACD\n    const macdHist = getLast(indicators.macd?.histogram);\n    const macdLine = getLast(indicators.macd?.macd);\n    const macdSignal = getLast(indicators.macd?.signal);\n\n    // Stochastic\n    const stochK = getLast(indicators.stochastic?.k);\n    const stochD = getLast(indicators.stochastic?.d);\n\n    // RSI\n    if (rsi < 30) {\n      buySignals += 2; // Oversold\n    } else if (rsi > 70) {\n      sellSignals += 2; // Overbought\n    } else if (rsi > 50) {\n      buySignals++;\n    } else if (rsi < 50) {\n      sellSignals++;\n    }\n\n    // MACD\n    if (macdHist > 0 && macdLine > macdSignal) {\n      buySignals++;\n    } else if (macdHist < 0 && macdLine < macdSignal) {\n      sellSignals++;\n    }\n\n    // Stochastic\n    if (stochK < 20 && stochD < 20) {\n      buySignals++; // Oversold\n    } else if (stochK > 80 && stochD > 80) {\n      sellSignals++; // Overbought\n    }\n\n    if (buySignals > sellSignals) return 'BUY';\n    if (sellSignals > buySignals) return 'SELL';\n    return 'NEUTRAL';\n  }\n\n  /**\n   * Analyze volatility\n   */\n  private analyzeVolatility(indicators: TechnicalIndicators): 'LOW' | 'MEDIUM' | 'HIGH' {\n    const bandwidth = indicators.bollinger_bands?.bandwidth || 0;\n\n    if (bandwidth < 10) return 'LOW';\n    if (bandwidth > 25) return 'HIGH';\n    return 'MEDIUM';\n  }\n\n  /**\n   * Calculate overall signal\n   */\n  private calculateOverallSignal(\n    trendSignal: 'BUY' | 'SELL' | 'NEUTRAL',\n    momentumSignal: 'BUY' | 'SELL' | 'NEUTRAL',\n  ): 'BUY' | 'SELL' | 'NEUTRAL' {\n    if (trendSignal === 'BUY' && momentumSignal === 'BUY') return 'BUY';\n    if (trendSignal === 'SELL' && momentumSignal === 'SELL') return 'SELL';\n    if (trendSignal === 'BUY' && momentumSignal !== 'SELL') return 'BUY';\n    if (trendSignal === 'SELL' && momentumSignal !== 'BUY') return 'SELL';\n    return 'NEUTRAL';\n  }\n\n  /**\n   * Calculate signal strength (0-100)\n   */\n  private calculateSignalStrength(\n    indicators: TechnicalIndicators,\n    trendSignal: 'BUY' | 'SELL' | 'NEUTRAL',\n    momentumSignal: 'BUY' | 'SELL' | 'NEUTRAL',\n  ): number {\n    let strength = 50; // Base strength\n\n    // Helper to get last value\n    const getLast = (val: number | number[] | undefined): number => {\n      if (Array.isArray(val)) return val[val.length - 1] || 0;\n      return val || 0;\n    };\n\n    const rsi = getLast(indicators.rsi);\n    const trendStrength = indicators.trend_strength || 0;\n\n    // Add trend strength\n    strength += trendStrength * 0.3;\n\n    // Adjust based on signal alignment\n    if (trendSignal === momentumSignal && trendSignal !== 'NEUTRAL') {\n      strength += 20;\n    }\n\n    // Adjust based on RSI extremes\n    if (rsi < 20 || rsi > 80) {\n      strength += 10;\n    }\n\n    return Math.min(100, Math.max(0, Math.round(strength)));\n  }\n\n  /**\n   * Detect chart patterns\n   */\n  private detectPatterns(priceHistory: PriceData[], indicators: TechnicalIndicators): string[] {\n    const patterns: string[] = [];\n\n    const currentPrice = priceHistory[priceHistory.length - 1].close;\n\n    // Helper to get last value\n    const getLast = (val: number | number[] | undefined): number => {\n      if (Array.isArray(val)) return val[val.length - 1] || 0;\n      return val || 0;\n    };\n\n    const bandwidth = indicators.bollinger_bands?.bandwidth || 0;\n    const bbUpper = getLast(indicators.bollinger_bands?.upper);\n    const bbLower = getLast(indicators.bollinger_bands?.lower);\n    const sma50 = getLast(indicators.sma_50);\n    const sma200 = getLast(indicators.sma_200);\n    const macdLine = getLast(indicators.macd?.macd);\n    const macdSignal = getLast(indicators.macd?.signal);\n    const macdHist = getLast(indicators.macd?.histogram);\n\n    // Bollinger Bands squeeze\n    if (bandwidth < 10) {\n      patterns.push('Bollinger Bands Squeeze - Volatility Compression');\n    }\n\n    // Price touching Bollinger Bands\n    if (currentPrice >= bbUpper) {\n      patterns.push('Price at Upper Bollinger Band - Overbought');\n    } else if (currentPrice <= bbLower) {\n      patterns.push('Price at Lower Bollinger Band - Oversold');\n    }\n\n    // Golden Cross / Death Cross\n    if (sma50 > sma200) {\n      patterns.push('Golden Cross - Bullish Long-term');\n    } else if (sma50 < sma200) {\n      patterns.push('Death Cross - Bearish Long-term');\n    }\n\n    // MACD Crossover\n    if (macdLine > macdSignal && macdHist > 0) {\n      patterns.push('MACD Bullish Crossover');\n    } else if (macdLine < macdSignal && macdHist < 0) {\n      patterns.push('MACD Bearish Crossover');\n    }\n\n    return patterns;\n  }\n\n  /**\n   * Calculate support and resistance levels\n   */\n  private calculateSupportResistance(priceHistory: PriceData[]): {\n    supportLevels: number[];\n    resistanceLevels: number[];\n  } {\n    const highs = priceHistory.map((p) => p.high);\n    const lows = priceHistory.map((p) => p.low);\n\n    // Find local maxima and minima\n    const resistanceLevels: number[] = [];\n    const supportLevels: number[] = [];\n\n    for (let i = 2; i < highs.length - 2; i++) {\n      // Check if local maximum\n      if (\n        highs[i] > highs[i - 1] &&\n        highs[i] > highs[i - 2] &&\n        highs[i] > highs[i + 1] &&\n        highs[i] > highs[i + 2]\n      ) {\n        resistanceLevels.push(highs[i]);\n      }\n\n      // Check if local minimum\n      if (\n        lows[i] < lows[i - 1] &&\n        lows[i] < lows[i - 2] &&\n        lows[i] < lows[i + 1] &&\n        lows[i] < lows[i + 2]\n      ) {\n        supportLevels.push(lows[i]);\n      }\n    }\n\n    // Return top 3 levels\n    return {\n      supportLevels: supportLevels.slice(-3).reverse(),\n      resistanceLevels: resistanceLevels.slice(-3).reverse(),\n    };\n  }\n\n  /**\n   * Generate recommendations\n   */\n  private generateRecommendations(\n    indicators: TechnicalIndicators,\n    signals: any,\n    patterns: string[],\n  ): string[] {\n    const recommendations: string[] = [];\n\n    // Helper to get last value\n    const getLast = (val: number | number[] | undefined): number => {\n      if (Array.isArray(val)) return val[val.length - 1] || 0;\n      return val || 0;\n    };\n\n    const rsi = getLast(indicators.rsi);\n    const trendStrength = indicators.trend_strength || 0;\n\n    // Overall recommendation\n    if (signals.overall === 'BUY') {\n      recommendations.push(\n        `Ô¼å´©Å COMPRA (${signals.strength}% confian├ºa): Indicadores t├®cnicos sugerem tend├¬ncia de alta`,\n      );\n    } else if (signals.overall === 'SELL') {\n      recommendations.push(\n        `Ô¼ç´©Å VENDA (${signals.strength}% confian├ºa): Indicadores t├®cnicos sugerem tend├¬ncia de baixa`,\n      );\n    } else {\n      recommendations.push(`ÔÅ©´©Å NEUTRO: Aguardar confirma├º├úo de tend├¬ncia`);\n    }\n\n    // RSI recommendations\n    if (rsi < 30) {\n      recommendations.push(\n        `­ƒôè RSI em ${rsi.toFixed(1)} - Ativo sobrevendido, poss├¡vel revers├úo de alta`,\n      );\n    } else if (rsi > 70) {\n      recommendations.push(`­ƒôè RSI em ${rsi.toFixed(1)} - Ativo sobrecomprado, poss├¡vel corre├º├úo`);\n    }\n\n    // Trend recommendations\n    if (indicators.trend === 'UPTREND' && trendStrength > 70) {\n      recommendations.push(`­ƒôê Tend├¬ncia de alta forte (${trendStrength}%)`);\n    } else if (indicators.trend === 'DOWNTREND' && trendStrength > 70) {\n      recommendations.push(`­ƒôë Tend├¬ncia de baixa forte (${trendStrength}%)`);\n    }\n\n    // Volatility recommendations\n    if (signals.volatilitySignal === 'LOW') {\n      recommendations.push(`­ƒö╣ Volatilidade baixa - Poss├¡vel movimento forte em breve`);\n    } else if (signals.volatilitySignal === 'HIGH') {\n      recommendations.push(`­ƒö© Volatilidade alta - Cuidado com movimentos bruscos`);\n    }\n\n    return recommendations;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\analysis\\technical\\technical-indicators.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\analysis\\analysis.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\analysis\\analysis.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\analysis\\analysis.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'User' is defined but never used.","line":11,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":7}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger, NotFoundException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport {\n  Analysis,\n  AnalysisType,\n  AnalysisStatus,\n  Asset,\n  AssetPrice,\n  Recommendation,\n  User,\n} from '@database/entities';\nimport { ScrapersService } from '@scrapers/scrapers.service';\n\n@Injectable()\nexport class AnalysisService {\n  private readonly logger = new Logger(AnalysisService.name);\n\n  constructor(\n    @InjectRepository(Analysis)\n    private analysisRepository: Repository<Analysis>,\n    @InjectRepository(Asset)\n    private assetRepository: Repository<Asset>,\n    @InjectRepository(AssetPrice)\n    private assetPriceRepository: Repository<AssetPrice>,\n    private scrapersService: ScrapersService,\n  ) {}\n\n  async generateFundamentalAnalysis(ticker: string) {\n    this.logger.log(`Generating fundamental analysis for ${ticker}`);\n\n    // Get asset ID from ticker\n    const asset = await this.assetRepository.findOne({\n      where: { ticker: ticker.toUpperCase() },\n    });\n\n    if (!asset) {\n      throw new NotFoundException(`Asset with ticker ${ticker} not found`);\n    }\n\n    // Create analysis record\n    const analysis = this.analysisRepository.create({\n      assetId: asset.id,\n      type: AnalysisType.FUNDAMENTAL,\n      status: AnalysisStatus.PROCESSING,\n    });\n    await this.analysisRepository.save(analysis);\n\n    try {\n      // Scrape fundamental data from multiple sources\n      const result = await this.scrapersService.scrapeFundamentalData(ticker);\n\n      // Update analysis with results\n      analysis.status = AnalysisStatus.COMPLETED;\n      analysis.analysis = result.data;\n      analysis.dataSources = result.sources;\n      analysis.sourcesCount = result.sourcesCount;\n      analysis.confidenceScore = result.confidence;\n      analysis.completedAt = new Date();\n\n      await this.analysisRepository.save(analysis);\n\n      return analysis;\n    } catch (error) {\n      this.logger.error(`Failed to generate fundamental analysis: ${error.message}`);\n      analysis.status = AnalysisStatus.FAILED;\n      analysis.errorMessage = error.message;\n      await this.analysisRepository.save(analysis);\n      throw error;\n    }\n  }\n\n  async generateTechnicalAnalysis(ticker: string) {\n    this.logger.log(`Generating technical analysis for ${ticker}`);\n\n    // Get asset\n    const asset = await this.assetRepository.findOne({\n      where: { ticker: ticker.toUpperCase() },\n    });\n\n    if (!asset) {\n      throw new NotFoundException(`Asset with ticker ${ticker} not found`);\n    }\n\n    // Create analysis record\n    const analysis = this.analysisRepository.create({\n      assetId: asset.id,\n      type: AnalysisType.TECHNICAL,\n      status: AnalysisStatus.PROCESSING,\n    });\n    await this.analysisRepository.save(analysis);\n\n    try {\n      const startTime = Date.now();\n\n      // Get last 200 days of price data for technical indicators\n      const prices = await this.assetPriceRepository.find({\n        where: { assetId: asset.id },\n        order: { date: 'DESC' },\n        take: 200,\n      });\n\n      if (prices.length < 20) {\n        throw new Error(\n          'Insufficient price data for technical analysis (minimum 20 days required)',\n        );\n      }\n\n      // Reverse to chronological order for calculations\n      prices.reverse();\n\n      // Calculate technical indicators\n      const indicators = this.calculateTechnicalIndicators(prices);\n\n      // Generate recommendation based on indicators\n      const recommendation = this.generateRecommendation(indicators);\n\n      // Calculate confidence score based on indicator alignment\n      const confidence = this.calculateConfidence(indicators);\n\n      // Update analysis with results\n      analysis.status = AnalysisStatus.COMPLETED;\n      analysis.recommendation = recommendation;\n      analysis.confidenceScore = confidence;\n      analysis.indicators = indicators;\n      analysis.analysis = {\n        summary: this.generateSummary(indicators, recommendation),\n        signals: this.identifySignals(indicators),\n        trends: this.identifyTrends(indicators),\n      };\n      analysis.dataSources = ['database'];\n      analysis.sourcesCount = 1;\n      analysis.processingTime = Date.now() - startTime;\n      analysis.completedAt = new Date();\n\n      await this.analysisRepository.save(analysis);\n\n      this.logger.log(`Technical analysis completed for ${ticker} in ${analysis.processingTime}ms`);\n      return analysis;\n    } catch (error) {\n      this.logger.error(`Failed to generate technical analysis: ${error.message}`);\n      analysis.status = AnalysisStatus.FAILED;\n      analysis.errorMessage = error.message;\n      await this.analysisRepository.save(analysis);\n      throw error;\n    }\n  }\n\n  private calculateTechnicalIndicators(prices: AssetPrice[]) {\n    const closes = prices.map((p) => Number(p.close));\n    const volumes = prices.map((p) => Number(p.volume));\n\n    return {\n      rsi: this.calculateRSI(closes, 14),\n      sma20: this.calculateSMA(closes, 20),\n      sma50: this.calculateSMA(closes, 50),\n      sma200: this.calculateSMA(closes, 200),\n      ema12: this.calculateEMA(closes, 12),\n      ema26: this.calculateEMA(closes, 26),\n      macd: this.calculateMACD(closes),\n      volume_avg: this.calculateSMA(volumes, 20),\n      current_price: closes[closes.length - 1],\n      price_change_1d: (closes[closes.length - 1] / closes[closes.length - 2] - 1) * 100,\n      price_change_5d:\n        closes.length >= 5\n          ? (closes[closes.length - 1] / closes[closes.length - 6] - 1) * 100\n          : null,\n      price_change_20d:\n        closes.length >= 20\n          ? (closes[closes.length - 1] / closes[closes.length - 21] - 1) * 100\n          : null,\n    };\n  }\n\n  private calculateRSI(prices: number[], period: number = 14): number {\n    if (prices.length < period + 1) return 50; // Neutral if insufficient data\n\n    let gains = 0;\n    let losses = 0;\n\n    // Calculate initial average gain/loss\n    for (let i = 1; i <= period; i++) {\n      const change = prices[i] - prices[i - 1];\n      if (change >= 0) gains += change;\n      else losses -= change;\n    }\n\n    let avgGain = gains / period;\n    let avgLoss = losses / period;\n\n    // Calculate RSI using smoothed averages\n    for (let i = period + 1; i < prices.length; i++) {\n      const change = prices[i] - prices[i - 1];\n      if (change >= 0) {\n        avgGain = (avgGain * (period - 1) + change) / period;\n        avgLoss = (avgLoss * (period - 1)) / period;\n      } else {\n        avgGain = (avgGain * (period - 1)) / period;\n        avgLoss = (avgLoss * (period - 1) - change) / period;\n      }\n    }\n\n    if (avgLoss === 0) return 100;\n    const rs = avgGain / avgLoss;\n    return 100 - 100 / (1 + rs);\n  }\n\n  private calculateSMA(prices: number[], period: number): number | null {\n    if (prices.length < period) return null;\n    const slice = prices.slice(-period);\n    return slice.reduce((a, b) => a + b, 0) / period;\n  }\n\n  private calculateEMA(prices: number[], period: number): number | null {\n    if (prices.length < period) return null;\n\n    const multiplier = 2 / (period + 1);\n    let ema = this.calculateSMA(prices.slice(0, period), period);\n\n    for (let i = period; i < prices.length; i++) {\n      ema = (prices[i] - ema) * multiplier + ema;\n    }\n\n    return ema;\n  }\n\n  private calculateMACD(prices: number[]) {\n    const ema12 = this.calculateEMA(prices, 12);\n    const ema26 = this.calculateEMA(prices, 26);\n\n    if (!ema12 || !ema26) return { line: null, signal: null, histogram: null };\n\n    const macdLine = ema12 - ema26;\n\n    // Simplified signal line (would need full MACD history for accurate EMA of MACD)\n    const signalLine = macdLine * 0.9; // Approximation\n\n    return {\n      line: macdLine,\n      signal: signalLine,\n      histogram: macdLine - signalLine,\n    };\n  }\n\n  private generateRecommendation(indicators: any): Recommendation {\n    let score = 0;\n\n    // RSI signals\n    if (indicators.rsi < 30)\n      score += 2; // Oversold - buy signal\n    else if (indicators.rsi < 40) score += 1;\n    else if (indicators.rsi > 70)\n      score -= 2; // Overbought - sell signal\n    else if (indicators.rsi > 60) score -= 1;\n\n    // Moving average signals\n    if (indicators.sma20 && indicators.current_price > indicators.sma20) score += 1;\n    else if (indicators.sma20 && indicators.current_price < indicators.sma20) score -= 1;\n\n    if (indicators.sma50 && indicators.current_price > indicators.sma50) score += 1;\n    else if (indicators.sma50 && indicators.current_price < indicators.sma50) score -= 1;\n\n    // MACD signals\n    if (indicators.macd.histogram && indicators.macd.histogram > 0) score += 1;\n    else if (indicators.macd.histogram && indicators.macd.histogram < 0) score -= 1;\n\n    // Price momentum\n    if (indicators.price_change_5d && indicators.price_change_5d > 5) score += 1;\n    else if (indicators.price_change_5d && indicators.price_change_5d < -5) score -= 1;\n\n    // Convert score to recommendation\n    if (score >= 4) return Recommendation.STRONG_BUY;\n    if (score >= 2) return Recommendation.BUY;\n    if (score <= -4) return Recommendation.STRONG_SELL;\n    if (score <= -2) return Recommendation.SELL;\n    return Recommendation.HOLD;\n  }\n\n  private calculateConfidence(indicators: any): number {\n    let signals = 0;\n    let total = 0;\n\n    // Check RSI confidence\n    if (indicators.rsi < 30 || indicators.rsi > 70) signals += 2;\n    else if (indicators.rsi < 40 || indicators.rsi > 60) signals += 1;\n    total += 2;\n\n    // Check MA alignment\n    if (indicators.sma20 && indicators.sma50) {\n      const trend =\n        indicators.current_price > indicators.sma20 === indicators.sma20 > indicators.sma50;\n      if (trend) signals += 2;\n      total += 2;\n    }\n\n    // Check MACD strength\n    if (indicators.macd.histogram) {\n      if (Math.abs(indicators.macd.histogram) > 0.5) signals += 1;\n      total += 1;\n    }\n\n    return Math.min(signals / total, 1);\n  }\n\n  private generateSummary(indicators: any, recommendation: Recommendation): string {\n    const price = indicators.current_price.toFixed(2);\n    const rsi = indicators.rsi.toFixed(1);\n    const change5d = indicators.price_change_5d?.toFixed(2) || 'N/A';\n\n    return (\n      `An├ílise t├®cnica indica ${recommendation.toUpperCase()}. ` +\n      `Pre├ºo atual: R$ ${price}. RSI: ${rsi}. ` +\n      `Varia├º├úo 5 dias: ${change5d}%.`\n    );\n  }\n\n  private identifySignals(indicators: any): string[] {\n    const signals: string[] = [];\n\n    if (indicators.rsi < 30) signals.push('RSI indica sobrevenda (poss├¡vel revers├úo de alta)');\n    else if (indicators.rsi > 70)\n      signals.push('RSI indica sobrecompra (poss├¡vel revers├úo de baixa)');\n\n    if (indicators.sma20 && indicators.current_price > indicators.sma20) {\n      signals.push('Pre├ºo acima da SMA 20 (tend├¬ncia de alta)');\n    }\n\n    if (indicators.macd.histogram && indicators.macd.histogram > 0) {\n      signals.push('MACD positivo (momentum de alta)');\n    } else if (indicators.macd.histogram && indicators.macd.histogram < 0) {\n      signals.push('MACD negativo (momentum de baixa)');\n    }\n\n    return signals;\n  }\n\n  private identifyTrends(indicators: any): any {\n    return {\n      short_term:\n        indicators.sma20 && indicators.current_price > indicators.sma20 ? 'bullish' : 'bearish',\n      medium_term:\n        indicators.sma50 && indicators.current_price > indicators.sma50 ? 'bullish' : 'bearish',\n      long_term:\n        indicators.sma200 && indicators.current_price > indicators.sma200 ? 'bullish' : 'bearish',\n    };\n  }\n\n  async generateCompleteAnalysis(ticker: string, userId?: string) {\n    this.logger.log(`Generating COMPLETE analysis (Fundamental + Technical) for ${ticker}`);\n\n    // Get asset ID from ticker\n    const asset = await this.assetRepository.findOne({\n      where: { ticker: ticker.toUpperCase() },\n    });\n\n    if (!asset) {\n      throw new NotFoundException(`Asset with ticker ${ticker} not found`);\n    }\n\n    // Check for existing analysis and delete it to allow new one\n    if (userId) {\n      const existingAnalysis = await this.analysisRepository.findOne({\n        where: {\n          assetId: asset.id,\n          userId: userId,\n          type: AnalysisType.COMPLETE,\n        },\n      });\n\n      if (existingAnalysis) {\n        this.logger.log(\n          `Removing old analysis for ${ticker} by user ${userId} before creating new one`,\n        );\n        await this.analysisRepository.remove(existingAnalysis);\n      }\n    }\n\n    // Create analysis record\n    const createData: Partial<Analysis> = {\n      assetId: asset.id,\n      type: AnalysisType.COMPLETE,\n      status: AnalysisStatus.PROCESSING,\n    };\n\n    if (userId) {\n      createData.userId = userId;\n    }\n\n    const analysis = this.analysisRepository.create(createData);\n    await this.analysisRepository.save(analysis);\n\n    this.logger.log(`Analysis created with ID: ${analysis.id}`);\n\n    try {\n      const startTime = Date.now();\n\n      // Ô£à STEP 1: FUNDAMENTAL ANALYSIS (multi-source scraping)\n      this.logger.log(`[Complete] Step 1/3: Scraping fundamental data from 6 sources...`);\n      const fundamentalResult = await this.scrapersService.scrapeFundamentalData(ticker);\n      this.logger.log(\n        `[Complete] Fundamental analysis complete: ${fundamentalResult.sourcesCount} sources, ${(fundamentalResult.confidence * 100).toFixed(1)}% confidence`,\n      );\n\n      // Ô£à STEP 2: TECHNICAL ANALYSIS (indicators from price data)\n      this.logger.log(`[Complete] Step 2/3: Calculating technical indicators...`);\n      let technicalAnalysis: any = null;\n      let technicalRecommendation: Recommendation | null = null;\n      let technicalConfidence = 0;\n\n      const prices = await this.assetPriceRepository.find({\n        where: { assetId: asset.id },\n        order: { date: 'DESC' },\n        take: 200,\n      });\n\n      if (prices.length >= 20) {\n        prices.reverse(); // Chronological order for calculations\n        const indicators = this.calculateTechnicalIndicators(prices);\n        technicalRecommendation = this.generateRecommendation(indicators);\n        technicalConfidence = this.calculateConfidence(indicators);\n\n        technicalAnalysis = {\n          recommendation: technicalRecommendation,\n          confidence: technicalConfidence,\n          indicators,\n          summary: this.generateSummary(indicators, technicalRecommendation),\n          signals: this.identifySignals(indicators),\n          trends: this.identifyTrends(indicators),\n        };\n\n        this.logger.log(\n          `[Complete] Technical analysis complete: ${technicalRecommendation}, ${(technicalConfidence * 100).toFixed(1)}% confidence`,\n        );\n      } else {\n        this.logger.warn(\n          `[Complete] Insufficient price data (${prices.length} days), skipping technical analysis (minimum 20 required)`,\n        );\n      }\n\n      // Ô£à STEP 3: COMBINE RESULTS (60% fundamental + 40% technical)\n      this.logger.log(`[Complete] Step 3/3: Combining fundamental and technical analysis...`);\n\n      const combinedAnalysis = {\n        fundamental: {\n          data: fundamentalResult.data,\n          sources: fundamentalResult.sources,\n          sourcesCount: fundamentalResult.sourcesCount,\n          confidence: fundamentalResult.confidence,\n        },\n        technical: technicalAnalysis\n          ? {\n              recommendation: technicalAnalysis.recommendation,\n              confidence: technicalAnalysis.confidence,\n              indicators: technicalAnalysis.indicators,\n              summary: technicalAnalysis.summary,\n              signals: technicalAnalysis.signals,\n              trends: technicalAnalysis.trends,\n            }\n          : null,\n        combined: {\n          recommendation: this.combineRecommendations(\n            fundamentalResult.data,\n            technicalRecommendation,\n          ),\n          confidence: technicalAnalysis\n            ? this.combinedConfidence(fundamentalResult.confidence, technicalConfidence)\n            : fundamentalResult.confidence, // Fallback to fundamental only if no technical data\n          explanation: this.generateCombinedExplanation(\n            fundamentalResult.confidence,\n            technicalRecommendation,\n            technicalConfidence,\n          ),\n        },\n      };\n\n      // Update analysis with combined results\n      analysis.status = AnalysisStatus.COMPLETED;\n      analysis.analysis = combinedAnalysis;\n      analysis.recommendation = combinedAnalysis.combined.recommendation;\n      analysis.confidenceScore = combinedAnalysis.combined.confidence;\n      analysis.dataSources = [\n        ...fundamentalResult.sources,\n        ...(technicalAnalysis ? ['database'] : []),\n      ];\n      analysis.sourcesCount = analysis.dataSources.length;\n      analysis.processingTime = Date.now() - startTime;\n      analysis.completedAt = new Date();\n\n      await this.analysisRepository.save(analysis);\n\n      this.logger.log(\n        `[Complete] Ô£ô Complete analysis finished for ${ticker} in ${analysis.processingTime}ms: ` +\n          `${analysis.recommendation} (${(analysis.confidenceScore * 100).toFixed(1)}% confidence, ${analysis.sourcesCount} sources)`,\n      );\n\n      return analysis;\n    } catch (error) {\n      this.logger.error(`Error generating complete analysis: ${error.message}`);\n      analysis.status = AnalysisStatus.FAILED;\n      analysis.analysis = { error: error.message };\n      await this.analysisRepository.save(analysis);\n      throw error;\n    }\n  }\n\n  /**\n   * Combine fundamental data and technical recommendation into final recommendation\n   * Weight: 60% fundamental, 40% technical\n   */\n  private combineRecommendations(\n    fundamentalData: any,\n    technicalRecommendation?: Recommendation | null,\n  ): Recommendation {\n    // If no technical data, base on fundamental indicators only\n    if (!technicalRecommendation) {\n      this.logger.debug('[Combine] No technical recommendation, using fundamental indicators');\n      return this.recommendationFromFundamentals(fundamentalData);\n    }\n\n    // Score fundamental indicators (-2 to +2)\n    const fundamentalScore = this.scoreFundamentals(fundamentalData);\n\n    // Score technical recommendation (-2 to +2)\n    const technicalScore = this.scoreRecommendation(technicalRecommendation);\n\n    // Weighted average: 60% fundamental + 40% technical\n    const combinedScore = fundamentalScore * 0.6 + technicalScore * 0.4;\n\n    this.logger.debug(\n      `[Combine] Fundamental score: ${fundamentalScore}, Technical score: ${technicalScore}, Combined: ${combinedScore.toFixed(2)}`,\n    );\n\n    // Convert combined score to recommendation\n    if (combinedScore >= 1.5) return Recommendation.STRONG_BUY;\n    if (combinedScore >= 0.5) return Recommendation.BUY;\n    if (combinedScore <= -1.5) return Recommendation.STRONG_SELL;\n    if (combinedScore <= -0.5) return Recommendation.SELL;\n    return Recommendation.HOLD;\n  }\n\n  /**\n   * Score fundamental data (-2 to +2)\n   */\n  private scoreFundamentals(data: any): number {\n    let score = 0;\n\n    // P/L (Price to Earnings)\n    if (data.pl) {\n      if (data.pl < 10)\n        score += 1; // Undervalued\n      else if (data.pl > 25) score -= 1; // Overvalued\n    }\n\n    // P/VP (Price to Book Value)\n    if (data.pvp) {\n      if (data.pvp < 1.5)\n        score += 1; // Undervalued\n      else if (data.pvp > 3) score -= 1; // Overvalued\n    }\n\n    // ROE (Return on Equity)\n    if (data.roe) {\n      if (data.roe > 15)\n        score += 1; // Good profitability\n      else if (data.roe < 5) score -= 1; // Poor profitability\n    }\n\n    // Dividend Yield\n    if (data.dividendYield || data.dy) {\n      const dy = data.dividendYield || data.dy;\n      if (dy > 6) score += 0.5; // Good dividend payer\n    }\n\n    return Math.max(-2, Math.min(2, score)); // Clamp to [-2, 2]\n  }\n\n  /**\n   * Convert recommendation enum to numeric score (-2 to +2)\n   */\n  private scoreRecommendation(rec: Recommendation): number {\n    switch (rec) {\n      case Recommendation.STRONG_BUY:\n        return 2;\n      case Recommendation.BUY:\n        return 1;\n      case Recommendation.HOLD:\n        return 0;\n      case Recommendation.SELL:\n        return -1;\n      case Recommendation.STRONG_SELL:\n        return -2;\n      default:\n        return 0;\n    }\n  }\n\n  /**\n   * Generate recommendation from fundamental data only (fallback)\n   */\n  private recommendationFromFundamentals(data: any): Recommendation {\n    const score = this.scoreFundamentals(data);\n\n    if (score >= 1.5) return Recommendation.STRONG_BUY;\n    if (score >= 0.5) return Recommendation.BUY;\n    if (score <= -1.5) return Recommendation.STRONG_SELL;\n    if (score <= -0.5) return Recommendation.SELL;\n    return Recommendation.HOLD;\n  }\n\n  /**\n   * Calculate combined confidence score (weighted average)\n   * Weight: 60% fundamental + 40% technical\n   */\n  private combinedConfidence(fundamentalConf: number, technicalConf: number): number {\n    const combined = fundamentalConf * 0.6 + technicalConf * 0.4;\n    this.logger.debug(\n      `[Confidence] Combined: ${(combined * 100).toFixed(1)}% (Fundamental: ${(fundamentalConf * 100).toFixed(1)}%, Technical: ${(technicalConf * 100).toFixed(1)}%)`,\n    );\n    return combined;\n  }\n\n  /**\n   * Generate explanation of how recommendation was combined\n   */\n  private generateCombinedExplanation(\n    fundamentalConf: number,\n    technicalRec: Recommendation | null,\n    technicalConf: number,\n  ): string {\n    if (!technicalRec) {\n      return (\n        `Baseado apenas em an├ílise fundamentalista (${(fundamentalConf * 100).toFixed(0)}% confian├ºa). ` +\n        `Dados t├®cnicos insuficientes (m├¡nimo 20 dias de pre├ºos necess├írio).`\n      );\n    }\n\n    return (\n      `An├ílise combinada: 60% fundamentalista (${(fundamentalConf * 100).toFixed(0)}% confian├ºa) + ` +\n      `40% t├®cnica (${(technicalConf * 100).toFixed(0)}% confian├ºa, recomenda├º├úo: ${technicalRec}). ` +\n      `Confian├ºa final: ${((fundamentalConf * 0.6 + technicalConf * 0.4) * 100).toFixed(0)}%.`\n    );\n  }\n\n  async findAll(\n    userId: string,\n    params?: {\n      type?: string;\n      ticker?: string;\n      limit?: number;\n      offset?: number;\n    },\n  ) {\n    const where: any = { userId };\n\n    if (params?.type) {\n      where.type = params.type;\n    }\n\n    if (params?.ticker) {\n      where.asset = { ticker: params.ticker.toUpperCase() };\n    }\n\n    const query = this.analysisRepository.find({\n      where,\n      relations: ['asset'],\n      order: { createdAt: 'DESC' },\n      take: params?.limit || 50,\n      skip: params?.offset || 0,\n    });\n\n    return query;\n  }\n\n  async findByTicker(ticker: string, type?: string) {\n    const where: any = { asset: { ticker: ticker.toUpperCase() } };\n    if (type) {\n      where.type = type;\n    }\n\n    return this.analysisRepository.find({\n      where,\n      order: { createdAt: 'DESC' },\n    });\n  }\n\n  async findById(id: string) {\n    const analysis = await this.analysisRepository.findOne({\n      where: { id },\n      relations: ['asset'],\n    });\n\n    if (!analysis) {\n      throw new NotFoundException('Analysis not found');\n    }\n\n    // Buscar pre├ºo mais recente do ativo\n    const latestPrice = await this.assetPriceRepository.findOne({\n      where: { assetId: analysis.assetId },\n      order: { date: 'DESC' },\n    });\n\n    // Retornar an├ílise com pre├ºo atual\n    return {\n      ...analysis,\n      currentPrice: latestPrice?.close,\n      currentPriceDate: latestPrice?.date,\n      changePercent: latestPrice?.changePercent,\n    };\n  }\n\n  async deleteAnalysis(id: string, userId: string) {\n    const analysis = await this.analysisRepository.findOne({\n      where: { id, userId },\n    });\n\n    if (!analysis) {\n      throw new NotFoundException('Analysis not found or you do not have permission to delete it');\n    }\n\n    await this.analysisRepository.remove(analysis);\n\n    this.logger.log(`Analysis ${id} deleted by user ${userId}`);\n\n    return { message: 'Analysis deleted successfully', id };\n  }\n\n  async requestBulkAnalysis(type: AnalysisType, userId: string) {\n    this.logger.log(`Requesting bulk ${type} analysis for all active assets`);\n\n    // Get all active assets\n    const assets = await this.assetRepository.find({\n      where: { isActive: true },\n      order: { ticker: 'ASC' },\n    });\n\n    if (assets.length === 0) {\n      return {\n        message: 'No active assets found',\n        total: 0,\n        requested: 0,\n      };\n    }\n\n    this.logger.log(`Found ${assets.length} active assets to analyze`);\n\n    const requested = [];\n    const skipped = [];\n\n    // Create analysis records for each asset\n    for (const asset of assets) {\n      try {\n        // Check if analysis already exists and is recent (less than 7 days old)\n        const existingAnalysis = await this.analysisRepository.findOne({\n          where: {\n            assetId: asset.id,\n            type,\n            userId,\n          },\n          order: { createdAt: 'DESC' },\n        });\n\n        const sevenDaysAgo = new Date();\n        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n\n        if (existingAnalysis && existingAnalysis.createdAt > sevenDaysAgo) {\n          this.logger.debug(`Skipping ${asset.ticker} - recent analysis exists`);\n          skipped.push(asset.ticker);\n          continue;\n        }\n\n        // Create pending analysis record\n        const analysis = this.analysisRepository.create({\n          assetId: asset.id,\n          type,\n          userId,\n          status: AnalysisStatus.PENDING,\n        });\n\n        await this.analysisRepository.save(analysis);\n        requested.push(asset.ticker);\n\n        this.logger.debug(`Created pending ${type} analysis for ${asset.ticker}`);\n      } catch (error) {\n        this.logger.error(`Failed to create analysis for ${asset.ticker}: ${error.message}`);\n      }\n    }\n\n    this.logger.log(\n      `Bulk analysis request completed: ${requested.length} requested, ${skipped.length} skipped`,\n    );\n\n    return {\n      message: `Bulk ${type} analysis requested successfully`,\n      total: assets.length,\n      requested: requested.length,\n      skipped: skipped.length,\n      requestedAssets: requested,\n      skippedAssets: skipped,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\assets\\assets-update.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\assets\\assets-update.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fundamentalData' is assigned a value but never used.","line":132,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":132,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'startTime' is assigned a value but never used.","line":450,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":450,"endColumn":20}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, In, LessThan } from 'typeorm';\nimport {\n  Asset,\n  FundamentalData,\n  UpdateLog,\n  UpdateStatus,\n  UpdateTrigger,\n  Portfolio,\n  PortfolioPosition,\n} from '@database/entities';\nimport { ScrapersService } from '../../scrapers/scrapers.service';\nimport { AppWebSocketGateway } from '../../websocket/websocket.gateway';\n\nexport interface UpdateResult {\n  success: boolean;\n  assetId: string;\n  ticker: string;\n  status: UpdateStatus;\n  error?: string;\n  duration?: number;\n  metadata?: {\n    sources?: string[];\n    sourcesCount?: number;\n    confidence?: number;\n    dataPoints?: number;\n    discrepancies?: any[];\n  };\n}\n\nexport interface BatchUpdateResult {\n  totalAssets: number;\n  successCount: number;\n  failedCount: number;\n  results: UpdateResult[];\n  duration: number;\n}\n\n@Injectable()\nexport class AssetsUpdateService {\n  private readonly logger = new Logger(AssetsUpdateService.name);\n\n  // Configuration\n  private readonly MAX_RETRY_COUNT = 3;\n  private readonly OUTDATED_THRESHOLD_DAYS = 7;\n  private readonly MIN_SOURCES = 3;\n  private readonly MIN_CONFIDENCE = 0.7;\n  private readonly RATE_LIMIT_DELAY = 2000; // 2 seconds between requests\n\n  constructor(\n    @InjectRepository(Asset)\n    private assetRepository: Repository<Asset>,\n    @InjectRepository(FundamentalData)\n    private fundamentalDataRepository: Repository<FundamentalData>,\n    @InjectRepository(UpdateLog)\n    private updateLogRepository: Repository<UpdateLog>,\n    @InjectRepository(Portfolio)\n    private portfolioRepository: Repository<Portfolio>,\n    @InjectRepository(PortfolioPosition)\n    private portfolioPositionRepository: Repository<PortfolioPosition>,\n    private scrapersService: ScrapersService,\n    private webSocketGateway: AppWebSocketGateway,\n  ) {}\n\n  /**\n   * M├ëTODO 1: Atualizar um ├║nico ativo\n   * Usado para atualiza├º├Áes manuais de ativos individuais\n   */\n  async updateSingleAsset(\n    ticker: string,\n    userId?: string,\n    triggeredBy: UpdateTrigger = UpdateTrigger.MANUAL,\n  ): Promise<UpdateResult> {\n    this.logger.log(`[UPDATE-SINGLE] Starting update for ${ticker} (user: ${userId || 'system'})`);\n    const startTime = Date.now();\n\n    // 1. Find asset in database\n    const asset = await this.assetRepository.findOne({ where: { ticker } });\n    if (!asset) {\n      throw new NotFoundException(`Asset ${ticker} not found`);\n    }\n\n    // 2. Check if asset has auto-update disabled\n    if (!asset.autoUpdateEnabled && triggeredBy === UpdateTrigger.CRON) {\n      this.logger.warn(`[UPDATE-SINGLE] Auto-update disabled for ${ticker}, skipping cron update`);\n      return {\n        success: false,\n        assetId: asset.id,\n        ticker: asset.ticker,\n        status: UpdateStatus.CANCELLED,\n        error: 'Auto-update disabled for this asset',\n      };\n    }\n\n    // 3. Create update log entry\n    const updateLog = this.updateLogRepository.create({\n      asset,\n      assetId: asset.id,\n      userId,\n      startedAt: new Date(),\n      status: UpdateStatus.RUNNING,\n      triggeredBy,\n    });\n    await this.updateLogRepository.save(updateLog);\n\n    // 4. Emit WebSocket event: update started\n    this.webSocketGateway.emitAssetUpdateStarted({\n      assetId: asset.id,\n      ticker: asset.ticker,\n      updateLogId: updateLog.id,\n      triggeredBy,\n    });\n\n    try {\n      // 5. Execute scrapers\n      this.logger.log(`[UPDATE-SINGLE] Scraping data for ${ticker}...`);\n      const scrapedResult = await this.scrapersService.scrapeFundamentalData(ticker);\n\n      // 6. Validate data quality\n      if (!scrapedResult || scrapedResult.sourcesCount < this.MIN_SOURCES) {\n        throw new Error(\n          `Insufficient data sources: ${scrapedResult?.sourcesCount || 0} < ${this.MIN_SOURCES}`,\n        );\n      }\n\n      if (scrapedResult.confidence < this.MIN_CONFIDENCE) {\n        throw new Error(`Low confidence: ${scrapedResult.confidence} < ${this.MIN_CONFIDENCE}`);\n      }\n\n      // 7. Map and save fundamental data\n      const fundamentalData = await this.saveFundamentalData(asset, scrapedResult);\n\n      // 8. Update asset tracking fields\n      asset.lastUpdated = new Date();\n      asset.lastUpdateStatus = 'success';\n      asset.lastUpdateError = null;\n      asset.updateRetryCount = 0;\n      await this.assetRepository.save(asset);\n\n      // 9. Complete update log\n      const duration = Date.now() - startTime;\n      updateLog.completedAt = new Date();\n      updateLog.status = UpdateStatus.SUCCESS;\n      updateLog.metadata = {\n        sources: scrapedResult.sources,\n        sourcesCount: scrapedResult.sourcesCount,\n        confidence: scrapedResult.confidence,\n        dataPoints: Object.keys(scrapedResult.data).length,\n        discrepancies: scrapedResult.discrepancies,\n        duration,\n      };\n      await this.updateLogRepository.save(updateLog);\n\n      // 10. Emit WebSocket event: update completed\n      this.webSocketGateway.emitAssetUpdateCompleted({\n        assetId: asset.id,\n        ticker: asset.ticker,\n        updateLogId: updateLog.id,\n        status: UpdateStatus.SUCCESS,\n        duration,\n        metadata: updateLog.metadata,\n      });\n\n      this.logger.log(`[UPDATE-SINGLE] Ô£à Successfully updated ${ticker} in ${duration}ms`);\n\n      return {\n        success: true,\n        assetId: asset.id,\n        ticker: asset.ticker,\n        status: UpdateStatus.SUCCESS,\n        duration,\n        metadata: updateLog.metadata,\n      };\n    } catch (error) {\n      // Handle failure\n      const duration = Date.now() - startTime;\n      const errorMessage = error.message || 'Unknown error';\n\n      this.logger.error(`[UPDATE-SINGLE] ÔØî Failed to update ${ticker}: ${errorMessage}`);\n\n      // Update asset tracking fields\n      asset.lastUpdateStatus = 'failed';\n      asset.lastUpdateError = errorMessage;\n      asset.updateRetryCount += 1;\n\n      // If max retries reached, disable auto-update\n      if (asset.updateRetryCount >= this.MAX_RETRY_COUNT) {\n        this.logger.warn(\n          `[UPDATE-SINGLE] Max retries reached for ${ticker}, disabling auto-update`,\n        );\n        asset.autoUpdateEnabled = false;\n      }\n\n      await this.assetRepository.save(asset);\n\n      // Update log with failure\n      updateLog.completedAt = new Date();\n      updateLog.status = UpdateStatus.FAILED;\n      updateLog.error = errorMessage;\n      updateLog.metadata = { duration };\n      await this.updateLogRepository.save(updateLog);\n\n      // Emit WebSocket event: update failed\n      this.webSocketGateway.emitAssetUpdateFailed({\n        assetId: asset.id,\n        ticker: asset.ticker,\n        updateLogId: updateLog.id,\n        error: errorMessage,\n        duration,\n      });\n\n      return {\n        success: false,\n        assetId: asset.id,\n        ticker: asset.ticker,\n        status: UpdateStatus.FAILED,\n        error: errorMessage,\n        duration,\n      };\n    }\n  }\n\n  /**\n   * M├ëTODO 2: Atualizar todos os ativos de um portf├│lio\n   * Usado quando o usu├írio quer atualizar todos os ativos do seu portf├│lio\n   */\n  async updatePortfolioAssets(portfolioId: string, userId: string): Promise<BatchUpdateResult> {\n    this.logger.log(`[UPDATE-PORTFOLIO] Starting update for portfolio ${portfolioId}`);\n    const startTime = Date.now();\n\n    // 1. Find portfolio and verify ownership\n    const portfolio = await this.portfolioRepository.findOne({\n      where: { id: portfolioId, user: { id: userId } },\n      relations: ['positions', 'positions.asset'],\n    });\n\n    if (!portfolio) {\n      throw new NotFoundException(`Portfolio ${portfolioId} not found or unauthorized`);\n    }\n\n    // 2. Extract unique assets from positions\n    const assets = portfolio.positions.map((pos) => pos.asset);\n    const uniqueTickers = [...new Set(assets.map((a) => a.ticker))];\n\n    if (uniqueTickers.length === 0) {\n      this.logger.warn(`[UPDATE-PORTFOLIO] Portfolio ${portfolioId} has no assets`);\n      return {\n        totalAssets: 0,\n        successCount: 0,\n        failedCount: 0,\n        results: [],\n        duration: Date.now() - startTime,\n      };\n    }\n\n    this.logger.log(`[UPDATE-PORTFOLIO] Found ${uniqueTickers.length} unique assets to update`);\n\n    // 3. Emit WebSocket event: batch update started\n    this.webSocketGateway.emitBatchUpdateStarted({\n      portfolioId,\n      totalAssets: uniqueTickers.length,\n      tickers: uniqueTickers,\n    });\n\n    // 4. Update all assets with rate limiting\n    const results: UpdateResult[] = [];\n    let successCount = 0;\n    let failedCount = 0;\n\n    for (let i = 0; i < uniqueTickers.length; i++) {\n      const ticker = uniqueTickers[i];\n\n      // Emit progress\n      this.webSocketGateway.emitBatchUpdateProgress({\n        portfolioId,\n        current: i + 1,\n        total: uniqueTickers.length,\n        currentTicker: ticker,\n      });\n\n      // Update asset\n      const result = await this.updateSingleAsset(ticker, userId, UpdateTrigger.MANUAL);\n      results.push(result);\n\n      if (result.success) {\n        successCount++;\n      } else {\n        failedCount++;\n      }\n\n      // Rate limiting: wait between requests (except last one)\n      if (i < uniqueTickers.length - 1) {\n        await this.sleep(this.RATE_LIMIT_DELAY);\n      }\n    }\n\n    const duration = Date.now() - startTime;\n\n    // 5. Emit WebSocket event: batch update completed\n    this.webSocketGateway.emitBatchUpdateCompleted({\n      portfolioId,\n      totalAssets: uniqueTickers.length,\n      successCount,\n      failedCount,\n      duration,\n    });\n\n    this.logger.log(\n      `[UPDATE-PORTFOLIO] Ô£à Completed portfolio ${portfolioId}: ${successCount}/${uniqueTickers.length} successful in ${duration}ms`,\n    );\n\n    return {\n      totalAssets: uniqueTickers.length,\n      successCount,\n      failedCount,\n      results,\n      duration,\n    };\n  }\n\n  /**\n   * M├ëTODO 3: Atualizar m├║ltiplos ativos espec├¡ficos\n   * Usado para atualiza├º├Áes em lote de ativos selecionados\n   */\n  async updateMultipleAssets(\n    tickers: string[],\n    userId?: string,\n    triggeredBy: UpdateTrigger = UpdateTrigger.MANUAL,\n  ): Promise<BatchUpdateResult> {\n    this.logger.log(`[UPDATE-MULTIPLE] Starting batch update for ${tickers.length} assets`);\n    const startTime = Date.now();\n\n    if (tickers.length === 0) {\n      throw new BadRequestException('No tickers provided');\n    }\n\n    // 1. Validate all tickers exist\n    const assets = await this.assetRepository.find({\n      where: { ticker: In(tickers) },\n    });\n\n    const foundTickers = assets.map((a) => a.ticker);\n    const notFoundTickers = tickers.filter((t) => !foundTickers.includes(t));\n\n    if (notFoundTickers.length > 0) {\n      this.logger.warn(`[UPDATE-MULTIPLE] Tickers not found: ${notFoundTickers.join(', ')}`);\n    }\n\n    // 2. Emit WebSocket event: batch update started\n    this.webSocketGateway.emitBatchUpdateStarted({\n      totalAssets: foundTickers.length,\n      tickers: foundTickers,\n    });\n\n    // 3. Update all assets with rate limiting\n    const results: UpdateResult[] = [];\n    let successCount = 0;\n    let failedCount = 0;\n\n    for (let i = 0; i < foundTickers.length; i++) {\n      const ticker = foundTickers[i];\n\n      // Emit progress\n      this.webSocketGateway.emitBatchUpdateProgress({\n        current: i + 1,\n        total: foundTickers.length,\n        currentTicker: ticker,\n      });\n\n      // Update asset\n      const result = await this.updateSingleAsset(ticker, userId, triggeredBy);\n      results.push(result);\n\n      if (result.success) {\n        successCount++;\n      } else {\n        failedCount++;\n      }\n\n      // Rate limiting: wait between requests (except last one)\n      if (i < foundTickers.length - 1) {\n        await this.sleep(this.RATE_LIMIT_DELAY);\n      }\n    }\n\n    const duration = Date.now() - startTime;\n\n    // 4. Emit WebSocket event: batch update completed\n    this.webSocketGateway.emitBatchUpdateCompleted({\n      totalAssets: foundTickers.length,\n      successCount,\n      failedCount,\n      duration,\n    });\n\n    this.logger.log(\n      `[UPDATE-MULTIPLE] Ô£à Completed batch: ${successCount}/${foundTickers.length} successful in ${duration}ms`,\n    );\n\n    return {\n      totalAssets: foundTickers.length,\n      successCount,\n      failedCount,\n      results,\n      duration,\n    };\n  }\n\n  /**\n   * M├ëTODO 4: Buscar ativos desatualizados\n   * Usado para identificar quais ativos precisam de atualiza├º├úo\n   */\n  async getOutdatedAssets(portfolioId?: string): Promise<Asset[]> {\n    this.logger.log(`[GET-OUTDATED] Finding outdated assets (portfolio: ${portfolioId || 'all'})`);\n\n    // Calculate outdated threshold\n    const outdatedDate = new Date();\n    outdatedDate.setDate(outdatedDate.getDate() - this.OUTDATED_THRESHOLD_DAYS);\n\n    let query = this.assetRepository\n      .createQueryBuilder('asset')\n      .where('asset.isActive = :isActive', { isActive: true })\n      .andWhere('asset.autoUpdateEnabled = :autoUpdateEnabled', { autoUpdateEnabled: true })\n      .andWhere(\n        '(asset.lastUpdated IS NULL OR asset.lastUpdated < :outdatedDate OR asset.lastUpdateStatus = :failedStatus)',\n        { outdatedDate, failedStatus: 'failed' },\n      );\n\n    // If portfolioId provided, filter by portfolio assets\n    if (portfolioId) {\n      query = query\n        .innerJoin('portfolio_positions', 'position', 'position.assetId = asset.id')\n        .andWhere('position.portfolioId = :portfolioId', { portfolioId });\n    }\n\n    const outdatedAssets = await query.getMany();\n\n    this.logger.log(`[GET-OUTDATED] Found ${outdatedAssets.length} outdated assets`);\n\n    return outdatedAssets;\n  }\n\n  /**\n   * M├ëTODO 5: Atualizar ativos por setor\n   * Usado para atualiza├º├Áes tem├íticas (ex: atualizar todos bancos)\n   */\n  async updateAssetsBySector(sector: string, userId?: string): Promise<BatchUpdateResult> {\n    this.logger.log(`[UPDATE-SECTOR] Starting update for sector: ${sector}`);\n    const startTime = Date.now();\n\n    // 1. Find all assets in sector\n    const assets = await this.assetRepository.find({\n      where: {\n        sector,\n        isActive: true,\n        autoUpdateEnabled: true,\n      },\n    });\n\n    if (assets.length === 0) {\n      throw new NotFoundException(`No active assets found for sector: ${sector}`);\n    }\n\n    const tickers = assets.map((a) => a.ticker);\n    this.logger.log(`[UPDATE-SECTOR] Found ${tickers.length} assets in sector ${sector}`);\n\n    // 2. Update all assets using updateMultipleAssets\n    return this.updateMultipleAssets(tickers, userId, UpdateTrigger.BATCH);\n  }\n\n  /**\n   * M├ëTODO 6: Processar retry de ativos com falha\n   * Usado pelo cron job para reprocessar ativos que falharam\n   */\n  async retryFailedAssets(): Promise<BatchUpdateResult> {\n    this.logger.log(`[RETRY-FAILED] Starting retry for failed assets`);\n    const startTime = Date.now();\n\n    // 1. Find assets with failed status that haven't reached max retry count\n    const failedAssets = await this.assetRepository.find({\n      where: {\n        lastUpdateStatus: 'failed',\n        updateRetryCount: LessThan(this.MAX_RETRY_COUNT),\n        autoUpdateEnabled: true,\n        isActive: true,\n      },\n    });\n\n    if (failedAssets.length === 0) {\n      this.logger.log(`[RETRY-FAILED] No failed assets to retry`);\n      return {\n        totalAssets: 0,\n        successCount: 0,\n        failedCount: 0,\n        results: [],\n        duration: Date.now() - startTime,\n      };\n    }\n\n    const tickers = failedAssets.map((a) => a.ticker);\n    this.logger.log(`[RETRY-FAILED] Found ${tickers.length} failed assets to retry`);\n\n    // 2. Update all assets using updateMultipleAssets\n    return this.updateMultipleAssets(tickers, undefined, UpdateTrigger.RETRY);\n  }\n\n  /**\n   * M├ëTODO AUXILIAR: Salvar dados fundamentalistas\n   */\n  private async saveFundamentalData(asset: Asset, scrapedResult: any): Promise<FundamentalData> {\n    const data = scrapedResult.data;\n\n    const fundamentalData = this.fundamentalDataRepository.create({\n      assetId: asset.id,\n      referenceDate: new Date(),\n\n      // Valuation\n      pl: data.pl || data.pe || null,\n      pvp: data.pvp || data.pb || null,\n      psr: data.psr || null,\n      pAtivos: data.pAtivos || data.pa || null,\n      pCapitalGiro: data.pCapitalGiro || data.pcg || null,\n      pEbit: data.pEbit || null,\n      evEbit: data.evEbit || null,\n      evEbitda: data.evEbitda || null,\n      pegRatio: data.pegRatio || null,\n\n      // Profitability\n      roe: data.roe || null,\n      roa: data.roa || null,\n      roic: data.roic || null,\n      margemBruta: data.margemBruta || null,\n      margemEbit: data.margemEbit || null,\n      margemEbitda: data.margemEbitda || null,\n      margemLiquida: data.margemLiquida || null,\n      giroAtivos: data.giroAtivos || null,\n\n      // Debt\n      dividaBruta: data.dividaBruta || null,\n      dividaLiquida: data.dividaLiquida || null,\n      dividaLiquidaEbitda: data.dividaLiquidaEbitda || data.dividaEbitda || null,\n      dividaLiquidaEbit: data.dividaLiquidaEbit || null,\n      dividaLiquidaPatrimonio: data.dividaLiquidaPatrimonio || data.dividaPatrimonio || null,\n      patrimonioLiquidoAtivos: data.patrimonioLiquidoAtivos || null,\n      passivosAtivos: data.passivosAtivos || null,\n\n      // Growth\n      cagrReceitas5anos: data.cagrReceitas5anos || data.cagr5Anos || null,\n      cagrLucros5anos: data.cagrLucros5anos || null,\n\n      // Dividends\n      dividendYield: data.dividendYield || data.dy || null,\n      payout: data.payout || null,\n\n      // Financial Statement Data\n      receitaLiquida: data.receitaLiquida || null,\n      ebit: data.ebit || null,\n      ebitda: data.ebitda || null,\n      lucroLiquido: data.lucroLiquido || null,\n      patrimonioLiquido: data.patrimonioLiquido || null,\n      ativoTotal: data.ativoTotal || null,\n      disponibilidades: data.disponibilidades || null,\n\n      // Metadata\n      metadata: {\n        sources: scrapedResult.sources,\n        sourcesCount: scrapedResult.sourcesCount,\n        confidence: scrapedResult.confidence,\n        discrepancies: scrapedResult.discrepancies,\n        rawData: data,\n      },\n    });\n\n    return this.fundamentalDataRepository.save(fundamentalData);\n  }\n\n  /**\n   * M├ëTODO AUXILIAR: Sleep para rate limiting\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\assets\\assets.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\assets\\assets.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\assets\\assets.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AssetType' is defined but never used.","line":4,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'previousClose' is assigned a value but never used.","line":141,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":141,"endColumn":24}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, NotFoundException, Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Asset, AssetType, AssetPrice, FundamentalData, PriceSource } from '@database/entities';\nimport { ScrapersService } from '../../scrapers/scrapers.service';\nimport { BrapiScraper } from '../../scrapers/fundamental/brapi.scraper';\nimport { HistoricalPricesQueryDto, PriceRange } from './dto/historical-prices-query.dto';\n\n@Injectable()\nexport class AssetsService {\n  private readonly logger = new Logger(AssetsService.name);\n\n  constructor(\n    @InjectRepository(Asset)\n    private assetRepository: Repository<Asset>,\n    @InjectRepository(AssetPrice)\n    private assetPriceRepository: Repository<AssetPrice>,\n    @InjectRepository(FundamentalData)\n    private fundamentalDataRepository: Repository<FundamentalData>,\n    private scrapersService: ScrapersService,\n    private brapiScraper: BrapiScraper,\n  ) {}\n\n  async findAll(type?: string) {\n    // Build optimized query with LEFT JOIN to get latest 2 prices per asset\n    const qb = this.assetRepository\n      .createQueryBuilder('asset')\n      .leftJoinAndSelect(\n        'asset_prices',\n        'price1',\n        `price1.asset_id = asset.id AND price1.date = (\n          SELECT MAX(p.date)\n          FROM asset_prices p\n          WHERE p.asset_id = asset.id\n        )`,\n      )\n      .leftJoinAndSelect(\n        'asset_prices',\n        'price2',\n        `price2.asset_id = asset.id AND price2.date = (\n          SELECT MAX(p.date)\n          FROM asset_prices p\n          WHERE p.asset_id = asset.id\n            AND p.date < (\n              SELECT MAX(p2.date)\n              FROM asset_prices p2\n              WHERE p2.asset_id = asset.id\n            )\n        )`,\n      )\n      .addSelect('price1.change', 'price1_change')\n      .addSelect('price1.change_percent', 'price1_change_percent')\n      .orderBy('asset.ticker', 'ASC');\n\n    if (type) {\n      qb.where('asset.type = :type', { type });\n    }\n\n    const assets = await qb.getRawAndEntities();\n\n    // Process results to get enriched data from database\n    const enrichedAssets = assets.entities.map((asset, index) => {\n      const rawData = assets.raw[index];\n\n      const latestClose = rawData?.price1_close;\n\n      if (!latestClose) {\n        return {\n          ...asset,\n          price: null,\n          change: null,\n          changePercent: null,\n          volume: null,\n          marketCap: null,\n        };\n      }\n\n      const price = Number(latestClose);\n      // Use change and changePercent from database (collected from BRAPI)\n      const change = rawData?.price1_change ? Number(rawData.price1_change) : null;\n      const changePercent = rawData?.price1_change_percent\n        ? Number(rawData.price1_change_percent)\n        : null;\n\n      return {\n        ...asset,\n        price,\n        change,\n        changePercent,\n        volume: rawData?.price1_volume ? Number(rawData.price1_volume) : null,\n        marketCap: rawData?.price1_market_cap ? Number(rawData.price1_market_cap) : null,\n        currentPrice: {\n          date: rawData?.price1_date,\n          close: price,\n          collectedAt: rawData?.price1_collected_at,\n        },\n      };\n    });\n\n    return enrichedAssets;\n  }\n\n  async findByTicker(ticker: string) {\n    // Optimized query with LEFT JOIN to get latest 2 prices\n    const result = await this.assetRepository\n      .createQueryBuilder('asset')\n      .leftJoinAndSelect(\n        'asset_prices',\n        'price1',\n        `price1.asset_id = asset.id AND price1.date = (\n          SELECT MAX(p.date)\n          FROM asset_prices p\n          WHERE p.asset_id = asset.id\n        )`,\n      )\n      .leftJoinAndSelect(\n        'asset_prices',\n        'price2',\n        `price2.asset_id = asset.id AND price2.date = (\n          SELECT MAX(p.date)\n          FROM asset_prices p\n          WHERE p.asset_id = asset.id\n            AND p.date < (\n              SELECT MAX(p2.date)\n              FROM asset_prices p2\n              WHERE p2.asset_id = asset.id\n            )\n        )`,\n      )\n      .where('UPPER(asset.ticker) = :ticker', { ticker: ticker.toUpperCase() })\n      .getRawAndEntities();\n\n    if (!result.entities.length) {\n      throw new NotFoundException(`Asset ${ticker} not found`);\n    }\n\n    const asset = result.entities[0];\n    const rawData = result.raw[0];\n\n    const latestClose = rawData?.price1_close;\n    const previousClose = rawData?.price2_close;\n\n    if (!latestClose) {\n      return {\n        ...asset,\n        price: null,\n        change: null,\n        changePercent: null,\n        volume: null,\n        marketCap: null,\n      };\n    }\n\n    const price = Number(latestClose);\n    // Use change and changePercent from database (collected from BRAPI)\n    const change = rawData?.price1_change ? Number(rawData.price1_change) : null;\n    const changePercent = rawData?.price1_change_percent\n      ? Number(rawData.price1_change_percent)\n      : null;\n\n    return {\n      ...asset,\n      price,\n      change,\n      changePercent,\n      volume: rawData?.price1_volume ? Number(rawData.price1_volume) : null,\n      marketCap: rawData?.price1_market_cap ? Number(rawData.price1_market_cap) : null,\n    };\n  }\n\n  async getPriceHistory(ticker: string, query: HistoricalPricesQueryDto) {\n    const asset = await this.findByTicker(ticker);\n\n    // 1. Determine date range\n    let { startDate, endDate, range } = query;\n\n    // If range provided, convert to startDate/endDate\n    if (range && !startDate) {\n      startDate = this.rangeToStartDate(range);\n      endDate = endDate || new Date().toISOString().split('T')[0];\n    }\n\n    // Default to 1 year if no params provided\n    if (!startDate && !endDate && !range) {\n      range = PriceRange.ONE_YEAR;\n      startDate = this.rangeToStartDate(range);\n      endDate = new Date().toISOString().split('T')[0];\n    }\n\n    // 2. Query database for existing prices\n    const queryBuilder = this.assetPriceRepository\n      .createQueryBuilder('price')\n      .where('price.assetId = :assetId', { assetId: asset.id })\n      .orderBy('price.date', 'ASC'); // ASC for chronological order\n\n    if (startDate) {\n      queryBuilder.andWhere('price.date >= :startDate', { startDate });\n    }\n\n    if (endDate) {\n      queryBuilder.andWhere('price.date <= :endDate', { endDate });\n    }\n\n    const prices = await queryBuilder.getMany();\n\n    // 3. Check if we need to fetch fresh data from BRAPI\n    const shouldFetch = this.shouldRefetchData(prices, range || '1y');\n\n    if (shouldFetch) {\n      this.logger.log(`Fetching fresh data from BRAPI for ${ticker} (range: ${range || 'custom'})`);\n      await this.syncAsset(ticker, range || '1y');\n\n      // Re-query database after sync\n      return queryBuilder.getMany();\n    }\n\n    this.logger.log(`Returning ${prices.length} cached prices for ${ticker}`);\n    return prices;\n  }\n\n  /**\n   * Convert BRAPI range to start date\n   */\n  private rangeToStartDate(range: string): string {\n    const now = new Date();\n    const daysMap: Record<string, number> = {\n      '1d': 1,\n      '5d': 5,\n      '1mo': 30,\n      '3mo': 90,\n      '6mo': 180,\n      '1y': 365,\n      '2y': 730,\n      '5y': 1825,\n      '10y': 3650,\n      ytd: this.getYTDDays(),\n      max: 7300, // ~20 years\n    };\n\n    const days = daysMap[range] || 365;\n    const startDate = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);\n    return startDate.toISOString().split('T')[0];\n  }\n\n  /**\n   * Calculate days since start of year (for YTD range)\n   */\n  private getYTDDays(): number {\n    const now = new Date();\n    const startOfYear = new Date(now.getFullYear(), 0, 1);\n    return Math.floor((now.getTime() - startOfYear.getTime()) / (24 * 60 * 60 * 1000));\n  }\n\n  /**\n   * Determine if we should refetch data from BRAPI\n   * Based on data freshness and completeness\n   */\n  private shouldRefetchData(prices: AssetPrice[], range: string): boolean {\n    // If no data exists, definitely fetch\n    if (!prices || prices.length === 0) {\n      return true;\n    }\n\n    // Check data freshness - if latest data is > 24h old, fetch\n    const latestPrice = prices[prices.length - 1]; // Last element (most recent date due to ASC order)\n    const latestDate = new Date(latestPrice.date);\n    const now = new Date();\n    const hoursSinceLatest = (now.getTime() - latestDate.getTime()) / (1000 * 60 * 60);\n\n    if (hoursSinceLatest > 24) {\n      this.logger.log(`Data is stale (${hoursSinceLatest.toFixed(1)}h old), refetching...`);\n      return true;\n    }\n\n    // Check data completeness - if we have significantly less data than expected, fetch\n    const expectedDays = this.getExpectedDays(range);\n    const actualDays = prices.length;\n\n    if (actualDays < expectedDays * 0.5) {\n      this.logger.log(`Data incomplete (${actualDays}/${expectedDays} expected), refetching...`);\n      return true;\n    }\n\n    // Data is fresh and complete, use cache\n    return false;\n  }\n\n  /**\n   * Get expected number of trading days for a given range\n   */\n  private getExpectedDays(range: string): number {\n    const daysMap: Record<string, number> = {\n      '1d': 1,\n      '5d': 5,\n      '1mo': 20, // ~20 trading days\n      '3mo': 60,\n      '6mo': 120,\n      '1y': 250, // ~250 trading days\n      '2y': 500,\n      '5y': 1250,\n      '10y': 2500,\n      ytd: Math.floor(this.getYTDDays() * 0.7), // ~70% are trading days\n      max: 5000,\n    };\n\n    return daysMap[range] || 250;\n  }\n\n  async syncAsset(ticker: string, range: string = '1y') {\n    this.logger.log(`Starting sync for ${ticker} (range: ${range})`);\n\n    try {\n      // 1. Find asset in database\n      const asset = await this.assetRepository.findOne({\n        where: { ticker: ticker.toUpperCase() },\n      });\n\n      if (!asset) {\n        throw new NotFoundException(`Asset ${ticker} not found`);\n      }\n\n      // 2. Fetch data from BRAPI scraper (includes price + historical data)\n      const result = await this.brapiScraper.scrape(ticker, range); // Get data for specified range\n\n      if (!result.success || !result.data) {\n        this.logger.warn(`Failed to fetch data for ${ticker}: ${result.error || 'unknown error'}`);\n        return {\n          message: `Failed to fetch data for ${ticker}`,\n          ticker,\n          status: 'failed',\n          error: result.error,\n        };\n      }\n\n      // 3. Extract price data from BRAPI\n      const brapiData = result.data;\n      this.logger.log(\n        `BrapiData for ${ticker}: price=${brapiData.price}, volume=${brapiData.volume}, change=${brapiData.change}, changePercent=${brapiData.changePercent}`,\n      );\n\n      // 4. Save current day price\n      if (brapiData.price && brapiData.volume !== null && brapiData.volume !== undefined) {\n        this.logger.log(\n          `Preparing to save price for ${ticker}. Change: ${brapiData.change}, ChangePercent: ${brapiData.changePercent}`,\n        );\n\n        const today = new Date();\n        today.setHours(0, 0, 0, 0);\n\n        // Check if price already exists for today\n        const existingPrice = await this.assetPriceRepository.findOne({\n          where: {\n            assetId: asset.id,\n            date: today,\n          },\n        });\n\n        const collectedAt = new Date(); // Timestamp da coleta\n\n        this.logger.log(`Price exists for ${ticker}? ${!!existingPrice}`);\n\n        if (!existingPrice) {\n          const priceData = this.assetPriceRepository.create({\n            asset,\n            assetId: asset.id,\n            date: today,\n            open: brapiData.open || brapiData.price,\n            high: brapiData.high || brapiData.price,\n            low: brapiData.low || brapiData.price,\n            close: brapiData.price,\n            volume: brapiData.volume,\n            adjustedClose: brapiData.price,\n            marketCap: brapiData.marketCap,\n            change: brapiData.change,\n            changePercent: brapiData.changePercent,\n            source: PriceSource.BRAPI,\n            collectedAt, // Registra quando foi coletado da API\n          });\n\n          await this.assetPriceRepository.save(priceData);\n          this.logger.log(\n            `Ô£ô Saved price for ${ticker}: R$ ${brapiData.price.toFixed(2)} (collected at ${collectedAt.toISOString()})`,\n          );\n        } else {\n          // Update existing price with latest data\n          existingPrice.open = brapiData.open || brapiData.price;\n          existingPrice.high = brapiData.high || brapiData.price;\n          existingPrice.low = brapiData.low || brapiData.price;\n          existingPrice.close = brapiData.price;\n          existingPrice.volume = brapiData.volume;\n          existingPrice.adjustedClose = brapiData.price;\n          existingPrice.marketCap = brapiData.marketCap;\n          existingPrice.change = brapiData.change;\n          existingPrice.changePercent = brapiData.changePercent;\n          existingPrice.collectedAt = collectedAt;\n\n          await this.assetPriceRepository.save(existingPrice);\n          this.logger.log(\n            `Ô£ô Updated price for ${ticker}: R$ ${brapiData.price.toFixed(2)} (collected at ${collectedAt.toISOString()})`,\n          );\n        }\n      }\n\n      // 5. Save historical prices if available\n      if (brapiData.historicalPrices && brapiData.historicalPrices.length > 0) {\n        let savedCount = 0;\n        const collectedAt = new Date(); // Mesmo timestamp para todos os hist├│ricos\n\n        for (const histPrice of brapiData.historicalPrices) {\n          // Save all historical data from range\n          const priceDate = new Date(histPrice.date);\n          priceDate.setHours(0, 0, 0, 0);\n\n          const existing = await this.assetPriceRepository.findOne({\n            where: {\n              assetId: asset.id,\n              date: priceDate,\n            },\n          });\n\n          if (!existing) {\n            const historicalData = this.assetPriceRepository.create({\n              asset,\n              assetId: asset.id,\n              date: priceDate,\n              open: histPrice.open,\n              high: histPrice.high,\n              low: histPrice.low,\n              close: histPrice.close,\n              volume: histPrice.volume,\n              adjustedClose: histPrice.adjustedClose,\n              source: PriceSource.BRAPI,\n              collectedAt, // Registra quando foi coletado\n            });\n\n            await this.assetPriceRepository.save(historicalData);\n            savedCount++;\n          }\n        }\n\n        if (savedCount > 0) {\n          this.logger.log(`Ô£ô Saved ${savedCount} historical prices for ${ticker}`);\n        }\n      }\n\n      return {\n        message: `Asset ${ticker} synced successfully`,\n        ticker,\n        status: 'success',\n        currentPrice: brapiData.price,\n        change: brapiData.change,\n        changePercent: brapiData.changePercent,\n        source: 'brapi',\n      };\n    } catch (error) {\n      this.logger.error(`Failed to sync ${ticker}: ${error.message}`);\n\n      if (error instanceof NotFoundException) {\n        throw error;\n      }\n\n      return {\n        message: `Failed to sync ${ticker}`,\n        ticker,\n        status: 'error',\n        error: error.message,\n      };\n    }\n  }\n\n  async syncAllAssets(range: string = '1y') {\n    this.logger.log(`Starting sync for all assets (range: ${range})`);\n\n    try {\n      // Get all assets from database\n      const assets = await this.assetRepository.find();\n      this.logger.log(`Found ${assets.length} assets to sync`);\n\n      const results = {\n        total: assets.length,\n        success: 0,\n        failed: 0,\n        range,\n        startedAt: new Date(),\n        completedAt: null as Date | null,\n        assets: [] as any[],\n      };\n\n      // Sync each asset (in parallel with limit)\n      const batchSize = 5; // Process 5 assets at a time to avoid overload\n      for (let i = 0; i < assets.length; i += batchSize) {\n        const batch = assets.slice(i, i + batchSize);\n\n        await Promise.all(\n          batch.map(async (asset) => {\n            try {\n              this.logger.log(`Syncing ${asset.ticker} (range: ${range})...`);\n              await this.syncAsset(asset.ticker, range);\n              results.success++;\n              results.assets.push({\n                ticker: asset.ticker,\n                status: 'success',\n              });\n            } catch (error) {\n              this.logger.error(`Failed to sync ${asset.ticker}: ${error.message}`);\n              results.failed++;\n              results.assets.push({\n                ticker: asset.ticker,\n                status: 'failed',\n                error: error.message,\n              });\n            }\n          }),\n        );\n      }\n\n      results.completedAt = new Date();\n      this.logger.log(`Sync completed: ${results.success} success, ${results.failed} failed`);\n\n      return results;\n    } catch (error) {\n      this.logger.error(`Error syncing all assets: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  async create(assetData: Partial<Asset>) {\n    const asset = this.assetRepository.create(assetData);\n    return this.assetRepository.save(asset);\n  }\n\n  async update(ticker: string, assetData: Partial<Asset>) {\n    const asset = await this.findByTicker(ticker);\n    Object.assign(asset, assetData);\n    return this.assetRepository.save(asset);\n  }\n\n  /**\n   * Populate fundamental data for an asset using scrapers\n   * This method scrapes data from multiple sources, validates it, and saves to database\n   */\n  async populateFundamentalData(\n    ticker: string,\n  ): Promise<{ success: boolean; message: string; data?: any }> {\n    this.logger.log(`Starting fundamental data population for ${ticker}`);\n\n    try {\n      // 1. Buscar asset no banco de dados\n      const asset = await this.assetRepository.findOne({\n        where: { ticker: ticker.toUpperCase() },\n      });\n\n      if (!asset) {\n        throw new NotFoundException(`Asset ${ticker} not found in database`);\n      }\n\n      this.logger.log(`Asset found: ${asset.name} (${asset.ticker})`);\n\n      // 2. Executar scrapers de m├║ltiplas fontes\n      this.logger.log(`Executing scrapers for ${ticker} from multiple sources...`);\n      const scrapedResult = await this.scrapersService.scrapeFundamentalData(ticker);\n\n      this.logger.log(\n        `Scraping completed: ${scrapedResult.sourcesCount} sources, confidence: ${scrapedResult.confidence}`,\n      );\n\n      // 3. Validar resultado (m├¡nimo 3 fontes, confidence >= 0.7)\n      if (!scrapedResult.isValid) {\n        this.logger.warn(\n          `Insufficient data quality for ${ticker}: ` +\n            `${scrapedResult.sourcesCount} sources (min 3 required), ` +\n            `confidence: ${scrapedResult.confidence} (min 0.7 required)`,\n        );\n        return {\n          success: false,\n          message: `Insufficient data quality: ${scrapedResult.sourcesCount} sources, confidence ${scrapedResult.confidence.toFixed(2)}`,\n          data: {\n            sources: scrapedResult.sources,\n            sourcesCount: scrapedResult.sourcesCount,\n            confidence: scrapedResult.confidence,\n            discrepancies: scrapedResult.discrepancies,\n          },\n        };\n      }\n\n      // 4. Mapear dados scraped para estrutura da entidade FundamentalData\n      const mappedData = this.mapScraperDataToEntity(scrapedResult.data);\n      this.logger.log(`Data mapped successfully with ${Object.keys(mappedData).length} fields`);\n\n      // 5. Salvar dados fundamentalistas no banco\n      const fundamentalData = this.fundamentalDataRepository.create({\n        asset,\n        assetId: asset.id,\n        referenceDate: new Date(),\n        ...mappedData,\n      });\n\n      const saved = await this.fundamentalDataRepository.save(fundamentalData);\n      this.logger.log(`Fundamental data saved successfully with ID: ${saved.id}`);\n\n      return {\n        success: true,\n        message: `Data populated successfully from ${scrapedResult.sourcesCount} sources with ${scrapedResult.confidence.toFixed(2)} confidence`,\n        data: {\n          ticker,\n          assetName: asset.name,\n          sources: scrapedResult.sources,\n          sourcesCount: scrapedResult.sourcesCount,\n          confidence: scrapedResult.confidence,\n          dataId: saved.id,\n          referenceDate: saved.referenceDate,\n          indicators: {\n            valuation: {\n              pl: mappedData.pl,\n              pvp: mappedData.pvp,\n              psr: mappedData.psr,\n              evEbitda: mappedData.evEbitda,\n            },\n            profitability: {\n              roe: mappedData.roe,\n              roa: mappedData.roa,\n              roic: mappedData.roic,\n              margemLiquida: mappedData.margemLiquida,\n            },\n            dividends: {\n              dividendYield: mappedData.dividendYield,\n              payout: mappedData.payout,\n            },\n          },\n        },\n      };\n    } catch (error) {\n      this.logger.error(`Error populating data for ${ticker}: ${error.message}`, error.stack);\n\n      if (error instanceof NotFoundException) {\n        return {\n          success: false,\n          message: error.message,\n        };\n      }\n\n      return {\n        success: false,\n        message: `Unexpected error: ${error.message}`,\n      };\n    }\n  }\n\n  /**\n   * Map scraper data to FundamentalData entity fields\n   * Handles field name variations and provides fallbacks\n   */\n  private mapScraperDataToEntity(scrapedData: any): Partial<FundamentalData> {\n    return {\n      // Valuation Indicators\n      pl: scrapedData.pl || scrapedData.pe || null,\n      pvp: scrapedData.pvp || scrapedData.pb || null,\n      psr: scrapedData.psr || null,\n      pAtivos: scrapedData.pAtivos || scrapedData.pAssets || null,\n      pCapitalGiro: scrapedData.pCapitalGiro || scrapedData.pWorkingCapital || null,\n      pEbit: scrapedData.pEbit || scrapedData.priceToEbit || null,\n      evEbit: scrapedData.evEbit || scrapedData.enterpriseValueToEbit || null,\n      evEbitda: scrapedData.evEbitda || scrapedData.enterpriseValueToEbitda || null,\n      pegRatio: scrapedData.pegRatio || scrapedData.peg || null,\n\n      // Debt Indicators\n      dividaLiquidaPatrimonio:\n        scrapedData.dividaLiquidaPatrimonio || scrapedData.netDebtToEquity || null,\n      dividaLiquidaEbitda: scrapedData.dividaLiquidaEbitda || scrapedData.netDebtToEbitda || null,\n      dividaLiquidaEbit: scrapedData.dividaLiquidaEbit || scrapedData.netDebtToEbit || null,\n      patrimonioLiquidoAtivos:\n        scrapedData.patrimonioLiquidoAtivos || scrapedData.equityToAssets || null,\n      passivosAtivos: scrapedData.passivosAtivos || scrapedData.liabilitiesToAssets || null,\n\n      // Efficiency Indicators\n      margemBruta: scrapedData.margemBruta || scrapedData.grossMargin || null,\n      margemEbit: scrapedData.margemEbit || scrapedData.ebitMargin || null,\n      margemEbitda: scrapedData.margemEbitda || scrapedData.ebitdaMargin || null,\n      margemLiquida: scrapedData.margemLiquida || scrapedData.netMargin || null,\n      roe: scrapedData.roe || scrapedData.returnOnEquity || null,\n      roa: scrapedData.roa || scrapedData.returnOnAssets || null,\n      roic: scrapedData.roic || scrapedData.returnOnInvestedCapital || null,\n      giroAtivos: scrapedData.giroAtivos || scrapedData.assetTurnover || null,\n\n      // Growth Indicators\n      cagrReceitas5anos: scrapedData.cagrReceitas5anos || scrapedData.revenueCagr5y || null,\n      cagrLucros5anos: scrapedData.cagrLucros5anos || scrapedData.earningsCagr5y || null,\n\n      // Dividend Indicators\n      dividendYield: scrapedData.dividendYield || scrapedData.dy || null,\n      payout: scrapedData.payout || scrapedData.payoutRatio || null,\n\n      // Financial Statement Data (in millions)\n      receitaLiquida:\n        scrapedData.receitaLiquida || scrapedData.revenue || scrapedData.netRevenue || null,\n      ebit: scrapedData.ebit || null,\n      ebitda: scrapedData.ebitda || null,\n      lucroLiquido:\n        scrapedData.lucroLiquido || scrapedData.netIncome || scrapedData.netProfit || null,\n      patrimonioLiquido:\n        scrapedData.patrimonioLiquido ||\n        scrapedData.equity ||\n        scrapedData.shareholderEquity ||\n        null,\n      ativoTotal: scrapedData.ativoTotal || scrapedData.totalAssets || null,\n      dividaBruta:\n        scrapedData.dividaBruta || scrapedData.grossDebt || scrapedData.totalDebt || null,\n      dividaLiquida: scrapedData.dividaLiquida || scrapedData.netDebt || null,\n      disponibilidades:\n        scrapedData.disponibilidades || scrapedData.cash || scrapedData.cashAndEquivalents || null,\n\n      // Store original data and metadata\n      metadata: {\n        originalData: scrapedData,\n        sources: scrapedData.sources || [],\n        scrapedAt: new Date().toISOString(),\n        confidence: scrapedData.confidence || null,\n        discrepancies: scrapedData.discrepancies || [],\n      },\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\assets\\dto\\historical-prices-query.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\assets\\dto\\update-asset.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\auth\\auth.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\auth\\auth.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\auth\\auth.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'password' is assigned a value but never used.","line":126,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":126,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { JwtService } from '@nestjs/jwt';\nimport * as bcrypt from 'bcrypt';\nimport { User } from '@database/entities';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    @InjectRepository(User)\n    private userRepository: Repository<User>,\n    private jwtService: JwtService,\n  ) {}\n\n  async register(registerDto: any) {\n    const { email, password, firstName, lastName } = registerDto;\n\n    // Check if user exists\n    const existingUser = await this.userRepository.findOne({ where: { email } });\n    if (existingUser) {\n      throw new UnauthorizedException('User already exists');\n    }\n\n    // Hash password\n    const hashedPassword = await bcrypt.hash(password, 10);\n\n    // Create user\n    const user = this.userRepository.create({\n      email,\n      password: hashedPassword,\n      firstName,\n      lastName,\n    });\n\n    await this.userRepository.save(user);\n\n    // Generate JWT\n    const token = this.generateToken(user);\n\n    return {\n      user: this.sanitizeUser(user),\n      token,\n    };\n  }\n\n  async login(loginDto: any) {\n    const { email, password } = loginDto;\n\n    // Find user\n    const user = await this.userRepository.findOne({ where: { email } });\n    if (!user || !user.password) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Verify password\n    const isPasswordValid = await bcrypt.compare(password, user.password);\n    if (!isPasswordValid) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Update last login\n    user.lastLogin = new Date();\n    await this.userRepository.save(user);\n\n    // Generate JWT\n    const token = this.generateToken(user);\n\n    return {\n      user: this.sanitizeUser(user),\n      token,\n    };\n  }\n\n  async googleLogin(profile: any) {\n    const { email, firstName, lastName, picture, googleId } = profile;\n\n    // Find or create user\n    let user = await this.userRepository.findOne({ where: { email } });\n\n    if (!user) {\n      user = this.userRepository.create({\n        email,\n        firstName,\n        lastName,\n        avatar: picture,\n        googleId,\n        isEmailVerified: true,\n      });\n      await this.userRepository.save(user);\n    } else {\n      // Update Google ID if not set\n      if (!user.googleId) {\n        user.googleId = googleId;\n        await this.userRepository.save(user);\n      }\n    }\n\n    // Update last login\n    user.lastLogin = new Date();\n    await this.userRepository.save(user);\n\n    // Generate JWT\n    const token = this.generateToken(user);\n\n    return {\n      user: this.sanitizeUser(user),\n      token,\n    };\n  }\n\n  async validateUser(userId: string): Promise<User> {\n    const user = await this.userRepository.findOne({ where: { id: userId } });\n    if (!user || !user.isActive) {\n      throw new UnauthorizedException('User not found or inactive');\n    }\n    return user;\n  }\n\n  private generateToken(user: User): string {\n    const payload = { sub: user.id, email: user.email };\n    return this.jwtService.sign(payload);\n  }\n\n  private sanitizeUser(user: User) {\n    const { password, ...sanitized } = user;\n    return sanitized;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\auth\\dto\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\auth\\dto\\login.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\auth\\dto\\register.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\auth\\guards\\google-auth.guard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\auth\\guards\\jwt-auth.guard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\auth\\strategies\\google.strategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\auth\\strategies\\jwt.strategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\data-sources\\data-sources.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\data-sources\\data-sources.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\data-sources\\data-sources.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\economic-indicators\\dto\\get-indicators.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsIn' is defined but never used.","line":2,"column":46,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":50}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ApiProperty } from '@nestjs/swagger';\nimport { IsOptional, IsString, IsDateString, IsIn } from 'class-validator';\n\n/**\n * DTO para consulta de indicadores econ├┤micos\n */\nexport class GetIndicatorsDto {\n  @ApiProperty({\n    description: 'Tipo de indicador (SELIC, IPCA, CDI, PIB, etc)',\n    required: false,\n    enum: ['SELIC', 'IPCA', 'CDI', 'PIB', 'IGPM', 'DI', 'POUPANCA', 'ALL'],\n    example: 'SELIC',\n  })\n  @IsOptional()\n  @IsString()\n  type?: string;\n\n  @ApiProperty({\n    description: 'Data inicial (formato: YYYY-MM-DD)',\n    required: false,\n    example: '2025-01-01',\n  })\n  @IsOptional()\n  @IsDateString()\n  startDate?: string;\n\n  @ApiProperty({\n    description: 'Data final (formato: YYYY-MM-DD)',\n    required: false,\n    example: '2025-11-21',\n  })\n  @IsOptional()\n  @IsDateString()\n  endDate?: string;\n\n  @ApiProperty({\n    description: 'Limite de registros retornados',\n    required: false,\n    default: 10,\n    example: 10,\n  })\n  @IsOptional()\n  limit?: number = 10;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\economic-indicators\\dto\\indicator-response.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\economic-indicators\\economic-indicators.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\economic-indicators\\economic-indicators.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\economic-indicators\\economic-indicators.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Between' is defined but never used.","line":3,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MoreThanOrEqual' is defined but never used.","line":3,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LessThanOrEqual' is defined but never used.","line":3,"column":48,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":63}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger, NotFoundException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, Between, MoreThanOrEqual, LessThanOrEqual } from 'typeorm';\nimport { CacheService } from '../../common/services/cache.service';\nimport { BrapiService } from '../../integrations/brapi/brapi.service';\nimport { EconomicIndicator } from '../../database/entities/economic-indicator.entity';\nimport { GetIndicatorsDto } from './dto/get-indicators.dto';\nimport {\n  IndicatorsListResponseDto,\n  IndicatorResponseDto,\n  LatestIndicatorResponseDto,\n} from './dto/indicator-response.dto';\n\nconst CACHE_TTL = {\n  LIST: 300, // 5 minutes\n  LATEST: 60, // 1 minute\n};\n\n/**\n * EconomicIndicatorsService - Servi├ºo de Indicadores Macroecon├┤micos\n *\n * Gerencia indicadores econ├┤micos brasileiros (SELIC, IPCA, CDI, PIB, etc)\n * com cache e sincroniza├º├úo autom├ítica via BRAPI.\n *\n * @created 2025-11-21 - FASE 2 (Backend Economic Indicators)\n */\n@Injectable()\nexport class EconomicIndicatorsService {\n  private readonly logger = new Logger(EconomicIndicatorsService.name);\n\n  constructor(\n    @InjectRepository(EconomicIndicator)\n    private readonly indicatorRepository: Repository<EconomicIndicator>,\n    private readonly cacheService: CacheService,\n    private readonly brapiService: BrapiService,\n  ) {}\n\n  /**\n   * Get all indicators with filters\n   * @param dto Query filters (type, startDate, endDate, limit)\n   * @returns IndicatorsListResponseDto\n   */\n  async getAll(dto: GetIndicatorsDto): Promise<IndicatorsListResponseDto> {\n    try {\n      const cacheKey = `indicators:list:${JSON.stringify(dto)}`;\n\n      // Try cache first\n      const cached = await this.cacheService.get<IndicatorsListResponseDto>(cacheKey);\n      if (cached) {\n        return cached;\n      }\n\n      // Build query\n      const query = this.indicatorRepository.createQueryBuilder('indicator');\n\n      // Filter by type (if not ALL)\n      if (dto.type && dto.type !== 'ALL') {\n        query.andWhere('indicator.indicatorType = :type', { type: dto.type });\n      }\n\n      // Filter by date range\n      if (dto.startDate && dto.endDate) {\n        query.andWhere('indicator.referenceDate BETWEEN :startDate AND :endDate', {\n          startDate: dto.startDate,\n          endDate: dto.endDate,\n        });\n      } else if (dto.startDate) {\n        query.andWhere('indicator.referenceDate >= :startDate', {\n          startDate: dto.startDate,\n        });\n      } else if (dto.endDate) {\n        query.andWhere('indicator.referenceDate <= :endDate', {\n          endDate: dto.endDate,\n        });\n      }\n\n      // Order by newest first\n      query.orderBy('indicator.referenceDate', 'DESC');\n\n      // Limit results\n      if (dto.limit) {\n        query.limit(dto.limit);\n      }\n\n      // Execute query\n      const [indicators, total] = await query.getManyAndCount();\n\n      const response: IndicatorsListResponseDto = {\n        indicators: indicators.map((i) => this.mapToResponseDto(i)),\n        total,\n        updatedAt: new Date(),\n      };\n\n      // Cache for 5 minutes\n      await this.cacheService.set(cacheKey, response, CACHE_TTL.LIST);\n\n      this.logger.log(`Fetched ${indicators.length} indicators (total: ${total})`);\n\n      return response;\n    } catch (error) {\n      this.logger.error(`getAll failed: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Get latest indicator by type (SELIC, IPCA, CDI, etc)\n   * @param type Indicator type\n   * @returns LatestIndicatorResponseDto\n   */\n  async getLatestByType(type: string): Promise<LatestIndicatorResponseDto> {\n    try {\n      const cacheKey = `indicators:latest:${type}`;\n\n      // Try cache first\n      const cached = await this.cacheService.get<LatestIndicatorResponseDto>(cacheKey);\n      if (cached) {\n        return cached;\n      }\n\n      // Fetch latest 2 records (current + previous)\n      const indicators = await this.indicatorRepository.find({\n        where: { indicatorType: type },\n        order: { referenceDate: 'DESC' },\n        take: 2,\n      });\n\n      if (indicators.length === 0) {\n        throw new NotFoundException(`No data found for indicator type: ${type}`);\n      }\n\n      const current = indicators[0];\n      const previous = indicators[1];\n\n      // Calculate change\n      const change = previous ? Number((current.value - previous.value).toFixed(4)) : undefined;\n\n      const response: LatestIndicatorResponseDto = {\n        type: current.indicatorType,\n        currentValue: Number(current.value),\n        previousValue: previous ? Number(previous.value) : undefined,\n        change,\n        referenceDate: current.referenceDate,\n        source: current.source || 'Unknown',\n        unit: current.metadata?.unit || '% a.a.',\n      };\n\n      // Cache for 1 minute\n      await this.cacheService.set(cacheKey, response, CACHE_TTL.LATEST);\n\n      this.logger.log(`Latest ${type}: ${response.currentValue} (change: ${change || 'N/A'})`);\n\n      return response;\n    } catch (error) {\n      this.logger.error(`getLatestByType failed: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Sync indicators from BRAPI (SELIC, IPCA, CDI)\n   * Uses upsert logic (insert or update based on indicatorType + referenceDate)\n   */\n  async syncFromBrapi(): Promise<void> {\n    try {\n      this.logger.log('Starting sync from Banco Central API...');\n\n      const syncResults = {\n        selic: false,\n        ipca: false,\n        cdi: false,\n      };\n\n      // 1. Sync SELIC\n      try {\n        const selicData = await this.brapiService.getSelic();\n        await this.upsertIndicator({\n          indicatorType: 'SELIC',\n          value: selicData.value,\n          referenceDate: selicData.date, // Already a Date from parseBCBDate()\n          source: 'BRAPI',\n          metadata: {\n            unit: '% a.a.',\n            period: 'annual',\n            description: 'Taxa b├ísica de juros (Banco Central)',\n          },\n        });\n        syncResults.selic = true;\n        this.logger.log(`SELIC synced: ${selicData.value}%`);\n      } catch (error) {\n        this.logger.error(`SELIC sync failed: ${error.message}`);\n      }\n\n      // 2. Sync IPCA\n      try {\n        const ipcaData = await this.brapiService.getInflation('brazil');\n        await this.upsertIndicator({\n          indicatorType: 'IPCA',\n          value: ipcaData.value,\n          referenceDate: ipcaData.date, // Already a Date from parseBCBDate()\n          source: 'BRAPI',\n          metadata: {\n            unit: '% a.a.',\n            period: 'annual',\n            description: '├ìndice de Pre├ºos ao Consumidor Amplo (IBGE)',\n          },\n        });\n        syncResults.ipca = true;\n        this.logger.log(`IPCA synced: ${ipcaData.value}%`);\n      } catch (error) {\n        this.logger.error(`IPCA sync failed: ${error.message}`);\n      }\n\n      // 3. Sync CDI\n      try {\n        const cdiData = await this.brapiService.getCDI();\n        await this.upsertIndicator({\n          indicatorType: 'CDI',\n          value: cdiData.value,\n          referenceDate: cdiData.date, // Already a Date from parseBCBDate()\n          source: 'BRAPI (calculated)',\n          metadata: {\n            unit: '% a.a.',\n            period: 'annual',\n            description: 'Certificado de Dep├│sito Interbanc├írio (calculado ~SELIC - 0.10%)',\n          },\n        });\n        syncResults.cdi = true;\n        this.logger.log(`CDI synced: ${cdiData.value}%`);\n      } catch (error) {\n        this.logger.error(`CDI sync failed: ${error.message}`);\n      }\n\n      // Clear cache after sync\n      await this.cacheService.del('indicators:*');\n\n      this.logger.log(`Sync completed: ${JSON.stringify(syncResults)}`);\n    } catch (error) {\n      this.logger.error(`syncFromBrapi failed: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Upsert indicator (insert or update based on unique constraint)\n   * Unique constraint: indicatorType + referenceDate\n   */\n  private async upsertIndicator(data: Partial<EconomicIndicator>): Promise<void> {\n    try {\n      const existing = await this.indicatorRepository.findOne({\n        where: {\n          indicatorType: data.indicatorType,\n          referenceDate: data.referenceDate,\n        },\n      });\n\n      if (existing) {\n        // Update existing\n        await this.indicatorRepository.update(existing.id, {\n          value: data.value,\n          source: data.source,\n          metadata: data.metadata,\n        });\n        this.logger.debug(`Updated ${data.indicatorType} for ${data.referenceDate}`);\n      } else {\n        // Insert new\n        await this.indicatorRepository.save(data);\n        this.logger.debug(`Inserted ${data.indicatorType} for ${data.referenceDate}`);\n      }\n    } catch (error) {\n      this.logger.error(`upsertIndicator failed: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Map EconomicIndicator entity to DTO\n   */\n  private mapToResponseDto(indicator: EconomicIndicator): IndicatorResponseDto {\n    return {\n      id: indicator.id,\n      indicatorType: indicator.indicatorType,\n      value: Number(indicator.value),\n      referenceDate: indicator.referenceDate,\n      source: indicator.source,\n      metadata: indicator.metadata,\n      createdAt: indicator.createdAt,\n      updatedAt: indicator.updatedAt,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\clients\\python-service.client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\dto\\get-prices.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsString' is defined but never used.","line":2,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":47}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ApiProperty } from '@nestjs/swagger';\nimport { IsOptional, IsInt, Min, Max, IsString, IsEnum } from 'class-validator';\nimport { Type } from 'class-transformer';\n\n/**\n * Candle Timeframe - Intervalo de agrega├º├úo dos candles\n * 1D = Daily (1 candle por dia - sem agrega├º├úo)\n * 1W = Weekly (1 candle por semana - agrega 5 dias ├║teis)\n * 1M = Monthly (1 candle por m├¬s - agrega ~21 dias ├║teis)\n */\nexport enum CandleTimeframe {\n  ONE_DAY = '1D',\n  ONE_WEEK = '1W',\n  ONE_MONTH = '1M',\n}\n\n/**\n * Viewing Range - Per├¡odo de dados a retornar\n * Quanto hist├│rico mostrar no gr├ífico\n */\nexport enum ViewingRange {\n  ONE_MONTH = '1mo',\n  THREE_MONTHS = '3mo',\n  SIX_MONTHS = '6mo',\n  ONE_YEAR = '1y',\n  TWO_YEARS = '2y',\n  FIVE_YEARS = '5y',\n  MAX = 'max',\n}\n\nexport class GetPricesDto {\n  @ApiProperty({\n    description: 'Candle timeframe (aggregation interval)',\n    enum: CandleTimeframe,\n    example: '1D',\n    default: '1D',\n    required: false,\n  })\n  @IsOptional()\n  @IsEnum(CandleTimeframe, {\n    message: 'Timeframe must be one of: 1D (Daily), 1W (Weekly), 1M (Monthly)',\n  })\n  timeframe?: CandleTimeframe = CandleTimeframe.ONE_DAY;\n\n  @ApiProperty({\n    description: 'Viewing range (how much historical data to return)',\n    enum: ViewingRange,\n    example: '1y',\n    default: '1y',\n    required: false,\n  })\n  @IsOptional()\n  @IsEnum(ViewingRange, {\n    message: 'Range must be one of: 1mo, 3mo, 6mo, 1y, 2y, 5y, max',\n  })\n  range?: ViewingRange = ViewingRange.ONE_YEAR;\n\n  @ApiProperty({\n    description: 'Number of days (alternative to range)',\n    example: 30,\n    required: false,\n  })\n  @IsOptional()\n  @IsInt()\n  @Min(1)\n  @Max(3650) // Max 10 years\n  @Type(() => Number)\n  days?: number;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\dto\\get-technical-data.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\dto\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\dto\\sync-bulk.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\dto\\sync-cotahist.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\dto\\sync-status-response.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\dto\\technical-data-response.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\interfaces\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\interfaces\\price-data.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\interfaces\\technical-indicators.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\market-data.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\market-data.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\market-data.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TechnicalIndicators' is defined but never used.","line":9,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'assetFilter' is defined but never used.","line":738,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":738,"endColumn":42}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger, InternalServerErrorException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, In } from 'typeorm';\nimport { CacheService } from '../../common/services/cache.service';\nimport { AssetsService } from '../assets/assets.service';\nimport { PriceRange } from '../assets/dto/historical-prices-query.dto';\nimport { PythonServiceClient } from './clients/python-service.client';\nimport { SyncGateway } from './sync.gateway'; // FASE 35\nimport { PriceDataPoint, TechnicalIndicators } from './interfaces';\nimport { TechnicalDataResponseDto } from './dto/technical-data-response.dto';\nimport { SyncCotahistResponseDto } from './dto/sync-cotahist.dto';\nimport {\n  Asset,\n  AssetPrice,\n  PriceSource,\n  SyncHistory,\n  SyncStatus,\n  SyncOperationType,\n} from '../../database/entities';\n\nconst CACHE_TTL = {\n  TECHNICAL_DATA: 300, // 5 minutes (seconds)\n};\n\nconst TIMEFRAME_TO_PRICE_RANGE: Record<string, PriceRange> = {\n  '1D': PriceRange.ONE_DAY,\n  '1MO': PriceRange.ONE_MONTH,\n  '3MO': PriceRange.THREE_MONTHS,\n  '6MO': PriceRange.SIX_MONTHS,\n  '1Y': PriceRange.ONE_YEAR,\n  '2Y': PriceRange.TWO_YEARS,\n  '5Y': PriceRange.FIVE_YEARS,\n  MAX: PriceRange.MAX,\n};\n\nconst MIN_DATA_POINTS_FOR_INDICATORS = 200;\n\n@Injectable()\nexport class MarketDataService {\n  private readonly logger = new Logger(MarketDataService.name);\n\n  constructor(\n    private readonly cacheService: CacheService,\n    private readonly assetsService: AssetsService,\n    private readonly pythonServiceClient: PythonServiceClient,\n    private readonly syncGateway: SyncGateway, // FASE 35\n    @InjectRepository(Asset)\n    private readonly assetRepository: Repository<Asset>,\n    @InjectRepository(AssetPrice)\n    private readonly assetPriceRepository: Repository<AssetPrice>,\n    @InjectRepository(SyncHistory)\n    private readonly syncHistoryRepository: Repository<SyncHistory>,\n  ) {}\n\n  /**\n   * Calculate date range based on viewing range\n   * @param range Viewing range (1mo, 3mo, 6mo, 1y, 2y, 5y, max)\n   * @returns Start and end dates\n   */\n  private calculateDateRange(range: string): { startDate: Date; endDate: Date } {\n    const endDate = new Date();\n    const startDate = new Date();\n\n    switch (range) {\n      case '1mo':\n        startDate.setMonth(endDate.getMonth() - 1);\n        break;\n      case '3mo':\n        startDate.setMonth(endDate.getMonth() - 3);\n        break;\n      case '6mo':\n        startDate.setMonth(endDate.getMonth() - 6);\n        break;\n      case '1y':\n        startDate.setFullYear(endDate.getFullYear() - 1);\n        break;\n      case '2y':\n        startDate.setFullYear(endDate.getFullYear() - 2);\n        break;\n      case '5y':\n        startDate.setFullYear(endDate.getFullYear() - 5);\n        break;\n      case 'max':\n        startDate.setFullYear(1986); // COTAHIST data starts in 1986\n        break;\n      default:\n        startDate.setFullYear(endDate.getFullYear() - 1);\n    }\n\n    return { startDate, endDate };\n  }\n\n  /**\n   * Get aggregated price data with candle timeframes\n   * FASE 35 - Implementa├º├úo de Candle Timeframes\n   *\n   * @param ticker Ticker symbol\n   * @param timeframe Candle timeframe (1D, 1W, 1M)\n   * @param range Viewing range (1mo, 3mo, 6mo, 1y, 2y, 5y, max)\n   * @returns Array of aggregated price data points\n   */\n  async getAggregatedPrices(\n    ticker: string,\n    timeframe: string = '1D',\n    range: string = '1y',\n  ): Promise<PriceDataPoint[]> {\n    try {\n      // Find asset\n      const asset = await this.assetRepository.findOne({ where: { ticker } });\n      if (!asset) {\n        throw new InternalServerErrorException(`Asset ${ticker} not found`);\n      }\n\n      const { startDate, endDate } = this.calculateDateRange(range);\n\n      // 1D: Return daily data without aggregation (raw data from DB)\n      if (timeframe === '1D') {\n        const prices = await this.assetPriceRepository\n          .createQueryBuilder('price')\n          .where('price.asset_id = :assetId', { assetId: asset.id })\n          .andWhere('price.date >= :startDate', { startDate })\n          .andWhere('price.date <= :endDate', { endDate })\n          .orderBy('price.date', 'ASC')\n          .getMany();\n\n        return prices.map((p) => ({\n          date: p.date instanceof Date ? p.date.toISOString().split('T')[0] : String(p.date),\n          open: parseFloat(String(p.open)),\n          high: parseFloat(String(p.high)),\n          low: parseFloat(String(p.low)),\n          close: parseFloat(String(p.close)),\n          volume: parseFloat(String(p.volume)),\n        }));\n      }\n\n      // 1W: Weekly aggregation\n      if (timeframe === '1W') {\n        const query = `\n          SELECT\n            DATE_TRUNC('week', date)::date as period_start,\n            (array_agg(open ORDER BY date ASC))[1] as open,\n            MAX(high) as high,\n            MIN(low) as low,\n            (array_agg(close ORDER BY date DESC))[1] as close,\n            SUM(volume) as volume,\n            COUNT(*) as trading_days\n          FROM asset_prices\n          WHERE asset_id = $1\n            AND date >= $2\n            AND date <= $3\n          GROUP BY DATE_TRUNC('week', date)\n          ORDER BY period_start ASC\n        `;\n\n        const result = await this.assetPriceRepository.query(query, [asset.id, startDate, endDate]);\n\n        return result.map((row: any) => ({\n          date:\n            row.period_start instanceof Date\n              ? row.period_start.toISOString().split('T')[0]\n              : String(row.period_start),\n          open: parseFloat(row.open),\n          high: parseFloat(row.high),\n          low: parseFloat(row.low),\n          close: parseFloat(row.close),\n          volume: parseInt(row.volume),\n        }));\n      }\n\n      // 1M: Monthly aggregation\n      if (timeframe === '1M') {\n        const query = `\n          SELECT\n            DATE_TRUNC('month', date)::date as period_start,\n            (array_agg(open ORDER BY date ASC))[1] as open,\n            MAX(high) as high,\n            MIN(low) as low,\n            (array_agg(close ORDER BY date DESC))[1] as close,\n            SUM(volume) as volume,\n            COUNT(*) as trading_days\n          FROM asset_prices\n          WHERE asset_id = $1\n            AND date >= $2\n            AND date <= $3\n          GROUP BY DATE_TRUNC('month', date)\n          ORDER BY period_start ASC\n        `;\n\n        const result = await this.assetPriceRepository.query(query, [asset.id, startDate, endDate]);\n\n        return result.map((row: any) => ({\n          date:\n            row.period_start instanceof Date\n              ? row.period_start.toISOString().split('T')[0]\n              : String(row.period_start),\n          open: parseFloat(row.open),\n          high: parseFloat(row.high),\n          low: parseFloat(row.low),\n          close: parseFloat(row.close),\n          volume: parseInt(row.volume),\n        }));\n      }\n\n      throw new InternalServerErrorException(`Timeframe ${timeframe} not yet implemented`);\n    } catch (error: any) {\n      this.logger.error(`Failed to fetch aggregated prices for ${ticker}: ${error.message}`);\n      throw new InternalServerErrorException('Failed to fetch aggregated price data');\n    }\n  }\n\n  /**\n   * Get price data for a ticker\n   *\n   * @param ticker Ticker symbol\n   * @param timeframe Timeframe (1D, 1MO, 1Y, etc)\n   * @returns Array of price data points\n   */\n  async getPrices(ticker: string, timeframe: string = '1MO'): Promise<PriceDataPoint[]> {\n    try {\n      // Convert timeframe to PriceRange enum\n      const priceRange = TIMEFRAME_TO_PRICE_RANGE[timeframe] || PriceRange.ONE_MONTH;\n\n      // Use AssetsService.getPriceHistory (j├í implementado)\n      const prices = await this.assetsService.getPriceHistory(ticker, {\n        range: priceRange,\n      });\n\n      // Convert to PriceDataPoint format (convert strings to numbers)\n      return prices.map((p: any) => ({\n        date: p.date,\n        open: parseFloat(p.open),\n        high: parseFloat(p.high),\n        low: parseFloat(p.low),\n        close: parseFloat(p.close),\n        volume: parseFloat(p.volume),\n      }));\n    } catch (error: any) {\n      this.logger.error(`Failed to fetch prices for ${ticker}: ${error.message}`);\n      throw new InternalServerErrorException('Failed to fetch price data');\n    }\n  }\n\n  /**\n   * Get technical analysis data (prices + indicators) with caching\n   *\n   * @param ticker Ticker symbol\n   * @param timeframe Timeframe (1D, 1MO, 1Y, etc)\n   * @returns Technical data response with prices, indicators, and metadata\n   */\n  async getTechnicalData(\n    ticker: string,\n    timeframe: string = '1D',\n    range: string = '1y',\n  ): Promise<TechnicalDataResponseDto> {\n    const startTime = Date.now();\n    const cacheKey = `${ticker}:${timeframe}:${range}:technical`;\n\n    // Try cache first\n    try {\n      const cached = await this.cacheService.get<TechnicalDataResponseDto>(cacheKey);\n\n      if (cached) {\n        const duration = Date.now() - startTime;\n        this.logger.log(`Ô£à Cache HIT: ${ticker}:${timeframe}:${range} (${duration}ms)`);\n\n        return {\n          ...cached,\n          metadata: {\n            ...cached.metadata,\n            cached: true,\n            duration,\n          },\n        };\n      }\n    } catch (error: any) {\n      this.logger.warn(`ÔÜá´©Å Cache error: ${error.message}`);\n    }\n\n    // Cache miss: fetch fresh data\n    this.logger.debug(`Cache MISS: ${ticker}:${timeframe}:${range}, fetching fresh data`);\n\n    const prices = await this.getAggregatedPrices(ticker, timeframe, range);\n\n    // Validate minimum data points\n    if (prices.length < MIN_DATA_POINTS_FOR_INDICATORS) {\n      this.logger.warn(\n        `Insufficient data for ${ticker}: ${prices.length}/${MIN_DATA_POINTS_FOR_INDICATORS}`,\n      );\n\n      const response: TechnicalDataResponseDto = {\n        ticker,\n        prices,\n        indicators: null,\n        metadata: {\n          data_points: prices.length,\n          cached: false,\n          duration: Date.now() - startTime,\n          error: 'INSUFFICIENT_DATA',\n          message: 'Minimum 200 data points required for technical analysis',\n          available: prices.length,\n          required: MIN_DATA_POINTS_FOR_INDICATORS,\n        },\n      };\n\n      return response;\n    }\n\n    // Calculate indicators via Python Service\n    const indicators = await this.pythonServiceClient.calculateIndicators(ticker, prices);\n\n    const duration = Date.now() - startTime;\n\n    const response: TechnicalDataResponseDto = {\n      ticker,\n      prices,\n      indicators,\n      metadata: {\n        data_points: prices.length,\n        cached: false,\n        duration,\n        ...(indicators === null && {\n          error: 'PYTHON_SERVICE_ERROR',\n          message: 'Failed to calculate indicators (Python Service unavailable)',\n        }),\n      },\n    };\n\n    // Store in cache (only if indicators calculated successfully)\n    if (indicators !== null) {\n      try {\n        await this.cacheService.set(cacheKey, response, CACHE_TTL.TECHNICAL_DATA);\n        this.logger.debug(`Cached: ${cacheKey} (TTL: ${CACHE_TTL.TECHNICAL_DATA}s)`);\n      } catch (error: any) {\n        this.logger.warn(`Cache set error: ${error.message}`);\n      }\n    }\n\n    this.logger.log(`ÔØî Cache MISS: ${ticker}:${timeframe} (${duration}ms)`);\n\n    return response;\n  }\n\n  /**\n   * Generate cache key for technical data\n   */\n  private generateCacheKey(ticker: string, timeframe: string): string {\n    return this.cacheService.generateKey('market-data', 'technical', ticker, timeframe, 'all');\n  }\n\n  /**\n   * Sincroniza dados hist├│ricos do COTAHIST para um ativo\n   *\n   * Fluxo:\n   * 1. Buscar dados COTAHIST (Python Service)\n   * 2. Buscar dados BRAPI recentes (├║ltimos 3 meses)\n   * 3. Merge inteligente (COTAHIST prioridade)\n   * 4. Batch UPSERT PostgreSQL\n   *\n   * @param ticker - C├│digo do ativo (ex: ABEV3)\n   * @param startYear - Ano inicial (default: 2020)\n   * @param endYear - Ano final (default: ano atual)\n   * @returns Estat├¡sticas da sincroniza├º├úo\n   */\n  async syncHistoricalDataFromCotahist(\n    ticker: string,\n    startYear: number = 2020,\n    endYear: number = new Date().getFullYear(),\n  ): Promise<SyncCotahistResponseDto> {\n    const startTime = Date.now();\n    this.logger.log(`­ƒöä Sync COTAHIST: ${ticker} (${startYear}-${endYear})`);\n\n    let asset: Asset;\n    let syncHistory: SyncHistory;\n\n    try {\n      // FASE 37: Emit WebSocket event - sync started (individual sync = 1 asset)\n      this.syncGateway.emitSyncStarted({\n        tickers: [ticker],\n        totalAssets: 1,\n        startYear,\n        endYear,\n      });\n\n      // 1. Buscar ou criar asset\n      asset = await this.assetRepository.findOne({ where: { ticker } });\n      if (!asset) {\n        this.logger.log(`Creating new asset: ${ticker}`);\n        asset = this.assetRepository.create({ ticker });\n        await this.assetRepository.save(asset);\n      }\n\n      // 2. Buscar dados COTAHIST via Python Service\n      this.logger.debug(`Fetching COTAHIST data for ${ticker}...`);\n      // FASE 37: Emit progress - fetching COTAHIST\n      this.syncGateway.emitSyncProgress({\n        ticker,\n        current: 1,\n        total: 1,\n        status: 'processing',\n      });\n      const cotahistData = await this.fetchCotahistData(ticker, startYear, endYear);\n      this.logger.log(`Ô£à COTAHIST: ${cotahistData.length} records`);\n\n      // 3. Buscar dados BRAPI recentes (├║ltimos 3 meses)\n      this.logger.debug(`Fetching BRAPI recent data for ${ticker}...`);\n      const brapiData = await this.fetchBrapiRecentData(ticker);\n      this.logger.log(`Ô£à BRAPI: ${brapiData.length} records (last 3mo)`);\n\n      // 4. Merge strategy\n      this.logger.debug(`Merging COTAHIST + BRAPI...`);\n      const mergedData = this.mergeCotahistBrapi(cotahistData, brapiData, ticker);\n      this.logger.log(`Ô£à Merged: ${mergedData.length} records`);\n\n      // 5. Batch UPSERT\n      this.logger.debug(`Batch UPSERT to PostgreSQL...`);\n      await this.batchUpsertPrices(asset.id, mergedData);\n\n      // 6. Estat├¡sticas\n      const endTime = Date.now();\n      const processingTime = (endTime - startTime) / 1000;\n\n      // 7. FASE 34.6: Record successful sync operation (audit trail)\n      syncHistory = this.syncHistoryRepository.create({\n        assetId: asset.id,\n        operationType: SyncOperationType.SYNC_COTAHIST,\n        status: SyncStatus.SUCCESS,\n        recordsSynced: mergedData.length,\n        yearsProcessed: endYear - startYear + 1,\n        processingTime,\n        sourceDetails: {\n          cotahist: cotahistData.length,\n          brapi: brapiData.length,\n          merged: mergedData.length,\n        },\n        errorMessage: null,\n        metadata: {\n          startYear,\n          endYear,\n          period: {\n            start: mergedData[0]?.date || '',\n            end: mergedData[mergedData.length - 1]?.date || '',\n          },\n        },\n      });\n      await this.syncHistoryRepository.save(syncHistory);\n      this.logger.debug(`­ƒôØ Sync history recorded: ${syncHistory.id}`);\n\n      this.logger.log(\n        `Ô£à Sync complete: ${ticker} (${mergedData.length} records, ${processingTime.toFixed(2)}s)`,\n      );\n\n      // FASE 37: Emit WebSocket event - sync completed successfully\n      this.syncGateway.emitSyncCompleted({\n        totalAssets: 1,\n        successCount: 1,\n        failedCount: 0,\n        duration: processingTime,\n      });\n\n      return {\n        totalRecords: mergedData.length,\n        yearsProcessed: endYear - startYear + 1,\n        processingTime,\n        sources: {\n          cotahist: cotahistData.length,\n          brapi: brapiData.length,\n          merged: mergedData.length,\n        },\n        period: {\n          start: mergedData[0]?.date || '',\n          end: mergedData[mergedData.length - 1]?.date || '',\n        },\n      };\n    } catch (error: any) {\n      // FASE 34.6: Record failed sync operation (audit trail)\n      const endTime = Date.now();\n      const processingTime = (endTime - startTime) / 1000;\n\n      if (asset) {\n        try {\n          syncHistory = this.syncHistoryRepository.create({\n            assetId: asset.id,\n            operationType: SyncOperationType.SYNC_COTAHIST,\n            status: SyncStatus.FAILED,\n            recordsSynced: null,\n            yearsProcessed: endYear - startYear + 1,\n            processingTime,\n            sourceDetails: null,\n            errorMessage: error.message,\n            metadata: {\n              startYear,\n              endYear,\n              errorStack: error.stack,\n            },\n          });\n          await this.syncHistoryRepository.save(syncHistory);\n          this.logger.debug(`­ƒôØ Failed sync history recorded: ${syncHistory.id}`);\n        } catch (historyError: any) {\n          this.logger.error(`Failed to record sync history: ${historyError.message}`);\n        }\n      }\n\n      this.logger.error(`Failed to sync COTAHIST for ${ticker}: ${error.message}`);\n\n      // FASE 37: Emit WebSocket event - sync failed\n      if (asset) {\n        this.syncGateway.emitSyncFailed({\n          error: error.message,\n          tickers: [ticker],\n        });\n      }\n\n      throw new InternalServerErrorException(`Failed to sync historical data: ${error.message}`);\n    }\n  }\n\n  /**\n   * Busca dados COTAHIST via Python Service\n   */\n  private async fetchCotahistData(\n    ticker: string,\n    startYear: number,\n    endYear: number,\n  ): Promise<any[]> {\n    try {\n      const response = await this.pythonServiceClient.post(\n        '/cotahist/fetch',\n        {\n          start_year: startYear,\n          end_year: endYear,\n          tickers: [ticker],\n        },\n        180000, // 180s timeout (COTAHIST download + parse pode demorar)\n      );\n\n      return response.data || [];\n    } catch (error: any) {\n      this.logger.warn(`COTAHIST fetch failed for ${ticker}: ${error.message}`);\n      return []; // Retornar array vazio se COTAHIST falhar (fallback para BRAPI apenas)\n    }\n  }\n\n  /**\n   * Busca dados BRAPI recentes (├║ltimos 3 meses)\n   */\n  private async fetchBrapiRecentData(ticker: string): Promise<any[]> {\n    try {\n      // Usar getPriceHistory com range=3mo\n      const prices = await this.assetsService.getPriceHistory(ticker, {\n        range: PriceRange.THREE_MONTHS,\n      });\n\n      return prices || [];\n    } catch (error: any) {\n      this.logger.warn(`BRAPI fetch failed for ${ticker}: ${error.message}`);\n      return []; // Retornar array vazio se BRAPI falhar\n    }\n  }\n\n  /**\n   * Merge inteligente: COTAHIST (hist├│rico) + BRAPI (recente + adjustedClose)\n   *\n   * Estrat├®gia:\n   * 1. COTAHIST: 1986 ÔåÆ (hoje - 3 meses)\n   * 2. BRAPI: (hoje - 3 meses) ÔåÆ hoje (com adjustedClose)\n   * 3. Se diverg├¬ncia > 1% no overlap ÔåÆ log warning\n   * 4. COTAHIST tem prioridade em caso de conflito\n   */\n  private mergeCotahistBrapi(cotahist: any[], brapi: any[], ticker: string): any[] {\n    const cotahistMap = new Map(cotahist.map((d) => [d.date, d]));\n    const brapiMap = new Map(brapi.map((d) => [d.date, d]));\n\n    const merged: any[] = [];\n    const threeMonthsAgo = new Date();\n    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);\n\n    // Adicionar todos os dados COTAHIST\n    for (const [date, data] of cotahistMap.entries()) {\n      merged.push({\n        date,\n        open: data.open,\n        high: data.high,\n        low: data.low,\n        close: data.close,\n        volume: data.volume,\n        adjustedClose: null, // COTAHIST n├úo tem adjustedClose\n        source: PriceSource.COTAHIST, // Rastreabilidade: dados oficiais B3\n      });\n    }\n\n    // Adicionar dados BRAPI recentes (├║ltimos 3 meses)\n    for (const [date, data] of brapiMap.entries()) {\n      const dateObj = new Date(date);\n\n      if (dateObj >= threeMonthsAgo) {\n        const cotahistRecord = cotahistMap.get(date);\n\n        // Se overlap, validar diverg├¬ncia\n        if (cotahistRecord) {\n          const divergence = Math.abs((cotahistRecord.close - data.close) / cotahistRecord.close);\n\n          if (divergence > 0.01) {\n            this.logger.warn(\n              `ÔÜá´©Å Diverg├¬ncia ${(divergence * 100).toFixed(2)}% em ${date} (${ticker}): ` +\n                `COTAHIST=${cotahistRecord.close.toFixed(2)}, BRAPI=${data.close.toFixed(2)}`,\n            );\n          }\n        }\n\n        // Adicionar/atualizar com dados BRAPI (tem adjustedClose)\n        const existingIdx = merged.findIndex((m) => m.date === date);\n        const record = {\n          date,\n          open: data.open,\n          high: data.high,\n          low: data.low,\n          close: data.close,\n          volume: data.volume,\n          adjustedClose: data.adjustedClose || data.close, // BRAPI pode n├úo ter adjustedClose\n          source: PriceSource.BRAPI, // Rastreabilidade: dados BRAPI API (com ajuste proventos)\n        };\n\n        if (existingIdx >= 0) {\n          merged[existingIdx] = record; // Substituir com BRAPI\n        } else {\n          merged.push(record);\n        }\n      }\n    }\n\n    // Ordenar por data\n    return merged.sort((a, b) => a.date.localeCompare(b.date));\n  }\n\n  /**\n   * Batch UPSERT no PostgreSQL usando DELETE+INSERT\n   * (compat├¡vel com TimescaleDB hypertables, n├úo requer UNIQUE constraint)\n   */\n  /**\n   * Batch UPSERT no PostgreSQL usando ON CONFLICT (Native UPSERT)\n   * Requer constraint UNIQUE (\"asset_id\", \"date\")\n   */\n  private async batchUpsertPrices(assetId: string, data: any[]): Promise<void> {\n    if (data.length === 0) {\n      this.logger.warn('No data to upsert');\n      return;\n    }\n\n    try {\n      // Preparar entidades\n      const entities = data.map((d) =>\n        this.assetPriceRepository.create({\n          assetId,\n          date: new Date(d.date),\n          open: d.open,\n          high: d.high,\n          low: d.low,\n          close: d.close,\n          volume: d.volume,\n          adjustedClose: d.adjustedClose,\n          source: d.source,\n        }),\n      );\n\n      // Executar Batch UPSERT em chunks para evitar limites de par├ómetros\n      // FASE 34.4: Otimizado de 1000 ÔåÆ 5000 records/batch (5x performance)\n      const BATCH_SIZE = 5000; // PostgreSQL suporta bem (testado em produ├º├úo)\n      const totalBatches = Math.ceil(entities.length / BATCH_SIZE);\n\n      for (let i = 0; i < entities.length; i += BATCH_SIZE) {\n        const batch = entities.slice(i, i + BATCH_SIZE);\n\n        await this.assetPriceRepository\n          .createQueryBuilder()\n          .insert()\n          .into(AssetPrice)\n          .values(batch)\n          .orUpdate(\n            ['open', 'high', 'low', 'close', 'volume', 'adjusted_close', 'source'],\n            'UQ_asset_prices_asset_id_date', // Explicit constraint name\n          )\n          .execute();\n\n        // FASE 34.4: Progress logs detalhados (0% ÔåÆ 100%)\n        const progress = ((i + batch.length) / entities.length) * 100;\n        const batchNum = Math.floor(i / BATCH_SIZE) + 1;\n        this.logger.log(\n          `­ƒôª Batch UPSERT progress: ${i + batch.length}/${entities.length} records (${progress.toFixed(1)}%) [Batch ${batchNum}/${totalBatches}]`,\n        );\n      }\n\n      this.logger.log(`Ô£à Batch UPSERT complete: ${data.length} records`);\n    } catch (error: any) {\n      this.logger.error(`Batch UPSERT failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Invalidate cache for a specific ticker (all timeframes)\n   * For future use (FASE 31)\n   */\n  async invalidateTickerCache(ticker: string): Promise<void> {\n    this.logger.log(`Invalidating cache for ticker: ${ticker}`);\n    // TODO: Implement SCAN-based pattern invalidation\n    // For now, just log (TTL will handle expiration)\n  }\n\n  /**\n   * FASE 34.6: Get Sync History (Audit Trail)\n   *\n   * Retorna hist├│rico de todas as sync operations para compliance e monitoring.\n   * Suporta filtros: ticker, status, operation type, pagination.\n   *\n   * @param filters - Filtros opcionais (ticker, status, operationType, limit, offset)\n   * @returns Array de sync history records + metadata de pagina├º├úo\n   */\n  async getSyncHistory(filters: {\n    ticker?: string;\n    status?: string;\n    operationType?: string;\n    limit?: number;\n    offset?: number;\n  }) {\n    try {\n      const { ticker, status, operationType, limit = 50, offset = 0 } = filters;\n\n      // Build where clause\n      const where: any = {};\n      if (status) {\n        where.status = status;\n      }\n      if (operationType) {\n        where.operationType = operationType;\n      }\n\n      // If ticker filter, we need to fetch asset first\n      let assetFilter: string | undefined;\n      if (ticker) {\n        const asset = await this.assetRepository.findOne({ where: { ticker } });\n        if (!asset) {\n          return {\n            data: [],\n            pagination: { total: 0, limit, offset, hasMore: false },\n          };\n        }\n        where.assetId = asset.id;\n      }\n\n      const [records, total] = await this.syncHistoryRepository.findAndCount({\n        where,\n        relations: ['asset'],\n        order: { createdAt: 'DESC' },\n        take: limit,\n        skip: offset,\n      });\n\n      this.logger.log(\n        `Sync history query: ${records.length}/${total} records (ticker=${ticker}, status=${status})`,\n      );\n\n      return {\n        data: records.map((record) => ({\n          id: record.id,\n          ticker: record.asset.ticker,\n          operationType: record.operationType,\n          status: record.status,\n          recordsSynced: record.recordsSynced,\n          yearsProcessed: record.yearsProcessed,\n          processingTime: record.processingTime,\n          sourceDetails: record.sourceDetails,\n          errorMessage: record.errorMessage,\n          metadata: record.metadata,\n          createdAt: record.createdAt,\n          updatedAt: record.updatedAt,\n        })),\n        pagination: {\n          total,\n          limit,\n          offset,\n          hasMore: offset + limit < total,\n        },\n      };\n    } catch (error: any) {\n      this.logger.error(`Failed to get sync history: ${error.message}`);\n      throw new InternalServerErrorException('Failed to retrieve sync history');\n    }\n  }\n\n  /**\n   * FASE 35: Obter status de sincroniza├º├úo de todos os ativos\n   *\n   * Retorna lista consolidada com status de sync, quantidade de registros,\n   * per├¡odo de dados e ├║ltima sincroniza├º├úo para cada ativo B3.\n   *\n   * Performance: Usa query SQL otimizada com LEFT JOIN para buscar tudo em 1 query\n   * ao inv├®s de 220+ queries (55 ativos ├ù 4 queries cada).\n   *\n   * @returns Status de sync de todos os 55 ativos + resumo consolidado\n   */\n  async getSyncStatus(): Promise<any> {\n    const startTime = Date.now();\n\n    try {\n      // Query SQL otimizada com LEFT JOIN (99.5% mais r├ípida que queries individuais)\n      // Busca: assets + count prices + min/max dates + last sync history\n      const query = `\n        SELECT\n          a.ticker,\n          a.name,\n          COUNT(ap.id)::int as records_loaded,\n          MIN(ap.date) as oldest_date,\n          MAX(ap.date) as newest_date,\n          sh.status as last_sync_status,\n          sh.created_at as last_sync_at,\n          sh.processing_time as last_sync_duration\n        FROM assets a\n        LEFT JOIN asset_prices ap ON ap.asset_id = a.id\n        LEFT JOIN LATERAL (\n          SELECT status, created_at, processing_time\n          FROM sync_history\n          WHERE asset_id = a.id\n          ORDER BY created_at DESC\n          LIMIT 1\n        ) sh ON true\n        WHERE a.is_active = true\n        GROUP BY a.id, a.ticker, a.name, sh.status, sh.created_at, sh.processing_time\n        ORDER BY a.ticker ASC\n      `;\n\n      const results = await this.assetRepository.query(query);\n\n      // Transformar resultados em DTOs tipados\n      const assets = results.map((row: any) => {\n        const recordsLoaded = row.records_loaded || 0;\n\n        // Determinar status baseado em regras de neg├│cio:\n        // PENDING: 0 registros (nunca sincronizado)\n        // FAILED: ├║ltima sync com status failed\n        // PARTIAL: < 200 registros (insuficiente para indicadores t├®cnicos)\n        // SYNCED: ÔëÑ 200 registros E ├║ltima sync success\n        let status: string;\n        if (recordsLoaded === 0) {\n          status = 'PENDING';\n        } else if (row.last_sync_status === 'failed') {\n          status = 'FAILED';\n        } else if (recordsLoaded < 200) {\n          status = 'PARTIAL';\n        } else {\n          status = 'SYNCED';\n        }\n\n        return {\n          ticker: row.ticker,\n          name: row.name,\n          recordsLoaded,\n          oldestDate: row.oldest_date ? row.oldest_date.toISOString().split('T')[0] : null,\n          newestDate: row.newest_date ? row.newest_date.toISOString().split('T')[0] : null,\n          status,\n          lastSyncAt: row.last_sync_at || null,\n          lastSyncDuration: row.last_sync_duration ? parseFloat(row.last_sync_duration) : null,\n        };\n      });\n\n      // Calcular resumo consolidado\n      const summary = {\n        total: assets.length,\n        synced: assets.filter((a) => a.status === 'SYNCED').length,\n        pending: assets.filter((a) => a.status === 'PENDING').length,\n        failed: assets.filter((a) => a.status === 'FAILED').length,\n      };\n\n      const duration = Date.now() - startTime;\n      this.logger.log(`Ô£à getSyncStatus completed in ${duration}ms (${assets.length} assets)`);\n\n      if (duration > 500) {\n        this.logger.warn(`ÔÜá´©Å SLOW QUERY: getSyncStatus took ${duration}ms (> 500ms threshold)`);\n      }\n\n      return { assets, summary };\n    } catch (error: any) {\n      this.logger.error(`Failed to get sync status: ${error.message}`);\n      throw new InternalServerErrorException('Failed to retrieve sync status');\n    }\n  }\n\n  /**\n   * FASE 35: Sincronizar m├║ltiplos ativos em massa (bulk sync)\n   *\n   * Processa tickers SEQUENCIALMENTE (1 por vez) para evitar sobrecarga do Python Service.\n   * Emite eventos WebSocket em tempo real para acompanhamento do progresso.\n   *\n   * Features:\n   * - Valida├º├úo pr├®via de tickers (fail-fast)\n   * - Retry 3x com backoff exponencial\n   * - Progress tracking via WebSocket\n   * - Processamento ass├¡ncrono (retorna 202 Accepted imediatamente)\n   *\n   * @param tickers Lista de tickers para sincronizar (max 20)\n   * @param startYear Ano inicial (1986-2024)\n   * @param endYear Ano final (1986-2024)\n   * @returns Resumo da opera├º├úo (n├úo aguarda conclus├úo)\n   */\n  async syncBulkAssets(\n    tickers: string[],\n    startYear: number,\n    endYear: number,\n  ): Promise<{ successCount: number; failedTickers: string[] }> {\n    const startTime = Date.now();\n    this.logger.log(`­ƒöä Bulk Sync iniciado: ${tickers.length} tickers (${startYear}-${endYear})`);\n\n    // 1. Valida├º├úo pr├®via: Verificar se todos os tickers existem no database\n    const validAssets = await this.assetRepository.find({\n      where: { ticker: In(tickers), isActive: true },\n      select: ['ticker'],\n    });\n\n    if (validAssets.length !== tickers.length) {\n      const validTickers = validAssets.map((a) => a.ticker);\n      const invalidTickers = tickers.filter((t) => !validTickers.includes(t));\n\n      this.logger.error(`ÔØî Tickers inv├ílidos: ${invalidTickers.join(', ')}`);\n\n      // FASE 35: Emitir WebSocket event de falha cr├¡tica\n      this.syncGateway.emitSyncFailed({\n        error: `Tickers inv├ílidos ou inativos: ${invalidTickers.join(', ')}`,\n        tickers: invalidTickers,\n      });\n\n      throw new InternalServerErrorException(\n        `Tickers inv├ílidos ou inativos: ${invalidTickers.join(', ')}`,\n      );\n    }\n\n    // FASE 35: Emitir WebSocket event de in├¡cio\n    this.syncGateway.emitSyncStarted({\n      tickers,\n      totalAssets: tickers.length,\n      startYear,\n      endYear,\n    });\n\n    // 2. Processar tickers SEQUENCIALMENTE (n├úo paralelo)\n    const results = {\n      successCount: 0,\n      failedTickers: [] as string[],\n    };\n\n    for (let i = 0; i < tickers.length; i++) {\n      const ticker = tickers[i];\n      const current = i + 1;\n      const total = tickers.length;\n\n      this.logger.log(`­ƒôª Processing ${ticker} (${current}/${total})...`);\n\n      // FASE 35: Emitir progresso - processing\n      this.syncGateway.emitSyncProgress({\n        ticker,\n        current,\n        total,\n        status: 'processing',\n      });\n\n      // Retry logic: 3 tentativas com backoff exponencial\n      let attempts = 0;\n      let success = false;\n      const tickerStartTime = Date.now();\n\n      while (attempts < 3 && !success) {\n        attempts++;\n\n        try {\n          // Reutilizar m├®todo existente syncHistoricalDataFromCotahist\n          const syncResult = await this.syncHistoricalDataFromCotahist(ticker, startYear, endYear);\n\n          results.successCount++;\n          success = true;\n\n          const tickerDuration = (Date.now() - tickerStartTime) / 1000;\n          this.logger.log(`Ô£à ${ticker} sincronizado (${current}/${total})`);\n\n          // FASE 35: Emitir progresso - success\n          this.syncGateway.emitSyncProgress({\n            ticker,\n            current,\n            total,\n            status: 'success',\n            recordsInserted: syncResult.totalRecords,\n            duration: Math.round(tickerDuration),\n          });\n        } catch (error: any) {\n          this.logger.error(`ÔØî Tentativa ${attempts}/3 falhou para ${ticker}: ${error.message}`);\n\n          if (attempts < 3) {\n            // Backoff exponencial: 2s, 4s, 8s\n            const backoffMs = Math.pow(2, attempts) * 1000;\n            this.logger.log(`ÔÅ│ Aguardando ${backoffMs}ms antes de retry...`);\n            await new Promise((resolve) => setTimeout(resolve, backoffMs));\n          } else {\n            // Falhou ap├│s 3 tentativas\n            results.failedTickers.push(ticker);\n\n            const tickerDuration = (Date.now() - tickerStartTime) / 1000;\n\n            // FASE 35: Emitir progresso - failed\n            this.syncGateway.emitSyncProgress({\n              ticker,\n              current,\n              total,\n              status: 'failed',\n              error: error.message,\n              duration: Math.round(tickerDuration),\n            });\n          }\n        }\n      }\n    }\n\n    const duration = (Date.now() - startTime) / 1000;\n    this.logger.log(\n      `Ô£à Bulk Sync completed: ${results.successCount}/${tickers.length} successful in ${duration.toFixed(1)}s`,\n    );\n\n    if (results.failedTickers.length > 0) {\n      this.logger.warn(`ÔÜá´©Å Failed tickers: ${results.failedTickers.join(', ')}`);\n    }\n\n    // FASE 35: Emitir WebSocket event de conclus├úo\n    this.syncGateway.emitSyncCompleted({\n      totalAssets: tickers.length,\n      successCount: results.successCount,\n      failedCount: results.failedTickers.length,\n      duration: Math.round(duration),\n      failedTickers: results.failedTickers.length > 0 ? results.failedTickers : undefined,\n    });\n\n    return results;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\market-data\\sync.gateway.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\portfolio\\parsers\\b3-parser.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fileBuffer' is defined but never used.","line":10,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport * as ExcelJS from 'exceljs';\nimport { PortfolioParser, ParsedPortfolio, PortfolioPosition } from './portfolio-parser.interface';\n\n@Injectable()\nexport class B3Parser implements PortfolioParser {\n  private readonly logger = new Logger(B3Parser.name);\n  readonly source = 'b3';\n\n  canParse(filename: string, fileBuffer: Buffer): boolean {\n    const ext = filename.toLowerCase();\n    return ext.endsWith('.xlsx') || ext.endsWith('.xls');\n  }\n\n  async parse(fileBuffer: Buffer, filename: string): Promise<ParsedPortfolio> {\n    this.logger.log(`Parsing B3 portfolio from ${filename}`);\n\n    try {\n      const workbook = new ExcelJS.Workbook();\n      await workbook.xlsx.load(fileBuffer as any);\n\n      const worksheet = workbook.worksheets[0];\n      const data: any[] = [];\n\n      // Convert worksheet to JSON format\n      const headers: string[] = [];\n      worksheet.eachRow((row, rowNumber) => {\n        if (rowNumber === 1) {\n          // First row is headers\n          row.eachCell((cell) => {\n            headers.push(String(cell.value || ''));\n          });\n        } else {\n          // Data rows\n          const rowData: any = {};\n          row.eachCell((cell, colNumber) => {\n            const header = headers[colNumber - 1];\n            if (header) {\n              rowData[header] = cell.value;\n            }\n          });\n          if (Object.keys(rowData).length > 0) {\n            data.push(rowData);\n          }\n        }\n      });\n\n      const positions: PortfolioPosition[] = [];\n      let totalInvested = 0;\n\n      for (const row of data) {\n        // B3 format variations\n        const ticker = this.extractTicker(row);\n        const quantity = this.extractQuantity(row);\n        const averagePrice = this.extractAveragePrice(row);\n\n        if (ticker && quantity && averagePrice) {\n          const totalInv = quantity * averagePrice;\n          positions.push({\n            ticker,\n            quantity,\n            averagePrice,\n            totalInvested: totalInv,\n            assetType: this.detectAssetType(ticker),\n          });\n          totalInvested += totalInv;\n        }\n      }\n\n      return {\n        source: this.source,\n        positions,\n        totalInvested,\n        metadata: {\n          filename,\n          parsedAt: new Date().toISOString(),\n          rowCount: data.length,\n        },\n      };\n    } catch (error) {\n      this.logger.error(`Failed to parse B3 portfolio: ${error.message}`);\n      throw new Error(`Failed to parse B3 portfolio: ${error.message}`);\n    }\n  }\n\n  private extractTicker(row: any): string | null {\n    // Try different column names\n    const tickerKeys = [\n      'C├│digo do Ativo',\n      'Codigo do Ativo',\n      'C├│digo',\n      'Codigo',\n      'Ticker',\n      'Ativo',\n    ];\n\n    for (const key of tickerKeys) {\n      if (row[key]) {\n        return String(row[key]).trim().toUpperCase();\n      }\n    }\n\n    return null;\n  }\n\n  private extractQuantity(row: any): number | null {\n    const quantityKeys = ['Quantidade', 'Qtd', 'Qtde', 'Qty', 'Quantidade de Ativos'];\n\n    for (const key of quantityKeys) {\n      if (row[key] !== undefined && row[key] !== null) {\n        const value =\n          typeof row[key] === 'string'\n            ? parseFloat(row[key].replace(/\\./g, '').replace(',', '.'))\n            : row[key];\n        if (!isNaN(value)) return value;\n      }\n    }\n\n    return null;\n  }\n\n  private extractAveragePrice(row: any): number | null {\n    const priceKeys = [\n      'Pre├ºo M├®dio',\n      'Preco Medio',\n      'Pre├ºo',\n      'Preco',\n      'PM',\n      'Valor',\n      'Pre├ºo M├®dio de Compra',\n    ];\n\n    for (const key of priceKeys) {\n      if (row[key] !== undefined && row[key] !== null) {\n        let value = row[key];\n\n        // Handle string prices\n        if (typeof value === 'string') {\n          value = value\n            .replace(/R\\$\\s?/g, '')\n            .replace(/\\./g, '')\n            .replace(',', '.');\n          value = parseFloat(value);\n        }\n\n        if (!isNaN(value)) return value;\n      }\n    }\n\n    return null;\n  }\n\n  private detectAssetType(ticker: string): string {\n    if (ticker.endsWith('11') || ticker.endsWith('B')) return 'fii';\n    if (ticker.match(/^[A-Z]{4}[0-9]{2}$/)) return 'bdr';\n    if (ticker.match(/^[A-Z]{4}[A-Z][0-9]{2}$/)) return 'option';\n    if (ticker.match(/^[A-Z]{4}[0-9]{1}$/)) return 'stock';\n    return 'stock';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\portfolio\\parsers\\kinvo-parser.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fileBuffer' is defined but never used.","line":10,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport * as ExcelJS from 'exceljs';\nimport { PortfolioParser, ParsedPortfolio, PortfolioPosition } from './portfolio-parser.interface';\n\n@Injectable()\nexport class KinvoParser implements PortfolioParser {\n  private readonly logger = new Logger(KinvoParser.name);\n  readonly source = 'kinvo';\n\n  canParse(filename: string, fileBuffer: Buffer): boolean {\n    const ext = filename.toLowerCase();\n    return (\n      (ext.endsWith('.xlsx') || ext.endsWith('.xls') || ext.endsWith('.csv')) &&\n      filename.toLowerCase().includes('kinvo')\n    );\n  }\n\n  async parse(fileBuffer: Buffer, filename: string): Promise<ParsedPortfolio> {\n    this.logger.log(`Parsing Kinvo portfolio from ${filename}`);\n\n    try {\n      let data: any[];\n\n      if (filename.toLowerCase().endsWith('.csv')) {\n        data = this.parseCSV(fileBuffer);\n      } else {\n        const workbook = new ExcelJS.Workbook();\n        await workbook.xlsx.load(fileBuffer as any);\n\n        const worksheet = workbook.worksheets[0];\n        data = [];\n\n        // Convert worksheet to JSON format\n        const headers: string[] = [];\n        worksheet.eachRow((row, rowNumber) => {\n          if (rowNumber === 1) {\n            // First row is headers\n            row.eachCell((cell) => {\n              headers.push(String(cell.value || ''));\n            });\n          } else {\n            // Data rows\n            const rowData: any = {};\n            row.eachCell((cell, colNumber) => {\n              const header = headers[colNumber - 1];\n              if (header) {\n                rowData[header] = cell.value;\n              }\n            });\n            if (Object.keys(rowData).length > 0) {\n              data.push(rowData);\n            }\n          }\n        });\n      }\n\n      const positions: PortfolioPosition[] = [];\n      let totalInvested = 0;\n\n      for (const row of data) {\n        const ticker = this.extractValue(row, ['Ticker', 'C├│digo', 'Ativo']);\n        const quantity = this.extractNumber(row, ['Quantidade', 'Qtd']);\n        const averagePrice = this.extractNumber(row, ['Pre├ºo M├®dio', 'PM', 'Valor M├®dio']);\n        const currentPrice = this.extractNumber(row, ['Cota├º├úo', 'Pre├ºo Atual', 'Valor Atual']);\n\n        if (ticker && quantity && averagePrice) {\n          const totalInv = quantity * averagePrice;\n          positions.push({\n            ticker: ticker.toUpperCase(),\n            quantity,\n            averagePrice,\n            totalInvested: totalInv,\n            currentPrice,\n            assetType: this.extractValue(row, ['Tipo', 'Categoria', 'Classe']),\n          });\n          totalInvested += totalInv;\n        }\n      }\n\n      return {\n        source: this.source,\n        positions,\n        totalInvested,\n        metadata: {\n          filename,\n          parsedAt: new Date().toISOString(),\n          rowCount: data.length,\n          format: filename.toLowerCase().endsWith('.csv') ? 'csv' : 'xlsx',\n        },\n      };\n    } catch (error) {\n      this.logger.error(`Failed to parse Kinvo portfolio: ${error.message}`);\n      throw new Error(`Failed to parse Kinvo portfolio: ${error.message}`);\n    }\n  }\n\n  private parseCSV(buffer: Buffer): any[] {\n    const content = buffer.toString('utf-8');\n    const lines = content.split('\\n');\n    const headers = lines[0].split(';').map((h) => h.trim());\n    const data = [];\n\n    for (let i = 1; i < lines.length; i++) {\n      if (!lines[i].trim()) continue;\n      const values = lines[i].split(';');\n      const row: any = {};\n      headers.forEach((header, index) => {\n        row[header] = values[index]?.trim();\n      });\n      data.push(row);\n    }\n\n    return data;\n  }\n\n  private extractValue(row: any, keys: string[]): string | null {\n    for (const key of keys) {\n      if (row[key]) {\n        return String(row[key]).trim();\n      }\n    }\n    return null;\n  }\n\n  private extractNumber(row: any, keys: string[]): number | null {\n    for (const key of keys) {\n      if (row[key] !== undefined && row[key] !== null) {\n        let value = row[key];\n\n        if (typeof value === 'string') {\n          value = value\n            .replace(/R\\$\\s?/g, '')\n            .replace(/\\./g, '')\n            .replace(',', '.');\n          value = parseFloat(value);\n        }\n\n        if (!isNaN(value)) return value;\n      }\n    }\n    return null;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\portfolio\\parsers\\portfolio-parser.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\portfolio\\portfolio.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\portfolio\\portfolio.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\portfolio\\portfolio.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\reports\\ai-report.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\reports\\dto\\asset-with-analysis-status.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\reports\\pdf-generator.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\reports\\reports.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\reports\\reports.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\api\\reports\\reports.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\app.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\app.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\app.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\common\\common.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\common\\decorators\\cache.decorator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\common\\interceptors\\cache.interceptor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\common\\services\\cache.service.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":60,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":60,"endColumn":78,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[1628,1699],"text":"// @ts-expect-error - reset may not be available in all store implementations"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger, Inject } from '@nestjs/common';\nimport { CACHE_MANAGER } from '@nestjs/cache-manager';\nimport { Cache } from 'cache-manager';\n\n@Injectable()\nexport class CacheService {\n  private readonly logger = new Logger(CacheService.name);\n\n  constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}\n\n  /**\n   * Get value from cache\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      const value = await this.cacheManager.get<T>(key);\n      if (value) {\n        this.logger.debug(`Cache hit: ${key}`);\n      } else {\n        this.logger.debug(`Cache miss: ${key}`);\n      }\n      return value;\n    } catch (error) {\n      this.logger.error(`Cache get error for key ${key}: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Set value in cache\n   */\n  async set<T>(key: string, value: T, ttl?: number): Promise<void> {\n    try {\n      await this.cacheManager.set(key, value, ttl ? ttl * 1000 : undefined);\n      this.logger.debug(`Cached: ${key}${ttl ? ` (TTL: ${ttl}s)` : ''}`);\n    } catch (error) {\n      this.logger.error(`Cache set error for key ${key}: ${error.message}`);\n    }\n  }\n\n  /**\n   * Delete value from cache\n   */\n  async del(key: string): Promise<void> {\n    try {\n      await this.cacheManager.del(key);\n      this.logger.debug(`Deleted from cache: ${key}`);\n    } catch (error) {\n      this.logger.error(`Cache delete error for key ${key}: ${error.message}`);\n    }\n  }\n\n  /**\n   * Clear all cache\n   * Note: reset() is not available in cache-manager v6+\n   * Use store-specific methods if needed\n   */\n  async reset(): Promise<void> {\n    try {\n      // @ts-ignore - reset may not be available in all store implementations\n      const store = (this.cacheManager as any).store;\n      if (store && typeof store.reset === 'function') {\n        await store.reset();\n        this.logger.log('Cache cleared');\n      } else {\n        this.logger.warn('Cache reset not supported by current store');\n      }\n    } catch (error: any) {\n      this.logger.error(`Cache reset error: ${error.message}`);\n    }\n  }\n\n  /**\n   * Cache with callback - get from cache or execute callback and cache result\n   */\n  async wrap<T>(key: string, callback: () => Promise<T>, ttl?: number): Promise<T> {\n    try {\n      // Try to get from cache\n      const cached = await this.get<T>(key);\n      if (cached !== null) {\n        return cached;\n      }\n\n      // Execute callback\n      const result = await callback();\n\n      // Cache result\n      await this.set(key, result, ttl);\n\n      return result;\n    } catch (error) {\n      this.logger.error(`Cache wrap error for key ${key}: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Invalidate cache by pattern (Redis specific)\n   */\n  async invalidatePattern(pattern: string): Promise<void> {\n    try {\n      // This would require access to the underlying Redis client\n      // For now, just log\n      this.logger.log(`Invalidating cache pattern: ${pattern}`);\n      // TODO: Implement Redis SCAN and DEL for pattern matching\n    } catch (error) {\n      this.logger.error(`Cache invalidate pattern error: ${error.message}`);\n    }\n  }\n\n  /**\n   * Generate cache key\n   */\n  generateKey(prefix: string, ...parts: any[]): string {\n    return [prefix, ...parts.map((p) => (typeof p === 'object' ? JSON.stringify(p) : p))].join(':');\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\common\\services\\notifications.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'notification' is defined but never used.","line":90,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":90,"endColumn":53}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport axios from 'axios';\n\nexport enum NotificationType {\n  PRICE_ALERT = 'price_alert',\n  ANALYSIS_COMPLETE = 'analysis_complete',\n  REPORT_READY = 'report_ready',\n  PORTFOLIO_UPDATE = 'portfolio_update',\n  SCRAPING_FAILED = 'scraping_failed',\n  RECOMMENDATION = 'recommendation',\n}\n\nexport interface Notification {\n  type: NotificationType;\n  title: string;\n  message: string;\n  data?: any;\n  userId?: string;\n}\n\n@Injectable()\nexport class NotificationsService {\n  private readonly logger = new Logger(NotificationsService.name);\n  private readonly emailEnabled: boolean;\n  private readonly telegramEnabled: boolean;\n  private readonly telegramBotToken: string;\n  private readonly telegramChatId: string;\n\n  constructor(private configService: ConfigService) {\n    this.emailEnabled = this.configService.get('EMAIL_ENABLED', false);\n    this.telegramEnabled = this.configService.get('TELEGRAM_ENABLED', false);\n    this.telegramBotToken = this.configService.get('TELEGRAM_BOT_TOKEN', '');\n    this.telegramChatId = this.configService.get('TELEGRAM_CHAT_ID', '');\n  }\n\n  /**\n   * Send notification\n   */\n  async send(notification: Notification): Promise<void> {\n    this.logger.log(`Sending notification: ${notification.type} - ${notification.title}`);\n\n    try {\n      const promises = [];\n\n      // Send to Telegram if enabled\n      if (this.telegramEnabled) {\n        promises.push(this.sendTelegram(notification));\n      }\n\n      // Send to Email if enabled\n      if (this.emailEnabled) {\n        promises.push(this.sendEmail(notification));\n      }\n\n      // TODO: Send push notification, WebSocket, etc.\n\n      await Promise.allSettled(promises);\n    } catch (error) {\n      this.logger.error(`Failed to send notification: ${error.message}`);\n    }\n  }\n\n  /**\n   * Send Telegram notification\n   */\n  private async sendTelegram(notification: Notification): Promise<void> {\n    if (!this.telegramBotToken || !this.telegramChatId) {\n      return;\n    }\n\n    try {\n      const text = this.formatTelegramMessage(notification);\n\n      await axios.post(`https://api.telegram.org/bot${this.telegramBotToken}/sendMessage`, {\n        chat_id: this.telegramChatId,\n        text,\n        parse_mode: 'HTML',\n      });\n\n      this.logger.log('Telegram notification sent');\n    } catch (error) {\n      this.logger.error(`Failed to send Telegram notification: ${error.message}`);\n    }\n  }\n\n  /**\n   * Send Email notification\n   */\n  private async sendEmail(notification: Notification): Promise<void> {\n    // TODO: Implement email sending\n    this.logger.log('Email notification sent (not implemented)');\n  }\n\n  /**\n   * Format Telegram message\n   */\n  private formatTelegramMessage(notification: Notification): string {\n    let icon = '­ƒôó';\n\n    switch (notification.type) {\n      case NotificationType.PRICE_ALERT:\n        icon = '­ƒÆ░';\n        break;\n      case NotificationType.ANALYSIS_COMPLETE:\n        icon = 'Ô£à';\n        break;\n      case NotificationType.REPORT_READY:\n        icon = '­ƒôè';\n        break;\n      case NotificationType.PORTFOLIO_UPDATE:\n        icon = '­ƒÆ╝';\n        break;\n      case NotificationType.SCRAPING_FAILED:\n        icon = 'ÔÜá´©Å';\n        break;\n      case NotificationType.RECOMMENDATION:\n        icon = '­ƒÄ»';\n        break;\n    }\n\n    let message = `${icon} <b>${notification.title}</b>\\n\\n${notification.message}`;\n\n    if (notification.data) {\n      message += '\\n\\n<i>Detalhes:</i>\\n';\n      message += this.formatData(notification.data);\n    }\n\n    return message;\n  }\n\n  /**\n   * Format notification data\n   */\n  private formatData(data: any): string {\n    const lines = [];\n\n    for (const [key, value] of Object.entries(data)) {\n      if (typeof value === 'object') {\n        lines.push(`${key}: ${JSON.stringify(value)}`);\n      } else {\n        lines.push(`${key}: ${value}`);\n      }\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Send price alert\n   */\n  async sendPriceAlert(ticker: string, currentPrice: number, targetPrice: number): Promise<void> {\n    await this.send({\n      type: NotificationType.PRICE_ALERT,\n      title: `Alerta de Pre├ºo - ${ticker}`,\n      message: `O ativo ${ticker} atingiu R$ ${currentPrice.toFixed(2)}!`,\n      data: {\n        ticker,\n        currentPrice: `R$ ${currentPrice.toFixed(2)}`,\n        targetPrice: `R$ ${targetPrice.toFixed(2)}`,\n      },\n    });\n  }\n\n  /**\n   * Send analysis complete notification\n   */\n  async sendAnalysisComplete(ticker: string, recommendation: string): Promise<void> {\n    await this.send({\n      type: NotificationType.ANALYSIS_COMPLETE,\n      title: `An├ílise Conclu├¡da - ${ticker}`,\n      message: `A an├ílise de ${ticker} foi conclu├¡da.`,\n      data: {\n        ticker,\n        recommendation,\n      },\n    });\n  }\n\n  /**\n   * Send report ready notification\n   */\n  async sendReportReady(ticker: string): Promise<void> {\n    await this.send({\n      type: NotificationType.REPORT_READY,\n      title: `Relat├│rio Pronto - ${ticker}`,\n      message: `O relat├│rio completo de ${ticker} est├í dispon├¡vel.`,\n      data: {\n        ticker,\n      },\n    });\n  }\n\n  /**\n   * Send portfolio update notification\n   */\n  async sendPortfolioUpdate(portfolioName: string, change: number): Promise<void> {\n    const emoji = change > 0 ? '­ƒôê' : change < 0 ? '­ƒôë' : 'Ô×í´©Å';\n\n    await this.send({\n      type: NotificationType.PORTFOLIO_UPDATE,\n      title: `Atualiza├º├úo de Portf├│lio`,\n      message: `${emoji} ${portfolioName}: ${change > 0 ? '+' : ''}${change.toFixed(2)}%`,\n      data: {\n        portfolio: portfolioName,\n        change: `${change > 0 ? '+' : ''}${change.toFixed(2)}%`,\n      },\n    });\n  }\n\n  /**\n   * Send recommendation notification\n   */\n  async sendRecommendation(\n    ticker: string,\n    action: string,\n    confidence: number,\n    reason: string,\n  ): Promise<void> {\n    let actionEmoji = '­ƒñö';\n\n    if (action === 'STRONG_BUY' || action === 'BUY') {\n      actionEmoji = '­ƒƒó';\n    } else if (action === 'SELL' || action === 'STRONG_SELL') {\n      actionEmoji = '­ƒö┤';\n    } else {\n      actionEmoji = '­ƒƒí';\n    }\n\n    await this.send({\n      type: NotificationType.RECOMMENDATION,\n      title: `Recomenda├º├úo - ${ticker}`,\n      message: `${actionEmoji} ${action} (${confidence}% confian├ºa)\\n\\n${reason}`,\n      data: {\n        ticker,\n        action,\n        confidence: `${confidence}%`,\n      },\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\common\\utils\\date-parser.util.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\data-source.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\database.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\analysis.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\asset-price.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\asset.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\data-source.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\economic-indicator.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\fundamental-data.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\portfolio-position.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\portfolio.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\scraped-data.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\scraper-metric.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\sync-history.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\update-log.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\entities\\user.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1700000000000-InitialSchema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1762716763091-AddAssetUpdateTracking.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1762877000000-AddUniqueConstraintAnalyses.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1762889210960-AddCollectedAtToAssetPrices.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1762905660778-AddChangeFieldsToAssetPrices.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1762906000000-CreateScraperMetrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1763331503585-AddUniqueConstraintAssetPrices.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1763500000000-AddSourceToAssetPrices.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1763513145845-AddUniqueConstraintAssetPrices.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1763513264878-RenameUniqueConstraintAssetPrices.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1763570147816-UpdateAssetPricePrecision.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1763600000000-CreateSyncHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\migrations\\1763728696267-CreateEconomicIndicators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\scripts\\cleanup-analyses.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\seeds\\admin-user.seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\seeds\\data-sources.seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\seeds\\ibov-assets.seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\seeds\\ibov-new-assets.seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\seeds\\seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\database\\seeds\\top20-b3-assets.seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\integrations\\brapi\\brapi.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'country' is assigned a value but never used.","line":100,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":100,"endColumn":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger, HttpException, HttpStatus } from '@nestjs/common';\nimport { HttpService } from '@nestjs/axios';\nimport { ConfigService } from '@nestjs/config';\nimport { firstValueFrom, timeout, catchError } from 'rxjs';\nimport { parseBCBDate } from '../../common/utils/date-parser.util';\n\n/**\n * BrapiService - Integra├º├úo com APIs de Indicadores Econ├┤micos\n *\n * FONTES:\n * - Banco Central Brasil API: https://api.bcb.gov.br/dados/serie/bcdata.sgs\n *   - S├®rie 11: SELIC (Taxa di├íria)\n *   - S├®rie 433: IPCA (Mensal)\n *\n * @created 2025-11-21 - FASE 2 (Backend Economic Indicators)\n * @updated 2025-11-21 - Migrado de BRAPI para API do Banco Central (gratuita)\n */\n@Injectable()\nexport class BrapiService {\n  private readonly logger = new Logger(BrapiService.name);\n  private readonly bcbBaseUrl = 'https://api.bcb.gov.br/dados/serie/bcdata.sgs';\n  private readonly requestTimeout = 10000; // 10s timeout\n  private readonly apiKey: string; // Mantido para compatibilidade futura\n\n  constructor(\n    private readonly httpService: HttpService,\n    private readonly configService: ConfigService,\n  ) {\n    this.apiKey = this.configService.get<string>('BRAPI_API_KEY', '');\n    if (!this.apiKey) {\n      this.logger.warn(\n        'ÔÜá´©Å BRAPI_API_KEY not configured - some endpoints may require authentication',\n      );\n    }\n  }\n\n  /**\n   * Get request config with API Key as query parameter\n   * @private\n   */\n  private getRequestConfig(): { params: Record<string, string> } {\n    return this.apiKey ? { params: { token: this.apiKey } } : { params: {} };\n  }\n\n  /**\n   * Get SELIC rate (Taxa b├ísica de juros - Banco Central)\n   * S├®rie 11: Taxa SELIC di├íria\n   * @returns { value: 0.055131, date: Date(2025-11-19) }\n   */\n  async getSelic(): Promise<{ value: number; date: Date }> {\n    try {\n      this.logger.log('Fetching SELIC rate from Banco Central API...');\n\n      // BCB API: ├║ltimos 1 registro da s├®rie 11 (SELIC)\n      const response = await firstValueFrom(\n        this.httpService\n          .get(`${this.bcbBaseUrl}.11/dados/ultimos/1`, {\n            params: { formato: 'json' },\n          })\n          .pipe(\n            timeout(this.requestTimeout),\n            catchError((error) => {\n              this.logger.error(`Banco Central API error: ${error.message}`);\n              throw new HttpException(\n                `Failed to fetch SELIC rate: ${error.message}`,\n                HttpStatus.BAD_GATEWAY,\n              );\n            }),\n          ),\n      );\n\n      // BCB response format: [{ \"data\": \"19/11/2025\", \"valor\": \"0.055131\" }]\n      const selicData = response.data?.[0];\n\n      if (!selicData) {\n        throw new HttpException(\n          'Invalid response format from Banco Central API',\n          HttpStatus.INTERNAL_SERVER_ERROR,\n        );\n      }\n\n      const value = parseFloat(selicData.valor);\n      const date = parseBCBDate(selicData.data); // Parse DD/MM/YYYY to Date\n\n      this.logger.log(`SELIC fetched: ${value}% (ref: ${date.toISOString().split('T')[0]})`);\n\n      return { value, date };\n    } catch (error) {\n      this.logger.error(`getSelic failed: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Get IPCA inflation rate (Infla├º├úo - IBGE via Banco Central)\n   * S├®rie 433: IPCA mensal\n   * @param country Par├ómetro mantido para compatibilidade (n├úo utilizado)\n   * @returns { value: 0.09, date: Date(2025-10-01) }\n   */\n  async getInflation(country: string = 'brazil'): Promise<{ value: number; date: Date }> {\n    try {\n      this.logger.log(`Fetching IPCA inflation from Banco Central API...`);\n\n      // BCB API: ├║ltimos 1 registro da s├®rie 433 (IPCA)\n      const response = await firstValueFrom(\n        this.httpService\n          .get(`${this.bcbBaseUrl}.433/dados/ultimos/1`, {\n            params: { formato: 'json' },\n          })\n          .pipe(\n            timeout(this.requestTimeout),\n            catchError((error) => {\n              this.logger.error(`Banco Central API error: ${error.message}`);\n              throw new HttpException(\n                `Failed to fetch inflation rate: ${error.message}`,\n                HttpStatus.BAD_GATEWAY,\n              );\n            }),\n          ),\n      );\n\n      // BCB response format: [{ \"data\": \"01/10/2025\", \"valor\": \"0.09\" }]\n      const ipcaData = response.data?.[0];\n\n      if (!ipcaData) {\n        throw new HttpException(\n          'Invalid response format from Banco Central API',\n          HttpStatus.INTERNAL_SERVER_ERROR,\n        );\n      }\n\n      const value = parseFloat(ipcaData.valor);\n      const date = parseBCBDate(ipcaData.data); // Parse DD/MM/YYYY to Date\n\n      this.logger.log(`IPCA fetched: ${value}% (ref: ${date.toISOString().split('T')[0]})`);\n\n      return { value, date };\n    } catch (error) {\n      this.logger.error(`getInflation failed: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Get CDI rate (Certificado de Dep├│sito Interbanc├írio)\n   * BRAPI n├úo tem endpoint p├║blico para CDI, ent├úo retornamos mock baseado em SELIC\n   * CDI geralmente fica ~0.10% abaixo da SELIC\n   *\n   * @returns { value: -0.0449, date: Date(2025-11-19) }\n   */\n  async getCDI(): Promise<{ value: number; date: Date }> {\n    try {\n      this.logger.log('Calculating CDI based on SELIC (BRAPI does not have CDI endpoint)');\n\n      // Buscar SELIC e calcular CDI aproximado\n      const selic = await this.getSelic();\n      const cdiValue = parseFloat((selic.value - 0.1).toFixed(4)); // CDI ~0.10% menor que SELIC\n\n      this.logger.log(`CDI calculated: ${cdiValue}% (based on SELIC ${selic.value}%)`);\n\n      return {\n        value: cdiValue,\n        date: selic.date,\n      };\n    } catch (error) {\n      this.logger.error(`getCDI failed: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Health check: Verifica se Banco Central API est├í acess├¡vel\n   */\n  async healthCheck(): Promise<boolean> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService\n          .get(`${this.bcbBaseUrl}.11/dados/ultimos/1`, {\n            params: { formato: 'json' },\n          })\n          .pipe(\n            timeout(5000),\n            catchError(() => {\n              throw new Error('Banco Central API is not accessible');\n            }),\n          ),\n      );\n\n      return response.status === 200 && Array.isArray(response.data) && response.data.length > 0;\n    } catch (error) {\n      this.logger.error(`Banco Central API health check failed: ${error.message}`);\n      return false;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\modules\\cron\\cron.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\modules\\cron\\cron.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\modules\\cron\\cron.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CronExpression' is defined but never used.","line":2,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport { MarketDataService } from '../../api/market-data/market-data.service';\n\n/**\n * Service responsible for scheduled tasks (cron jobs)\n *\n * FASE 34.3: Daily COTAHIST Sync\n * - Executes Monday-Friday at 8:00 AM (America/Sao_Paulo)\n * - Syncs top 5 liquid tickers (ABEV3, VALE3, PETR4, ITUB4, BBDC4)\n * - Current year only (historical data already synced)\n * - Graceful error handling (logs failures, continues execution)\n *\n * Benefits:\n * - Automated daily updates (no manual intervention)\n * - Fresh data for analysis and portfolios\n * - Redis cache ensures fast repeated syncs\n */\n@Injectable()\nexport class CronService {\n  private readonly logger = new Logger(CronService.name);\n\n  // Top 5 most liquid B3 tickers (active daily sync)\n  private readonly activeTickers = [\n    'ABEV3', // Ambev\n    'VALE3', // Vale\n    'PETR4', // Petrobras PN\n    'ITUB4', // Ita├║ Unibanco PN\n    'BBDC4', // Bradesco PN\n  ];\n\n  constructor(private readonly marketDataService: MarketDataService) {}\n\n  /**\n   * Daily COTAHIST sync for active tickers\n   *\n   * Schedule: Monday-Friday at 8:00 AM (after B3 market close)\n   * Cron Expression: '0 8 * * 1-5'\n   * - Minute: 0\n   * - Hour: 8\n   * - Day of month: * (every day)\n   * - Month: * (every month)\n   * - Day of week: 1-5 (Monday-Friday)\n   *\n   * Strategy:\n   * 1. Get current year\n   * 2. Sync each ticker for current year only\n   * 3. Log success/failure per ticker\n   * 4. Continue on errors (partial success allowed)\n   *\n   * Performance:\n   * - With Redis cache: ~1s/ticker (cached COTAHIST ZIP)\n   * - Without cache: ~45s/ticker (FTP download + parsing)\n   * - Total: ~5s (with cache) or ~3min (without cache)\n   */\n  @Cron('0 8 * * 1-5', {\n    name: 'daily-cotahist-sync',\n    timeZone: 'America/Sao_Paulo',\n  })\n  async handleDailyCotahistSync() {\n    const startTime = Date.now();\n    this.logger.log('­ƒÜÇ Starting daily COTAHIST sync...');\n\n    const currentYear = new Date().getFullYear();\n    let successCount = 0;\n    let failureCount = 0;\n\n    for (const ticker of this.activeTickers) {\n      try {\n        this.logger.log(`ÔÅ│ Syncing ${ticker} for ${currentYear}...`);\n\n        await this.marketDataService.syncHistoricalDataFromCotahist(\n          ticker,\n          currentYear,\n          currentYear,\n        );\n\n        successCount++;\n        this.logger.log(`Ô£à Synced ${ticker} for ${currentYear}`);\n      } catch (error: any) {\n        failureCount++;\n        this.logger.error(`ÔØî Failed to sync ${ticker}: ${error.message}`);\n\n        // Continue with next ticker (partial success allowed)\n        continue;\n      }\n    }\n\n    const duration = Date.now() - startTime;\n    const totalTickers = this.activeTickers.length;\n    const successRate = ((successCount / totalTickers) * 100).toFixed(1);\n\n    this.logger.log(\n      `­ƒÄ» Daily COTAHIST sync completed: ${successCount}/${totalTickers} (${successRate}%) in ${duration}ms`,\n    );\n\n    // Alert if failure rate > 20%\n    if (failureCount / totalTickers > 0.2) {\n      this.logger.warn(`ÔÜá´©Å High failure rate: ${failureCount}/${totalTickers} tickers failed`);\n    }\n  }\n\n  /**\n   * Manual trigger for testing/debugging\n   * Can be called via endpoint POST /api/v1/cron/trigger-daily-sync\n   *\n   * @returns Sync result summary\n   */\n  async triggerDailySyncManually(): Promise<{\n    success: boolean;\n    message: string;\n    details: {\n      successCount: number;\n      failureCount: number;\n      totalTickers: number;\n      duration: number;\n    };\n  }> {\n    const startTime = Date.now();\n    this.logger.log('­ƒöº Manual trigger: Starting COTAHIST sync...');\n\n    const currentYear = new Date().getFullYear();\n    let successCount = 0;\n    let failureCount = 0;\n\n    for (const ticker of this.activeTickers) {\n      try {\n        await this.marketDataService.syncHistoricalDataFromCotahist(\n          ticker,\n          currentYear,\n          currentYear,\n        );\n        successCount++;\n      } catch (error: any) {\n        failureCount++;\n        this.logger.error(`Failed to sync ${ticker}: ${error.message}`);\n      }\n    }\n\n    const duration = Date.now() - startTime;\n    const totalTickers = this.activeTickers.length;\n\n    return {\n      success: failureCount === 0,\n      message: `Synced ${successCount}/${totalTickers} tickers in ${duration}ms`,\n      details: {\n        successCount,\n        failureCount,\n        totalTickers,\n        duration,\n      },\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\modules\\redis\\redis.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\queue\\jobs\\asset-update-jobs.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\queue\\jobs\\scheduled-jobs.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\queue\\processors\\asset-update.processor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\queue\\processors\\scraping.processor.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'result' is defined but never used.","line":35,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":49}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Processor, Process, OnQueueActive, OnQueueCompleted, OnQueueFailed } from '@nestjs/bull';\nimport { Logger } from '@nestjs/common';\nimport { Job } from 'bull';\nimport { ScrapersService } from '@scrapers/scrapers.service';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Asset, AssetType, ScrapedData, DataSource } from '@database/entities';\n\nexport interface ScrapingJob {\n  ticker: string;\n  type: 'fundamental' | 'technical' | 'options';\n  sources?: string[];\n}\n\n@Processor('scraping')\nexport class ScrapingProcessor {\n  private readonly logger = new Logger(ScrapingProcessor.name);\n\n  constructor(\n    private scrapersService: ScrapersService,\n    @InjectRepository(Asset)\n    private assetRepository: Repository<Asset>,\n    @InjectRepository(ScrapedData)\n    private scrapedDataRepository: Repository<ScrapedData>,\n    @InjectRepository(DataSource)\n    private dataSourceRepository: Repository<DataSource>,\n  ) {}\n\n  @OnQueueActive()\n  onActive(job: Job<ScrapingJob>) {\n    this.logger.log(`Processing job ${job.id} for ${job.data.ticker} (${job.data.type})`);\n  }\n\n  @OnQueueCompleted()\n  onCompleted(job: Job<ScrapingJob>, result: any) {\n    this.logger.log(`Job ${job.id} completed for ${job.data.ticker}`);\n  }\n\n  @OnQueueFailed()\n  onFailed(job: Job<ScrapingJob>, error: Error) {\n    this.logger.error(`Job ${job.id} failed for ${job.data.ticker}: ${error.message}`);\n  }\n\n  @Process('fundamental')\n  async processFundamentalScraping(job: Job<ScrapingJob>) {\n    const { ticker } = job.data;\n\n    try {\n      this.logger.log(`Scraping fundamental data for ${ticker}`);\n\n      // Get or create asset\n      let asset = await this.assetRepository.findOne({\n        where: { ticker: ticker.toUpperCase() },\n      });\n\n      if (!asset) {\n        asset = await this.assetRepository.save({\n          ticker: ticker.toUpperCase(),\n          name: ticker.toUpperCase(),\n          type: AssetType.STOCK,\n          isActive: true,\n        });\n      }\n\n      // Scrape from multiple sources\n      const result = await this.scrapersService.scrapeFundamentalData(ticker);\n\n      // Save scraped data\n      if (result.isValid && result.data) {\n        for (const source of result.sources) {\n          const dataSource = await this.dataSourceRepository.findOne({\n            where: { code: source },\n          });\n\n          if (dataSource) {\n            await this.scrapedDataRepository.save({\n              assetId: asset.id,\n              dataSourceId: dataSource.id,\n              dataType: 'fundamental',\n              data: result.data,\n              scrapedAt: new Date(),\n              isValid: true,\n            });\n\n            // Update data source stats\n            dataSource.lastSuccessAt = new Date();\n            dataSource.successCount += 1;\n            await this.dataSourceRepository.save(dataSource);\n          }\n        }\n      }\n\n      return {\n        success: true,\n        ticker,\n        sourcesCount: result.sourcesCount,\n        confidence: result.confidence,\n      };\n    } catch (error) {\n      this.logger.error(`Failed to scrape fundamental data for ${ticker}: ${error.message}`);\n      throw error;\n    }\n  }\n\n  @Process('options')\n  async processOptionsScraping(job: Job<ScrapingJob>) {\n    const { ticker } = job.data;\n\n    try {\n      this.logger.log(`Scraping options data for ${ticker}`);\n\n      const asset = await this.assetRepository.findOne({\n        where: { ticker: ticker.toUpperCase() },\n      });\n\n      if (!asset) {\n        throw new Error(`Asset ${ticker} not found`);\n      }\n\n      // Scrape options data\n      const result = await this.scrapersService.scrapeOptionsData(ticker);\n\n      if (result.success && result.data) {\n        const dataSource = await this.dataSourceRepository.findOne({\n          where: { code: 'opcoes' },\n        });\n\n        if (dataSource) {\n          await this.scrapedDataRepository.save({\n            assetId: asset.id,\n            dataSourceId: dataSource.id,\n            dataType: 'options',\n            data: result.data,\n            scrapedAt: new Date(),\n            isValid: true,\n          });\n\n          dataSource.lastSuccessAt = new Date();\n          dataSource.successCount += 1;\n          await this.dataSourceRepository.save(dataSource);\n        }\n      }\n\n      return {\n        success: true,\n        ticker,\n      };\n    } catch (error) {\n      this.logger.error(`Failed to scrape options data for ${ticker}: ${error.message}`);\n      throw error;\n    }\n  }\n\n  @Process('bulk-scraping')\n  async processBulkScraping(job: Job<{ tickers: string[] }>) {\n    const { tickers } = job.data;\n\n    this.logger.log(`Processing bulk scraping for ${tickers.length} tickers`);\n\n    const results = [];\n\n    for (const ticker of tickers) {\n      try {\n        await this.processFundamentalScraping({\n          data: { ticker, type: 'fundamental' },\n        } as Job<ScrapingJob>);\n\n        results.push({ ticker, success: true });\n      } catch (error) {\n        results.push({ ticker, success: false, error: error.message });\n      }\n\n      // Wait a bit between requests to avoid rate limiting\n      await new Promise((resolve) => setTimeout(resolve, 2000));\n    }\n\n    return {\n      total: tickers.length,\n      successful: results.filter((r) => r.success).length,\n      failed: results.filter((r) => !r.success).length,\n      results,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\queue\\queue.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\auth\\google-auth.helper.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":193,"column":18,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":193,"endColumn":31},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":206,"column":18,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":206,"endColumn":31}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Page } from 'puppeteer';\nimport { Logger } from '@nestjs/common';\n\nexport class GoogleAuthHelper {\n  private static readonly logger = new Logger(GoogleAuthHelper.name);\n\n  /**\n   * Performs Google login on a page\n   */\n  static async loginWithGoogle(\n    page: Page,\n    email: string,\n    password: string,\n    loginButtonSelector: string = 'button:contains(\"Google\"), a:contains(\"Google\")',\n  ): Promise<void> {\n    try {\n      this.logger.log('Starting Google login process');\n\n      // Click on \"Login with Google\" button\n      await page.waitForSelector(loginButtonSelector, { timeout: 10000 }).catch(() => {\n        this.logger.warn('Google login button not found with default selector');\n      });\n\n      // Try different common selectors for Google login button\n      const googleButtonSelectors = [\n        loginButtonSelector,\n        'button[data-provider=\"google\"]',\n        'a[href*=\"google\"]',\n        '.google-login',\n        '#google-login',\n        '[aria-label*=\"Google\"]',\n      ];\n\n      let buttonClicked = false;\n      for (const selector of googleButtonSelectors) {\n        try {\n          const button = await page.$(selector);\n          if (button) {\n            await button.click();\n            buttonClicked = true;\n            break;\n          }\n        } catch (e) {\n          continue;\n        }\n      }\n\n      if (!buttonClicked) {\n        throw new Error('Could not find Google login button');\n      }\n\n      // Wait for Google login page\n      await page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 10000 }).catch(() => {});\n\n      // Wait for email input\n      await page.waitForSelector('input[type=\"email\"]', { timeout: 10000 });\n\n      // Enter email\n      await page.type('input[type=\"email\"]', email, { delay: 100 });\n      this.logger.log('Email entered');\n\n      // Click \"Next\" button\n      await this.clickNextButton(page);\n\n      // Wait for password input\n      await page.waitForSelector('input[type=\"password\"]', { timeout: 10000 });\n      await this.wait(1000);\n\n      // Enter password\n      await page.type('input[type=\"password\"]', password, { delay: 100 });\n      this.logger.log('Password entered');\n\n      // Click \"Next\" button\n      await this.clickNextButton(page);\n\n      // Wait for navigation after login\n      await page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 30000 }).catch(() => {\n        this.logger.warn('Navigation timeout after login');\n      });\n\n      // Handle 2FA or additional verification if present\n      await this.handle2FA(page);\n\n      this.logger.log('Google login completed');\n    } catch (error) {\n      this.logger.error(`Google login failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Click the \"Next\" button on Google login page\n   */\n  private static async clickNextButton(page: Page): Promise<void> {\n    const nextButtonSelectors = [\n      '#identifierNext button',\n      '#passwordNext button',\n      'button:contains(\"Next\")',\n      'button:contains(\"Pr├│xima\")',\n      '[type=\"button\"][jsname]',\n    ];\n\n    for (const selector of nextButtonSelectors) {\n      try {\n        const button = await page.$(selector);\n        if (button) {\n          await button.click();\n          await this.wait(2000);\n          return;\n        }\n      } catch (e) {\n        continue;\n      }\n    }\n\n    // Fallback: press Enter\n    await page.keyboard.press('Enter');\n    await this.wait(2000);\n  }\n\n  /**\n   * Handle 2FA if present\n   */\n  private static async handle2FA(page: Page): Promise<void> {\n    try {\n      // Check if 2FA is required\n      const has2FA = await page.$('input[type=\"tel\"]').catch(() => null);\n\n      if (has2FA) {\n        this.logger.warn('2FA detected - manual intervention required');\n        this.logger.warn('Please complete 2FA verification manually');\n\n        // Wait for manual 2FA completion (up to 2 minutes)\n        await page\n          .waitForNavigation({\n            waitUntil: 'networkidle2',\n            timeout: 120000,\n          })\n          .catch(() => {\n            this.logger.warn('2FA timeout - user may still be completing verification');\n          });\n      }\n    } catch (error) {\n      this.logger.warn(`2FA check failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Check if already logged in to Google\n   */\n  static async isLoggedIn(page: Page): Promise<boolean> {\n    try {\n      // Check for common indicators of being logged in\n      const loggedInSelectors = [\n        '.user-profile',\n        '[data-user]',\n        '.account-info',\n        'img[alt*=\"Profile\"]',\n      ];\n\n      for (const selector of loggedInSelectors) {\n        const element = await page.$(selector).catch(() => null);\n        if (element) {\n          return true;\n        }\n      }\n\n      // Check URL\n      const url = page.url();\n      if (url.includes('accounts.google.com')) {\n        return false;\n      }\n\n      return false;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Wait helper\n   */\n  private static async wait(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Save Google session cookies for reuse\n   */\n  static async saveSession(page: Page, filePath: string): Promise<void> {\n    try {\n      const cookies = await page.cookies();\n      const fs = require('fs');\n      fs.writeFileSync(filePath, JSON.stringify(cookies, null, 2));\n      this.logger.log(`Session saved to ${filePath}`);\n    } catch (error) {\n      this.logger.error(`Failed to save session: ${error.message}`);\n    }\n  }\n\n  /**\n   * Load Google session cookies\n   */\n  static async loadSession(page: Page, filePath: string): Promise<boolean> {\n    try {\n      const fs = require('fs');\n      if (!fs.existsSync(filePath)) {\n        return false;\n      }\n\n      const cookiesString = fs.readFileSync(filePath, 'utf8');\n      const cookies = JSON.parse(cookiesString);\n      await page.setCookie(...cookies);\n      this.logger.log(`Session loaded from ${filePath}`);\n      return true;\n    } catch (error) {\n      this.logger.error(`Failed to load session: ${error.message}`);\n      return false;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\base\\abstract-scraper.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'puppeteer' is defined but never used.","line":3,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Logger } from '@nestjs/common';\nimport { BaseScraper, ScraperConfig, ScraperResult } from './base-scraper.interface';\nimport puppeteer, { Browser, Page } from 'puppeteer';\nimport * as puppeteerExtra from 'puppeteer-extra';\nimport StealthPlugin from 'puppeteer-extra-plugin-stealth';\n\n// Use stealth plugin to avoid detection\npuppeteerExtra.default.use(StealthPlugin());\n\nexport abstract class AbstractScraper<T = any> implements BaseScraper<T> {\n  protected readonly logger: Logger;\n  protected browser: Browser | null = null;\n  protected page: Page | null = null;\n  protected config: ScraperConfig;\n\n  abstract readonly name: string;\n  abstract readonly source: string;\n  abstract readonly requiresLogin: boolean;\n\n  constructor(config?: ScraperConfig) {\n    this.logger = new Logger(this.constructor.name);\n    this.config = {\n      timeout: 60000, // Aumentado de 30s para 60s para evitar timeouts\n      retries: 3,\n      headless: true,\n      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n      ...config,\n    };\n  }\n\n  async initialize(): Promise<void> {\n    try {\n      this.logger.log(`Initializing scraper: ${this.name}`);\n\n      this.browser = await puppeteerExtra.default.launch({\n        headless: this.config.headless,\n        protocolTimeout: 60000, // Timeout para opera├º├Áes do protocolo CDP\n        args: [\n          '--no-sandbox',\n          '--disable-setuid-sandbox',\n          '--disable-dev-shm-usage',\n          '--disable-accelerated-2d-canvas',\n          '--disable-gpu',\n          '--window-size=1920x1080',\n        ],\n      });\n\n      this.page = await this.browser.newPage();\n      await this.page.setUserAgent(this.config.userAgent);\n      await this.page.setViewport({ width: 1920, height: 1080 });\n      this.page.setDefaultNavigationTimeout(60000); // Timeout padr├úo para navega├º├úo\n\n      if (this.requiresLogin) {\n        await this.login();\n      }\n\n      this.logger.log(`Scraper initialized: ${this.name}`);\n    } catch (error) {\n      this.logger.error(`Failed to initialize scraper: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async cleanup(): Promise<void> {\n    try {\n      if (this.page) {\n        await this.page.close();\n        this.page = null;\n      }\n      if (this.browser) {\n        await this.browser.close();\n        this.browser = null;\n      }\n      this.logger.log(`Scraper cleaned up: ${this.name}`);\n    } catch (error) {\n      this.logger.error(`Failed to cleanup scraper: ${error.message}`);\n    }\n  }\n\n  async scrape(ticker: string): Promise<ScraperResult<T>> {\n    const startTime = Date.now();\n\n    try {\n      this.logger.log(`Scraping ${ticker} from ${this.source}`);\n\n      if (!this.page) {\n        await this.initialize();\n      }\n\n      const data = await this.scrapeData(ticker);\n\n      if (this.validate && !this.validate(data)) {\n        throw new Error('Data validation failed');\n      }\n\n      const responseTime = Date.now() - startTime;\n\n      this.logger.log(`Successfully scraped ${ticker} from ${this.source} in ${responseTime}ms`);\n\n      return {\n        success: true,\n        data,\n        source: this.source,\n        timestamp: new Date(),\n        responseTime,\n      };\n    } catch (error) {\n      const responseTime = Date.now() - startTime;\n      this.logger.error(`Failed to scrape ${ticker} from ${this.source}: ${error.message}`);\n\n      return {\n        success: false,\n        error: error.message,\n        source: this.source,\n        timestamp: new Date(),\n        responseTime,\n      };\n    }\n  }\n\n  /**\n   * Login to the data source (if required)\n   * Override this method in child classes\n   */\n  protected async login(): Promise<void> {\n    // Override in child classes\n  }\n\n  /**\n   * Scrape data for a specific ticker\n   * Must be implemented by child classes\n   */\n  protected abstract scrapeData(ticker: string): Promise<T>;\n\n  /**\n   * Validate scraped data\n   * Override in child classes for custom validation\n   */\n  validate?(data: T): boolean;\n\n  /**\n   * Wait for a specific amount of time\n   */\n  protected async wait(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Retry a function with exponential backoff\n   */\n  protected async retry<R>(\n    fn: () => Promise<R>,\n    retries: number = this.config.retries,\n  ): Promise<R> {\n    try {\n      return await fn();\n    } catch (error) {\n      if (retries <= 0) {\n        throw error;\n      }\n      const delay = Math.pow(2, this.config.retries - retries) * 1000;\n      this.logger.warn(`Retrying in ${delay}ms... (${retries} retries left)`);\n      await this.wait(delay);\n      return this.retry(fn, retries - 1);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\base\\base-scraper.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\fundamental\\brapi.scraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\fundamental\\fundamentei.scraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\fundamental\\fundamentus.scraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\fundamental\\investidor10.scraper.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getValueByLabel' is assigned a value but never used.","line":90,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":90,"endColumn":26}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { AbstractScraper } from '../base/abstract-scraper';\nimport * as cheerio from 'cheerio';\n\nexport interface Investidor10Data {\n  ticker: string;\n  companyName: string;\n  price: number;\n  minPrice52w: number;\n  maxPrice52w: number;\n  volume: number;\n  valorMercado: number;\n  valorFirma: number;\n  numeroAcoes: number;\n\n  // Valuation\n  pl: number;\n  pvp: number;\n  psr: number;\n  pAtivos: number;\n  pCapitalGiro: number;\n  pEbit: number;\n  pAtivosCircLiq: number;\n  evEbit: number;\n  evEbitda: number;\n  pegRatio: number;\n\n  // Dividends\n  dy: number;\n  payout: number;\n\n  // Profitability\n  margemBruta: number;\n  margemEbit: number;\n  margemLiquida: number;\n  roe: number;\n  roa: number;\n  roic: number;\n  giroAtivos: number;\n\n  // Debt\n  dividaLiquidaPL: number;\n  dividaLiquidaEbit: number;\n  plSobreAtivos: number;\n  passivosAtivos: number;\n  liquidezCorrente: number;\n\n  // Growth\n  cagr5anos: number;\n\n  // Financial Data\n  receitaLiquida: number;\n  ebit: number;\n  lucroLiquido: number;\n}\n\n@Injectable()\nexport class Investidor10Scraper extends AbstractScraper<Investidor10Data> {\n  readonly name = 'Investidor10 Scraper';\n  readonly source = 'investidor10';\n  readonly requiresLogin = false;\n\n  protected async scrapeData(ticker: string): Promise<Investidor10Data> {\n    const url = `https://investidor10.com.br/acoes/${ticker.toLowerCase()}/`;\n\n    await this.page.goto(url, { waitUntil: 'networkidle2', timeout: this.config.timeout });\n\n    // Wait for main content\n    await this.page.waitForSelector('._card', { timeout: 10000 }).catch(() => {});\n\n    const content = await this.page.content();\n    const $ = cheerio.load(content);\n\n    const cleanValue = (text: string): number => {\n      if (!text) return 0;\n\n      text = text\n        .replace(/\\./g, '')\n        .replace(',', '.')\n        .replace('%', '')\n        .replace('R$', '')\n        .replace(/\\s/g, '')\n        .replace(/[^\\d.-]/g, '')\n        .trim();\n\n      const num = parseFloat(text);\n      return isNaN(num) ? 0 : num;\n    };\n\n    const getValueByLabel = (label: string): number => {\n      const element = $(`.info ._card:contains(\"${label}\")`).find('._card-body span').first();\n      return cleanValue(element.text());\n    };\n\n    const getIndicatorValue = (label: string): number => {\n      let value = 0;\n\n      // Try different selectors\n      $('._card-header').each((i, elem) => {\n        if ($(elem).text().includes(label)) {\n          value = cleanValue($(elem).next('._card-body').find('span').first().text());\n          return false; // break\n        }\n      });\n\n      if (value === 0) {\n        value = cleanValue($(`td:contains(\"${label}\")`).next('td').text());\n      }\n\n      return value;\n    };\n\n    // Get company name and price\n    const companyName =\n      $('.symbol-name').text().trim() || $('h1').first().text().trim() || ticker.toUpperCase();\n\n    const priceText =\n      $('.cotacao').text() || $('.value').first().text() || $('[data-type=\"price\"]').text();\n    const price = cleanValue(priceText);\n\n    const data: Investidor10Data = {\n      ticker: ticker.toUpperCase(),\n      companyName,\n      price,\n\n      // Price range\n      minPrice52w: getIndicatorValue('M├¡nima 52 sem') || getIndicatorValue('Min 52'),\n      maxPrice52w: getIndicatorValue('M├íxima 52 sem') || getIndicatorValue('Max 52'),\n      volume: getIndicatorValue('Volume') || getIndicatorValue('Vol. M├®dio'),\n\n      // Market data\n      valorMercado: getIndicatorValue('Valor de mercado') || getIndicatorValue('Val. Mercado'),\n      valorFirma: getIndicatorValue('Valor da firma') || getIndicatorValue('Enterprise Value'),\n      numeroAcoes: getIndicatorValue('Nro. A├º├Áes') || getIndicatorValue('A├º├Áes'),\n\n      // Valuation\n      pl: getIndicatorValue('P/L') || getIndicatorValue('Pre├ºo/Lucro'),\n      pvp: getIndicatorValue('P/VP') || getIndicatorValue('Pre├ºo/VPA'),\n      psr: getIndicatorValue('PSR') || getIndicatorValue('P/Receita'),\n      pAtivos: getIndicatorValue('P/Ativos') || getIndicatorValue('P/Ativo'),\n      pCapitalGiro: getIndicatorValue('P/Cap. Giro') || getIndicatorValue('P/Capital de Giro'),\n      pEbit: getIndicatorValue('P/EBIT'),\n      pAtivosCircLiq: getIndicatorValue('P/Ativ Circ Liq') || getIndicatorValue('P/ACL'),\n      evEbit: getIndicatorValue('EV/EBIT') || getIndicatorValue('EV / EBIT'),\n      evEbitda: getIndicatorValue('EV/EBITDA') || getIndicatorValue('EV / EBITDA'),\n      pegRatio: getIndicatorValue('PEG Ratio') || getIndicatorValue('PEG'),\n\n      // Dividends\n      dy: getIndicatorValue('Div. Yield') || getIndicatorValue('DY'),\n      payout: getIndicatorValue('Payout'),\n\n      // Profitability\n      margemBruta: getIndicatorValue('Margem Bruta') || getIndicatorValue('M. Bruta'),\n      margemEbit: getIndicatorValue('Margem EBIT') || getIndicatorValue('M. EBIT'),\n      margemLiquida: getIndicatorValue('Margem L├¡quida') || getIndicatorValue('M. L├¡quida'),\n      roe: getIndicatorValue('ROE'),\n      roa: getIndicatorValue('ROA'),\n      roic: getIndicatorValue('ROIC'),\n      giroAtivos: getIndicatorValue('Giro Ativos'),\n\n      // Debt\n      dividaLiquidaPL: getIndicatorValue('D├¡v. L├¡q./PL') || getIndicatorValue('D├¡v Liq/Pat'),\n      dividaLiquidaEbit: getIndicatorValue('D├¡v. L├¡q./EBIT') || getIndicatorValue('D├¡v Liq/EBIT'),\n      plSobreAtivos: getIndicatorValue('PL/Ativos') || getIndicatorValue('Pat Liq/Ativos'),\n      passivosAtivos: getIndicatorValue('Passivos/Ativos') || getIndicatorValue('Pass/Ativos'),\n      liquidezCorrente:\n        getIndicatorValue('Liquidez Corrente') || getIndicatorValue('Liq. Corrente'),\n\n      // Growth\n      cagr5anos: getIndicatorValue('CAGR Receitas 5 anos') || getIndicatorValue('CAGR 5a'),\n\n      // Financial Data\n      receitaLiquida: getIndicatorValue('Receita L├¡quida') || getIndicatorValue('Rec. L├¡quida'),\n      ebit: getIndicatorValue('EBIT'),\n      lucroLiquido: getIndicatorValue('Lucro L├¡quido') || getIndicatorValue('Lucro Liq'),\n    };\n\n    return data;\n  }\n\n  validate(data: Investidor10Data): boolean {\n    return data.ticker !== '' && (data.price > 0 || data.pl !== 0 || data.pvp !== 0);\n  }\n\n  protected async login(): Promise<void> {\n    this.logger.log('Investidor10 scraper running without login');\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\fundamental\\investsite.scraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\fundamental\\statusinvest.scraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\news\\google-news.scraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\news\\valor.scraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\options\\opcoes.scraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\scraper-metrics.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\scrapers.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\scrapers.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\scrapers\\scrapers.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\validators\\validators.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\validators\\validators.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":7,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'data' is defined but never used.","line":12,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":30}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\n\n@Injectable()\nexport class ValidatorsService {\n  private readonly logger = new Logger(ValidatorsService.name);\n\n  validateFundamentalData(data: any): boolean {\n    // TODO: Implement fundamental data validation\n    return true;\n  }\n\n  validatePriceData(data: any): boolean {\n    // TODO: Implement price data validation\n    return true;\n  }\n\n  crossValidateData(sources: any[]): any {\n    this.logger.log(`Cross-validating data from ${sources.length} sources`);\n    // TODO: Implement cross-validation logic\n    return { isValid: true, confidence: 0.95 };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\websocket\\websocket.gateway.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\src\\websocket\\websocket.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\test\\analysis.e2e-spec.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/test\\analysis.e2e-spec.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Test, TestingModule } from '@nestjs/testing';\r\nimport { INestApplication, ValidationPipe } from '@nestjs/common';\r\nimport request from 'supertest';\r\nimport { AppModule } from '../src/app.module';\r\n\r\ndescribe('Analysis API (E2E)', () => {\r\n  let app: INestApplication;\r\n  let reportId: string;\r\n\r\n  beforeAll(async () => {\r\n    const moduleFixture: TestingModule = await Test.createTestingModule({\r\n      imports: [AppModule],\r\n    }).compile();\r\n\r\n    app = moduleFixture.createNestApplication();\r\n    app.useGlobalPipes(new ValidationPipe({ transform: true, whitelist: true }));\r\n    await app.init();\r\n  });\r\n\r\n  afterAll(async () => {\r\n    await app.close();\r\n  });\r\n\r\n  describe('/api/analysis/generate (POST)', () => {\r\n    it('should generate analysis for a ticker', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/analysis/generate')\r\n        .send({ ticker: 'PETR4' })\r\n        .expect((res) => {\r\n          expect([200, 201, 202, 401]).toContain(res.status);\r\n          if (res.status === 201 || res.status === 202) {\r\n            expect(res.body).toHaveProperty('id');\r\n            expect(res.body).toHaveProperty('ticker', 'PETR4');\r\n            reportId = res.body.id;\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should validate ticker', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/analysis/generate')\r\n        .send({ ticker: '' })\r\n        .expect((res) => {\r\n          expect([400, 401]).toContain(res.status);\r\n        });\r\n    });\r\n\r\n    it('should handle invalid ticker', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/analysis/generate')\r\n        .send({ ticker: 'INVALID999' })\r\n        .expect((res) => {\r\n          expect([400, 404, 401]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/analysis/reports (GET)', () => {\r\n    it('should return list of reports', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/analysis/reports')\r\n        .expect((res) => {\r\n          expect([200, 401]).toContain(res.status);\r\n          if (res.status === 200) {\r\n            expect(Array.isArray(res.body)).toBe(true);\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should filter by ticker', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/analysis/reports?ticker=PETR4')\r\n        .expect((res) => {\r\n          expect([200, 401]).toContain(res.status);\r\n        });\r\n    });\r\n\r\n    it('should paginate results', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/analysis/reports?page=1&limit=10')\r\n        .expect((res) => {\r\n          expect([200, 401]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/analysis/reports/:id (GET)', () => {\r\n    it('should return report details', () => {\r\n      const testId = reportId || 'test-report-id';\r\n\r\n      return request(app.getHttpServer())\r\n        .get(`/api/analysis/reports/${testId}`)\r\n        .expect((res) => {\r\n          expect([200, 401, 404]).toContain(res.status);\r\n          if (res.status === 200) {\r\n            expect(res.body).toHaveProperty('id');\r\n            expect(res.body).toHaveProperty('ticker');\r\n            expect(res.body).toHaveProperty('recommendation');\r\n            expect(res.body).toHaveProperty('fundamentalAnalysis');\r\n            expect(res.body).toHaveProperty('technicalAnalysis');\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should return 404 for non-existent report', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/analysis/reports/non-existent-id')\r\n        .expect((res) => {\r\n          expect([401, 404]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/analysis/fundamental/:ticker (GET)', () => {\r\n    it('should return fundamental analysis', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/analysis/fundamental/PETR4')\r\n        .expect((res) => {\r\n          expect([200, 401, 404]).toContain(res.status);\r\n          if (res.status === 200) {\r\n            expect(res.body).toHaveProperty('ticker', 'PETR4');\r\n            expect(res.body).toHaveProperty('indicators');\r\n            // ROE, P/L, P/VP, Dividend Yield, etc\r\n            if (res.body.indicators) {\r\n              expect(res.body.indicators).toHaveProperty('roe');\r\n              expect(res.body.indicators).toHaveProperty('pe');\r\n              expect(res.body.indicators).toHaveProperty('pb');\r\n            }\r\n          }\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/analysis/technical/:ticker (GET)', () => {\r\n    it('should return technical analysis', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/analysis/technical/PETR4')\r\n        .expect((res) => {\r\n          expect([200, 401, 404]).toContain(res.status);\r\n          if (res.status === 200) {\r\n            expect(res.body).toHaveProperty('ticker', 'PETR4');\r\n            expect(res.body).toHaveProperty('indicators');\r\n            // RSI, MACD, SMA, EMA, etc\r\n            if (res.body.indicators) {\r\n              expect(res.body.indicators).toHaveProperty('rsi');\r\n              expect(res.body.indicators).toHaveProperty('macd');\r\n            }\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should support different timeframes', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/analysis/technical/PETR4?timeframe=daily')\r\n        .expect((res) => {\r\n          expect([200, 401, 404]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/analysis/ai/:ticker (POST)', () => {\r\n    it('should generate AI analysis', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/analysis/ai/PETR4')\r\n        .send({\r\n          includeNews: true,\r\n          includeSentiment: true,\r\n        })\r\n        .expect((res) => {\r\n          expect([200, 201, 202, 401, 404]).toContain(res.status);\r\n          if (res.status === 200 || res.status === 201) {\r\n            expect(res.body).toHaveProperty('ticker', 'PETR4');\r\n            expect(res.body).toHaveProperty('analysis');\r\n            expect(res.body).toHaveProperty('recommendation');\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should handle AI service errors gracefully', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/analysis/ai/PETR4')\r\n        .send({})\r\n        .expect((res) => {\r\n          expect([200, 201, 202, 401, 404, 500, 503]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/analysis/compare (POST)', () => {\r\n    it('should compare multiple assets', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/analysis/compare')\r\n        .send({\r\n          tickers: ['PETR4', 'VALE3', 'ITUB4'],\r\n          metrics: ['roe', 'pe', 'dividendYield'],\r\n        })\r\n        .expect((res) => {\r\n          expect([200, 401]).toContain(res.status);\r\n          if (res.status === 200) {\r\n            expect(res.body).toHaveProperty('comparison');\r\n            expect(Array.isArray(res.body.comparison)).toBe(true);\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should validate input', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/analysis/compare')\r\n        .send({ tickers: [] })\r\n        .expect((res) => {\r\n          expect([400, 401]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/analysis/alerts (POST)', () => {\r\n    it('should create price alert', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/analysis/alerts')\r\n        .send({\r\n          ticker: 'PETR4',\r\n          type: 'PRICE',\r\n          condition: 'ABOVE',\r\n          value: 40.0,\r\n        })\r\n        .expect((res) => {\r\n          expect([201, 401]).toContain(res.status);\r\n        });\r\n    });\r\n\r\n    it('should create indicator alert', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/analysis/alerts')\r\n        .send({\r\n          ticker: 'PETR4',\r\n          type: 'RSI',\r\n          condition: 'BELOW',\r\n          value: 30,\r\n        })\r\n        .expect((res) => {\r\n          expect([201, 401]).toContain(res.status);\r\n        });\r\n    });\r\n\r\n    it('should validate alert data', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/analysis/alerts')\r\n        .send({\r\n          ticker: 'PETR4',\r\n          type: 'INVALID',\r\n        })\r\n        .expect((res) => {\r\n          expect([400, 401]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/analysis/alerts (GET)', () => {\r\n    it('should return user alerts', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/analysis/alerts')\r\n        .expect((res) => {\r\n          expect([200, 401]).toContain(res.status);\r\n          if (res.status === 200) {\r\n            expect(Array.isArray(res.body)).toBe(true);\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should filter by ticker', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/analysis/alerts?ticker=PETR4')\r\n        .expect((res) => {\r\n          expect([200, 401]).toContain(res.status);\r\n        });\r\n    });\r\n\r\n    it('should filter by status', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/analysis/alerts?status=ACTIVE')\r\n        .expect((res) => {\r\n          expect([200, 401]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\test\\assets.e2e-spec.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/test\\assets.e2e-spec.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Test, TestingModule } from '@nestjs/testing';\r\nimport { INestApplication, ValidationPipe } from '@nestjs/common';\r\nimport * as request from 'supertest';\r\nimport { AppModule } from '../src/app.module';\r\n\r\ndescribe('Assets API (E2E)', () => {\r\n  let app: INestApplication;\r\n  let authToken: string;\r\n\r\n  beforeAll(async () => {\r\n    const moduleFixture: TestingModule = await Test.createTestingModule({\r\n      imports: [AppModule],\r\n    }).compile();\r\n\r\n    app = moduleFixture.createNestApplication();\r\n    app.useGlobalPipes(new ValidationPipe({ transform: true, whitelist: true }));\r\n    await app.init();\r\n\r\n    // TODO: Login para obter token (quando auth estiver implementado)\r\n    // const loginResponse = await request(app.getHttpServer())\r\n    //   .post('/auth/login')\r\n    //   .send({ email: 'test@example.com', password: 'password' });\r\n    // authToken = loginResponse.body.accessToken;\r\n  });\r\n\r\n  afterAll(async () => {\r\n    await app.close();\r\n  });\r\n\r\n  describe('/api/assets (GET)', () => {\r\n    it('should return list of assets', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/assets')\r\n        // .set('Authorization', `Bearer ${authToken}`)\r\n        .expect(200)\r\n        .expect((res) => {\r\n          expect(Array.isArray(res.body)).toBe(true);\r\n          if (res.body.length > 0) {\r\n            expect(res.body[0]).toHaveProperty('ticker');\r\n            expect(res.body[0]).toHaveProperty('name');\r\n            expect(res.body[0]).toHaveProperty('currentPrice');\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should filter assets by search query', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/assets?search=PETR4')\r\n        .expect(200)\r\n        .expect((res) => {\r\n          expect(Array.isArray(res.body)).toBe(true);\r\n          if (res.body.length > 0) {\r\n            expect(res.body[0].ticker).toContain('PETR');\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should filter assets by sector', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/assets?sector=Petr├│leo e G├ís')\r\n        .expect(200)\r\n        .expect((res) => {\r\n          expect(Array.isArray(res.body)).toBe(true);\r\n        });\r\n    });\r\n\r\n    it('should paginate results', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/assets?page=1&limit=10')\r\n        .expect(200)\r\n        .expect((res) => {\r\n          expect(res.body).toHaveProperty('data');\r\n          expect(res.body).toHaveProperty('meta');\r\n          expect(res.body.meta).toHaveProperty('page');\r\n          expect(res.body.meta).toHaveProperty('limit');\r\n          expect(res.body.meta).toHaveProperty('total');\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/assets/:ticker (GET)', () => {\r\n    it('should return asset details', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/assets/PETR4')\r\n        .expect(200)\r\n        .expect((res) => {\r\n          expect(res.body).toHaveProperty('ticker', 'PETR4');\r\n          expect(res.body).toHaveProperty('name');\r\n          expect(res.body).toHaveProperty('currentPrice');\r\n          expect(res.body).toHaveProperty('sector');\r\n        });\r\n    });\r\n\r\n    it('should return 404 for non-existent asset', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/assets/INVALID999')\r\n        .expect(404);\r\n    });\r\n\r\n    it('should validate ticker format', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/assets/invalid')\r\n        .expect((res) => {\r\n          expect([400, 404]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/assets/:ticker/history (GET)', () => {\r\n    it('should return price history', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/assets/PETR4/history')\r\n        .expect(200)\r\n        .expect((res) => {\r\n          expect(Array.isArray(res.body)).toBe(true);\r\n          if (res.body.length > 0) {\r\n            expect(res.body[0]).toHaveProperty('date');\r\n            expect(res.body[0]).toHaveProperty('open');\r\n            expect(res.body[0]).toHaveProperty('high');\r\n            expect(res.body[0]).toHaveProperty('low');\r\n            expect(res.body[0]).toHaveProperty('close');\r\n            expect(res.body[0]).toHaveProperty('volume');\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should filter by date range', () => {\r\n      const startDate = '2024-01-01';\r\n      const endDate = '2024-12-31';\r\n\r\n      return request(app.getHttpServer())\r\n        .get(`/api/assets/PETR4/history?startDate=${startDate}&endDate=${endDate}`)\r\n        .expect(200)\r\n        .expect((res) => {\r\n          expect(Array.isArray(res.body)).toBe(true);\r\n        });\r\n    });\r\n\r\n    it('should limit results', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/assets/PETR4/history?limit=30')\r\n        .expect(200)\r\n        .expect((res) => {\r\n          expect(res.body.length).toBeLessThanOrEqual(30);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/assets/:ticker/indicators (GET)', () => {\r\n    it('should return technical indicators', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/assets/PETR4/indicators')\r\n        .expect(200)\r\n        .expect((res) => {\r\n          expect(res.body).toHaveProperty('rsi');\r\n          expect(res.body).toHaveProperty('macd');\r\n          expect(res.body).toHaveProperty('sma');\r\n          expect(res.body).toHaveProperty('ema');\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/assets/compare (POST)', () => {\r\n    it('should compare multiple assets', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/assets/compare')\r\n        .send({ tickers: ['PETR4', 'VALE3', 'ITUB4'] })\r\n        .expect(200)\r\n        .expect((res) => {\r\n          expect(Array.isArray(res.body)).toBe(true);\r\n          expect(res.body).toHaveLength(3);\r\n        });\r\n    });\r\n\r\n    it('should validate input', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/assets/compare')\r\n        .send({ tickers: [] })\r\n        .expect(400);\r\n    });\r\n\r\n    it('should limit number of tickers', () => {\r\n      const tickers = Array(20).fill('PETR4');\r\n\r\n      return request(app.getHttpServer())\r\n        .post('/api/assets/compare')\r\n        .send({ tickers })\r\n        .expect((res) => {\r\n          expect([400, 200]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\adria\\Dropbox\\PC (2)\\Downloads\\Python - Projetos\\invest-claude-web\\backend\\test\\portfolio.e2e-spec.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/test\\portfolio.e2e-spec.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Test, TestingModule } from '@nestjs/testing';\r\nimport { INestApplication, ValidationPipe } from '@nestjs/common';\r\nimport request from 'supertest';\r\nimport { AppModule } from '../src/app.module';\r\n\r\ndescribe('Portfolio API (E2E)', () => {\r\n  let app: INestApplication;\r\n  let authToken: string;\r\n  let portfolioId: string;\r\n  let positionId: string;\r\n\r\n  beforeAll(async () => {\r\n    const moduleFixture: TestingModule = await Test.createTestingModule({\r\n      imports: [AppModule],\r\n    }).compile();\r\n\r\n    app = moduleFixture.createNestApplication();\r\n    app.useGlobalPipes(new ValidationPipe({ transform: true, whitelist: true }));\r\n    await app.init();\r\n  });\r\n\r\n  afterAll(async () => {\r\n    await app.close();\r\n  });\r\n\r\n  describe('/api/portfolios (GET)', () => {\r\n    it('should return user portfolios', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/portfolios')\r\n        // .set('Authorization', `Bearer ${authToken}`)\r\n        .expect((res) => {\r\n          // Sem auth, pode retornar 401 ou lista vazia\r\n          expect([200, 401]).toContain(res.status);\r\n          if (res.status === 200) {\r\n            expect(Array.isArray(res.body)).toBe(true);\r\n          }\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/portfolios (POST)', () => {\r\n    it('should create a new portfolio', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/portfolios')\r\n        .send({\r\n          name: 'Meu Portf├│lio de Teste',\r\n          description: 'Portf├│lio para testes automatizados',\r\n        })\r\n        .expect((res) => {\r\n          if (res.status === 201) {\r\n            expect(res.body).toHaveProperty('id');\r\n            expect(res.body).toHaveProperty('name');\r\n            portfolioId = res.body.id;\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should validate required fields', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/portfolios')\r\n        .send({})\r\n        .expect((res) => {\r\n          expect([400, 401]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/portfolios/:id (GET)', () => {\r\n    it('should return portfolio details', () => {\r\n      if (!portfolioId) {\r\n        return request(app.getHttpServer())\r\n          .get('/api/portfolios/test-id')\r\n          .expect((res) => {\r\n            expect([200, 401, 404]).toContain(res.status);\r\n          });\r\n      }\r\n\r\n      return request(app.getHttpServer())\r\n        .get(`/api/portfolios/${portfolioId}`)\r\n        .expect((res) => {\r\n          if (res.status === 200) {\r\n            expect(res.body).toHaveProperty('id');\r\n            expect(res.body).toHaveProperty('name');\r\n            expect(res.body).toHaveProperty('positions');\r\n          }\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/portfolios/:id/positions (POST)', () => {\r\n    it('should add a position to portfolio', () => {\r\n      if (!portfolioId) {\r\n        return request(app.getHttpServer())\r\n          .post('/api/portfolios/test-id/positions')\r\n          .send({\r\n            ticker: 'PETR4',\r\n            quantity: 100,\r\n            averagePrice: 38.50,\r\n          })\r\n          .expect((res) => {\r\n            expect([201, 401, 404]).toContain(res.status);\r\n          });\r\n      }\r\n\r\n      return request(app.getHttpServer())\r\n        .post(`/api/portfolios/${portfolioId}/positions`)\r\n        .send({\r\n          ticker: 'PETR4',\r\n          quantity: 100,\r\n          averagePrice: 38.50,\r\n        })\r\n        .expect((res) => {\r\n          if (res.status === 201) {\r\n            expect(res.body).toHaveProperty('id');\r\n            expect(res.body).toHaveProperty('ticker', 'PETR4');\r\n            expect(res.body).toHaveProperty('quantity', 100);\r\n            positionId = res.body.id;\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should validate position data', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/portfolios/test-id/positions')\r\n        .send({\r\n          ticker: 'INVALID',\r\n          quantity: -10,\r\n          averagePrice: -50,\r\n        })\r\n        .expect((res) => {\r\n          expect([400, 401, 404]).toContain(res.status);\r\n        });\r\n    });\r\n\r\n    it('should reject negative quantities', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/portfolios/test-id/positions')\r\n        .send({\r\n          ticker: 'PETR4',\r\n          quantity: -100,\r\n          averagePrice: 38.50,\r\n        })\r\n        .expect((res) => {\r\n          expect([400, 401]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/portfolios/:id/positions/:positionId (PATCH)', () => {\r\n    it('should update position', () => {\r\n      if (!portfolioId || !positionId) {\r\n        return request(app.getHttpServer())\r\n          .patch('/api/portfolios/test-id/positions/test-position-id')\r\n          .send({ quantity: 150 })\r\n          .expect((res) => {\r\n            expect([200, 401, 404]).toContain(res.status);\r\n          });\r\n      }\r\n\r\n      return request(app.getHttpServer())\r\n        .patch(`/api/portfolios/${portfolioId}/positions/${positionId}`)\r\n        .send({ quantity: 150 })\r\n        .expect((res) => {\r\n          if (res.status === 200) {\r\n            expect(res.body).toHaveProperty('quantity', 150);\r\n          }\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/portfolios/:id/positions/:positionId (DELETE)', () => {\r\n    it('should delete position', () => {\r\n      if (!portfolioId || !positionId) {\r\n        return request(app.getHttpServer())\r\n          .delete('/api/portfolios/test-id/positions/test-position-id')\r\n          .expect((res) => {\r\n            expect([200, 204, 401, 404]).toContain(res.status);\r\n          });\r\n      }\r\n\r\n      return request(app.getHttpServer())\r\n        .delete(`/api/portfolios/${portfolioId}/positions/${positionId}`)\r\n        .expect((res) => {\r\n          expect([200, 204]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/portfolios/:id/import (POST)', () => {\r\n    it('should import portfolio from file', () => {\r\n      // Mock de arquivo CSV/Excel\r\n      const csvContent = `ticker,quantity,averagePrice\r\nPETR4,100,38.50\r\nVALE3,50,65.00`;\r\n\r\n      return request(app.getHttpServer())\r\n        .post('/api/portfolios/test-id/import')\r\n        .attach('file', Buffer.from(csvContent), 'portfolio.csv')\r\n        .expect((res) => {\r\n          expect([200, 201, 401, 404]).toContain(res.status);\r\n        });\r\n    });\r\n\r\n    it('should validate file format', () => {\r\n      return request(app.getHttpServer())\r\n        .post('/api/portfolios/test-id/import')\r\n        .attach('file', Buffer.from('invalid content'), 'test.txt')\r\n        .expect((res) => {\r\n          expect([400, 401, 415]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/portfolios/:id/performance (GET)', () => {\r\n    it('should return portfolio performance metrics', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/portfolios/test-id/performance')\r\n        .expect((res) => {\r\n          expect([200, 401, 404]).toContain(res.status);\r\n          if (res.status === 200) {\r\n            expect(res.body).toHaveProperty('totalValue');\r\n            expect(res.body).toHaveProperty('totalInvested');\r\n            expect(res.body).toHaveProperty('totalGain');\r\n            expect(res.body).toHaveProperty('totalGainPercent');\r\n          }\r\n        });\r\n    });\r\n\r\n    it('should filter by date range', () => {\r\n      return request(app.getHttpServer())\r\n        .get('/api/portfolios/test-id/performance?startDate=2024-01-01&endDate=2024-12-31')\r\n        .expect((res) => {\r\n          expect([200, 401, 404]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n\r\n  describe('/api/portfolios/:id (DELETE)', () => {\r\n    it('should delete portfolio', () => {\r\n      if (!portfolioId) {\r\n        return request(app.getHttpServer())\r\n          .delete('/api/portfolios/test-id')\r\n          .expect((res) => {\r\n            expect([200, 204, 401, 404]).toContain(res.status);\r\n          });\r\n      }\r\n\r\n      return request(app.getHttpServer())\r\n        .delete(`/api/portfolios/${portfolioId}`)\r\n        .expect((res) => {\r\n          expect([200, 204]).toContain(res.status);\r\n        });\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]}]
